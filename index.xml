<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>A lifelong learner.</title>
    <link>https://egolearner.github.io/</link>
    <description>Recent content on A lifelong learner.</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 10 Sep 2024 19:31:31 +0800</lastBuildDate><atom:link href="https://egolearner.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Memory Consistency</title>
      <link>https://egolearner.github.io/post/memory-consistency/</link>
      <pubDate>Tue, 10 Sep 2024 19:31:31 +0800</pubDate>
      
      <guid>https://egolearner.github.io/post/memory-consistency/</guid>
      <description>&lt;h1 id=&#34;a-primer-on-memory-consistency-and-cache-coherence&#34;&gt;A Primer on Memory Consistency and Cache Coherence&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;书籍信息
&lt;ul&gt;
&lt;li&gt;链接
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/35125808/&#34;&gt;A Primer on Memory Consistency and Cache Coherence (豆瓣) (douban.com)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;作者&lt;/li&gt;
&lt;li&gt;题材/主题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;我为什么读这本书？
&lt;ul&gt;
&lt;li&gt;学习memory order&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;阅读前问题&lt;/li&gt;
&lt;li&gt;阅读中问题&lt;/li&gt;
&lt;li&gt;阅读时的思考&lt;/li&gt;
&lt;li&gt;主要内容&lt;/li&gt;
&lt;li&gt;本文提到的其他书籍&lt;/li&gt;
&lt;li&gt;评价
&lt;ul&gt;
&lt;li&gt;优点&lt;/li&gt;
&lt;li&gt;缺点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;chap1-introduction-to-consistency-and-coherence&#34;&gt;Chap1 Introduction to Consistency and Coherence&lt;/h2&gt;
&lt;p&gt;Consistency的定义提供了load和store的规则以及它们如何作用于内存。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h1 id="a-primer-on-memory-consistency-and-cache-coherence">A Primer on Memory Consistency and Cache Coherence</h1>
<ul>
<li>书籍信息
<ul>
<li>链接
<ul>
<li><a href="https://book.douban.com/subject/35125808/">A Primer on Memory Consistency and Cache Coherence (豆瓣) (douban.com)</a></li>
</ul>
</li>
<li>作者</li>
<li>题材/主题</li>
</ul>
</li>
<li>我为什么读这本书？
<ul>
<li>学习memory order</li>
</ul>
</li>
<li>阅读前问题</li>
<li>阅读中问题</li>
<li>阅读时的思考</li>
<li>主要内容</li>
<li>本文提到的其他书籍</li>
<li>评价
<ul>
<li>优点</li>
<li>缺点</li>
</ul>
</li>
</ul>
<h2 id="chap1-introduction-to-consistency-and-coherence">Chap1 Introduction to Consistency and Coherence</h2>
<p>Consistency的定义提供了load和store的规则以及它们如何作用于内存。</p>
<p>Coherence至于于让共享内存系统的Cache像单核系统上的Cache一样透明，使用将一个处理器的写入广播到其他处理器的方式。Consistency属于定义共享内存正确性的架构规范，而coherence是支撑consistency模型的一种方式。</p>
<p>对于特定输入的多线程程序，内存模型规定了dynamic load可以返回的值，可选的规定了内存最终的可能状态。通常允许多线程程序有多个正确的行为。</p>
<ul>
<li>Sequential Consistency(SC)中，多线程程序看起来像其中每个线程的交替执行，就像所有线程在单核机器上分时复用一样。</li>
<li>Total Store Order(TSO)，在将结果写入Cache前，使用FIFO的write buffer来保存committed store的结果。相比SC有更好的性能。</li>
<li>Relaxed or Weak Model，动机在于大部分强模型中的内存顺序是不必要的。例如，修改10个数据项和1个同步标记，10个数据项具体的内存顺序是不重要的，只需要保证在同步标记之前修改即可。</li>
</ul>
<p>在多核同时访问数据的多个副本，且至少有一个访问是写操作时会有coherence问题。使用coherence协议来避免访问到过期数据。通过广播操作使得一个处理器的写操作对其他处理器的Cache可见。目前基本是同步广播，异步广播机制正在出现。</p>
<ul>
<li><input disabled="" type="checkbox"> Database Replication. Synthesis Lectures on Data Management</li>
<li><input disabled="" type="checkbox"> Quorum Systems: With Applications to Storage and Consensus. Synthesis Lectures on Distributed Computing Theory</li>
</ul>
<h2 id="chap2-coherence-基础">Chap2 Coherence 基础</h2>
<p>在多种角色访问Cache和Memory时有coherence问题，如处理器、DMA、其他设备。</p>
<ul>
<li>
<p>Consistency-agnostic coherence。使用同步写，写操作在返回前对所有核可见，提供的接口和（不带Cache的）atomic memory system相同。</p>
<ul>
<li>single-writer-multiple-reader(SWMR)不变式。
<ul>
<li>另一种方式，使用token对SWMR不变式来解释。token个数和核数相等，拿到所有token时，可以执行写操作；拿到一个或多个token时，可以执行读操作。</li>
</ul>
</li>
<li>还要求给定内存的值被正确的广播，即数据值不变式：某个epoch开始时的值，等于上一个read-write epoch结束时的值。</li>
</ul>
<blockquote>
<p>Coherence invariants</p>
<ol>
<li>Single-Writer, Multiple-Read (SWMR) Invariant. For any memory location A, at any given time, there exists only a single core that may write to A (and can also read it) or some number of cores that may only read A.</li>
<li>Data-Value Invariant. The value of the memory location at the start of an epoch is the same as the value of the memory location at the end of the its last read-write epoch.</li>
</ol>
</blockquote>
</li>
<li>
<p>Consistency-directed coherence。写操作异步广播，coherence协议保证写操作以consistency模型强制的顺序最终可见，用以支持GP-GPU。</p>
</li>
</ul>
<p>Coherence的单位为cache block（例如cache line）。</p>
<h2 id="chap3-memory-consistency-motivation-and-sequential-consistency">Chap3 Memory Consistency Motivation and Sequential Consistency</h2>
<p>Reorder的类型</p>
<ul>
<li>Store-store reordering。如果核有非FIFO的write buffer可能会出现store-store reordering，第一个store miss而第二个store命中cache，或者第二个store可以和更早的store合并。</li>
<li>Load-load reordering。</li>
<li>Load-store和store-load reordering。
<ul>
<li>store-load reordering可能由于本地跳过了FIFO的write buffer。</li>
</ul>
</li>
</ul>
<table>
  <thead>
      <tr>
          <th style="text-align: left">Core C1</th>
          <th style="text-align: left">Core C2</th>
          <th style="text-align: left">Comments</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">S1: x = NEW;</td>
          <td style="text-align: left">S2: y = NEW;</td>
          <td style="text-align: left">/* Initially, x = 0 &amp; y = 0 */</td>
      </tr>
      <tr>
          <td style="text-align: left">L1: r1 = y;</td>
          <td style="text-align: left">L2: r2 = x;</td>
          <td style="text-align: left"></td>
      </tr>
  </tbody>
</table>
<p>大多数实际的硬件，包括x86，允许r1=0, r2=0作为最终的结果，因为它使用了FIFO的write buffer来提高性能。</p>
<p>memory model是共享内存使用共享内存执行的多线程程序允许的行为的规范。</p>
<ul>
<li>Cache coherence does not equal memory consistency.</li>
<li>A memory consistency implementation can use cache coherence as a useful “black box.”</li>
</ul>
<h3 id="sequential-consistencysc">Sequential Consistency(SC)</h3>
<p>SC最早由Lamport形式化，单核上的SC和Program Order相同，多核上的SC，如果所有核上的操作以某种顺序执行，序列中每个核的操作和Program Order相同。SC中，memory order遵循每个核上的Program Order，而其他的consistency model允许不遵守Program Order的memory order。</p>
<p>定义&lt;m为memory order, &lt;p为program order。在SC中，memory order遵守program order，即op1 &lt;p op2意味着op1 &lt;m op2。</p>
<p>3.5 SC的的规范化定义</p>
<p>L(a)和S(a)为对内存地址a的load和store操作。&lt;p为每个核上的total order，&lt;m为global memory order。</p>
<ol>
<li>所有的核将它们的load和store插入到&lt;m中，遵守其program order，无论是否是相同的地址。四种情况：
<ol>
<li>If L(a) &lt;p L(b) ⇒ L(a) &lt;m L(b) /* Load → Load */</li>
<li>If L(a) &lt;p S(b) ⇒ L(a) &lt;m S(b) /* Load → Store */</li>
<li>If S(a) &lt;p S(b) ⇒ S(a) &lt;m S(b) /* Store → Store */</li>
<li>If S(a) &lt;p L(b) ⇒ S(a) &lt;m L(b) /* Store → Load */</li>
</ol>
</li>
<li>每一个load得到的值为依global memory order在该load之前写入的值。</li>
</ol>
<p>对于原子的read-modify-write操作（如test-and-set)，要求load和store操作连续，中间不能有其他的内存操作（无论是相同还是不同的地址）。</p>
<img src="/images/A-Primer-on-Memory-Consistency-and-Cache-Coherence-044baf0ff63e42afa375411c9470a616/Untitled.png">
<p>表中定义了SC允许的行为，其中Operation 1在Operation 2之前，X意味着必须遵守program order。</p>
<p>一个SC实现只允许SC执行，这是safety属性(do no harm)，SC实现还有liveness属性(do some good)。</p>
<p>3.6 SC的naive实现</p>
<ul>
<li>
<p>使用单核来执行多线程程序， 在线程切换之前所有pending的内存操作必须完成。</p>
</li>
<li>
<p>使用一组核、内存和内存开关来实现，开关选取一个核来满足其内存访问请求，这定义了memory order &lt;m。</p>
<ul>
<li>该实现中不需要cache或者coherence。</li>
</ul>
  <img src="/images/A-Primer-on-Memory-Consistency-and-Cache-Coherence-044baf0ff63e42afa375411c9470a616/Untitled-1.png">
</li>
</ul>
<p>3.7 带有cache coherence的基本实现，能够并行的执行不冲突的load和store操作</p>
<img src="/images/A-Primer-on-Memory-Consistency-and-Cache-Coherence-044baf0ff63e42afa375411c9470a616/Untitled-2.png">
<p>这个SC实现中</p>
<ul>
<li>充分利用了cache的时延和带宽优势。</li>
<li>和它使用的cache coherence协议有相同的扩展性。</li>
<li>将实现core从实现coherence的复杂度解耦开。</li>
</ul>
<p>3.8 继续优化</p>
<ul>
<li>
<p>Non-Binding Prefetching。对块B的非绑定预取是指向coherent内存系统发请求来改变一个或多个cache中的coherence状态。重要的是，非绑定预取不会修改寄存器的状态或者块B中的数据，对memory consistency model相当于no-op。</p>
</li>
<li>
<p>Speculative Cores。推测执行在分支预测失败时，会无效化之前的操作，称为squashing，squashed的load和store操作看起来像非绑定预取，不影响SC。对store，可能会提前发起GetM预取，但只有store保证提交时才写入cache。</p>
</li>
<li>
<p>Dynamically Scheduled Cores。乱序执行，如将L2提到L1之前执行，有两种方式来检查预测的正确性。</p>
<ul>
<li>在核推测执行完L2，但在提交前，检查是否脱离了cache，监听L2相关的内存地址是否有GetM请求。</li>
<li>在核准备提交load前，重放推测的load，检查结果是否相同。</li>
</ul>
  <aside>
  💡 Flashback to Quiz Question 1: In a system that maintains sequential consistency, a core must issue coherence requests in program order. True or false?
  Answer: False! A core may issue coherence requests in any order.
  </aside>
</li>
<li>
<p>Non-Binding Prefetching in Dynamically Scheduled Cores。非绑定预取不影响SC。</p>
<ul>
<li>SC规定了load和store（看起来）应用到coherent memory的顺序，但没有规定coherent activity的顺序。</li>
</ul>
  <aside>
  💡 Flashback to Quiz Question 2: The memory consistency model specifies the legal orderings of coherence transactions. True or false?
  Answer: False!
  </aside>
</li>
<li>
<p>Multithreading。一个挑战是保证store在对其他核上的线程可见之前，相同核上的T1线程不能读到T2线程写入的值。</p>
</li>
</ul>
<p>3.9 SC下的原子操作</p>
<p>原子的atomic-read-write操作可以如下优化：一个核以M状态获取到cache，然后只需要load和store它的cache块，没有任何的coherence message或者锁总线，只要它直到store之后才服务任何的coherence请求。(个人理解：变成M之后，只要它不响应coherence请求，其他的核就没法得到S或M状态的cache，因此不能读，也不能写。）</p>
<aside>
💡 Flashback to Quiz Question 3: To perform an atomic read-modify-write instruction (e.g., test-and-set), a core must always communicate with the other cores. True or false?
Answer: False!
</aside>
<p>更进一步的优化为推测执行，如果cache的状态已经为S，RMW的load部分可以马上推测执行，同时cache控制器发起修改为M状态。在cache变为M状态后，再执行写部分。使用和前面类似的方式来检测预测失败，即cache是否被弹出。</p>
<h2 id="chap4-total-store-order-and-the-x86-memory-model">Chap4 Total Store Order and the x86 Memory Model</h2>
<p>在cache进入read-write coherence状态之前store可以进入write buffer。write buffer隐藏了store miss的延迟。</p>
<p>如果使用激进的预测SC实现来使得write buffer透明的话，复杂性很高，检测violation和处理mis-speculation的功耗很高。因此出现 了TSO模型。</p>
<p>TSO/X86的形式化定义</p>
<ol>
<li>相比SC会出现Store-Load的reorder，增加了FIFO的write buffer。</li>
<li>Load读到同一地址上一次Store的值。优先是按照program order在之前写入的值（从write buffer读），其次是按照memory order在之前写入的值。</li>
<li>提供了FENCE来保证顺序。
<ol>
<li>If S(a) &lt;p FENCE ⇒ S(a) &lt;m FENCE /* Store → FENCE */</li>
<li>If FENCE &lt;p L(a) ⇒ FENCE &lt;m L(a) /* FENCE → Load */</li>
</ol>
</li>
</ol>
<img src="/images/A-Primer-on-Memory-Consistency-and-Cache-Coherence-044baf0ff63e42afa375411c9470a616/Untitled-3.png">
<p>B意味着对相同地址需要bypassing。</p>
<p>AMD和Interl还没有正式的规范表明是TSO，但是所有的例子都符合TSO。</p>
<img src="/images/A-Primer-on-Memory-Consistency-and-Cache-Coherence-044baf0ff63e42afa375411c9470a616/Untitled-4.png">
<p>在4.4a中</p>
<ul>
<li>Load和Store以&lt;p离开核。</li>
<li>Load要么从write buffer bypass值，要么等待switch。</li>
<li>Store进入FIFO write buffer的尾部，如果满了则stall。</li>
<li>Switch选择某个核时，要么执行Load，要么执行write buffer头部的store。</li>
</ul>
<p>4.4b中，之前讨论的SC实现依然适用。大多数TSO实现都是在SC实现上插入了write buffer。</p>
<p>对多线程的core，一个线程上下文不应该bypass另一个线程上下文的write buffer。可以实现为每个线程上下文的write buffer，或者共享的write buffer加上线程上下文tag。后者更加常见。</p>
<aside>
💡 Flashback to Quiz Question 4: In a TSO system with multithreaded cores, threads may bypass values out of the write buffer, regardless of which thread wrote the value. True or false? 
Answer: False! A thread may bypass values that it has written, but other threads may not see the value until the store is inserted into the memory order.
</aside>
<p>read-modify-write实现。按照TSO定义，RMW的load不能跳过之前的load。如果RMW的load跳过了之前的store，因为RMW是原子的，其store也要跳过之前的store，而TSO是不允许store跳过store的。</p>
<p>RMW需要之前的store有序，即需要排干write buffer。为了保证RMW的store马上在load之后，需要获得read-write的coherence权限。为了保证原子性，在load和store之间不能放弃coherence权限。</p>
<p>更多的优化是可行的。write-buffer在满足下面的条件时不需要排干</p>
<ul>
<li>
<p>在write-buffer中的每个项在cache中有read-write权限，并在RMW提交前保持read-write权限。</p>
</li>
<li>
<p>使用MIPS R1000风格的load speculation检查。</p>
<blockquote>
<p>在cache block弹出时的地址如果和load speculation的地址相同，会使得load和之前的指令都失效。在Load提交时，它一直保持在cache中，值必然相同。</p>
</blockquote>
</li>
</ul>
<p>逻辑上来说，RMW之前的load和store作为一个chunk整体提交。</p>
<p>FENCE的语义是FENCE之前的指令必须排序（应该是&lt;m）在之后的指令之前。TSO下的FENCE不频繁，性能要求不高，在排干write buffer之后再执行load就足够了。</p>
<p>SC是TSO的子集。</p>
<img src="/images/A-Primer-on-Memory-Consistency-and-Cache-Coherence-044baf0ff63e42afa375411c9470a616/Untitled-5.png">
<h2 id="chap5-relaxed-memory-consistency">Chap5 Relaxed Memory Consistency</h2>
<p>5.1 动机</p>
<p>RMO只保持程序员需要的顺序。</p>
<p>如果操作不依赖许多Load和Store之间的顺序，使用relaxing order可以获得更高的性能。</p>
<p>优化的机会包括</p>
<ul>
<li>使用非FIFO的write buffer，来获得更多的写合并。</li>
<li>不需要做复杂的core speculation，本身就允许乱序的load。</li>
<li>通过打开coherence魔盒，来获得更高的性能。允许一组核读到最新的值，而其他的核读到老的值。</li>
</ul>
<h3 id="example-relaxed-consistency-modelxc">eXample relaxed Consistency Model(XC)</h3>
<p>XC不是实际的模型，假定存在global memory order，和不再使用的Alpha, SPARC RMO相同。</p>
<p>XC对相同地址的访问维护TSO规则。</p>
<ul>
<li>相同地址的Load → Load</li>
<li>相同地址的Load → Store</li>
<li>相同地址的Store → Store</li>
</ul>
<p>XC中的Load马上就能看到对自己核的更新（就像TSO的write buffer bypassing)。</p>
<p>XC的形式化定义</p>
<ol>
<li>
<p>所有的核将load, store和FENCE插入&lt;m，并遵循下面的规则</p>
<ul>
<li>If L(a) &lt;p FENCE  ⇒ L(a) &lt;m FENCE                  /* Load → FENCE */</li>
<li>If S(a) &lt;p FENCE  ⇒ S(a) &lt;m FENCE                  /* Store → FENCE */</li>
<li>If FENCE &lt;p FENCE  ⇒ FENCE &lt;m FENCE                  /* FENCE → FENCE */</li>
<li>If FENCE &lt;p L(a)  ⇒ FENCE &lt;m L(a)                  /* FENCE → LOAD */</li>
<li>If FENCE &lt;p S(a)  ⇒ FENCE &lt;m S(a)                  /* FENCE → STORE */</li>
</ul>
</li>
<li>
<p>所有的核将对相同地址的load和store插入&lt;m，并遵循下面的规则</p>
<ul>
<li>If L(a) &lt;p L’(a) ⇒ L(a) &lt;m L’ (a)        /* Load → Load to same address */</li>
<li>If L(a) &lt;p S(a) ⇒ L(a) &lt;m S(a)        /* Load → Store to same address */</li>
<li>If S(a) &lt;p S’(a) ⇒ S(a) &lt;m S’ (a)        /* Store → Store to same address */</li>
</ul>
</li>
<li>
<p>Load得到对相同地址的Store的值。</p>
<p>Value of L(a) = Value of MAX &lt;m {S(a) | S(a) &lt;m L(a) or S(a) &lt;p L(a)} /* Like TSO */</p>
</li>
</ol>
<img src="/images/A-Primer-on-Memory-Consistency-and-Cache-Coherence-044baf0ff63e42afa375411c9470a616/Untitled-6.png">
<ul>
<li>B指对相同地址需要bypassing。</li>
<li>A指对相同地址才保持顺序。</li>
</ul>
<p>实现XC</p>
<img src="/images/A-Primer-on-Memory-Consistency-and-Cache-Coherence-044baf0ff63e42afa375411c9470a616/Untitled-7.png">
<p>相比TSO，加上了reorder unit。</p>
<ul>
<li>Load, Store, FENCE以&lt;p顺序进入reorder的尾部</li>
<li>reorder unit遵循一定规则进行reorder，将操作从尾部移动到头部。FENCE到达头部后被丢弃。</li>
<li>switch选取某个core时，执行reorder头部的store或者load。</li>
</ul>
<p>作者之前预测speculative core会逐渐取代relaxed model，既能保证性能，接口又更加简单，但两方面的原因导致没有发生：厂商的冲量；低功耗的场景做不到高speculative。</p>
<p>XC的原子指令</p>
<p>XC中的RMW不需要draining write buffer，只需要获取到read-write权限，并在load部分和store部分之间不能放手。</p>
<p>TSO中的原子RMW就足以实现锁，而在XC中需要前后加上FENCE。</p>
<img src="/images/A-Primer-on-Memory-Consistency-and-Cache-Coherence-044baf0ff63e42afa375411c9470a616/Untitled-8.png">
<p>XC中的FENCE实现</p>
<ul>
<li>实现SC，将FENCE作为no-op</li>
<li>将FENCE实现为drain之前的内存操作。</li>
<li>不drain，怎么做书里面没讲。</li>
</ul>
<p>上面所有的情况中，FENCE都需要知道FENCE前的操作Xi是否结束了，在某些情况下非常tricky。</p>
<h3 id="sc-for-drfdata-race-free">SC for DRF(data race free)</h3>
<p>用于高阶语言做抽象，除了指定的同步操作需要保持顺序外，其他的操作允许做reorder。SC for DRF概括为下面两条</p>
<ul>
<li>要么有data race，暴露了类似XC的load和store的reordering</li>
<li>要么data race free，执行看起来就像SC。</li>
</ul>
<p>SC for DRF可以让程序员使用SC来论证程序的正确性，而不需要考虑更复杂的XC规则，而且能从XC相比SC的硬件性能提高或操作简化中受益。</p>
<img src="/images/A-Primer-on-Memory-Consistency-and-Cache-Coherence-044baf0ff63e42afa375411c9470a616/Untitled-9.png">
<p>在HLL中只在必要的地方加上同步，如atomic和synchronized，在low-level program根据硬件产生合适的指令。</p>
<p>Java中的内存操作都是SC，C++允许更relaxed的模型。</p>
<aside>
💡 Flashback to Quiz Question 5: A programmer who writes properly synchronized code relative to the high-level language consistency model (e.g,. Java) does not need to consider the architecture’s memory consistency model. True or false?
Answer: It depends. For typical application programmers, the answer is True, because their programs behave as expected (SC is expected). For the programmers of compilers and runtime systems, the answer is False.
</aside>
<p>ARMv7似乎不保证total memory order，ARMv8切换到了提供total memory order的multi-copy atomic memory order。</p>
<blockquote>
<p>write atomicity, store atomicity, multi-copy atomicity。是指一个核的store在逻辑上被其他核同时可见。
write atomicity能够推导出causality，反之不然。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>Quotient Filter</title>
      <link>https://egolearner.github.io/post/quotient-filter/</link>
      <pubDate>Sun, 04 Aug 2024 23:44:31 +0800</pubDate>
      
      <guid>https://egolearner.github.io/post/quotient-filter/</guid>
      <description>&lt;p&gt;quotient filter(QF)不存储原始的key，而是存储原始key的指纹，因此在指纹冲突时，无法区分key是否真的存在，此时也会false positive。论文中硬冲突定义为指纹冲突，软冲突定义为指纹不同但是商相同。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>quotient filter(QF)不存储原始的key，而是存储原始key的指纹，因此在指纹冲突时，无法区分key是否真的存在，此时也会false positive。论文中硬冲突定义为指纹冲突，软冲突定义为指纹不同但是商相同。</p>
<p>相比bloom filter的优势</p>
<ul>
<li>cache友好。</li>
<li>支持扩容。</li>
<li>支持合并。</li>
<li>支持删除。</li>
</ul>
<h2 id="原理">原理</h2>
<p>quotient filter底层实现使用了hash table。Quotienting将指纹分为商和余数两部分，商为指纹的高q位，余数为指纹的低r位。商用于定位到hash表的bucket，而余数则作为hash表的值存储起来。注意，通过将商和余数结合起来能够重建hash，而不需要使用原始的key重新哈希，这也是quotient filter支持扩容和合并等操作的关键所在。</p>
<p>在hash表冲突（即不同key的指纹的商相同）时，使用线性探测法来存储。使用线性推测法时，相同商的指纹的余数部分连续存储。quotient附加了额外的约束来加快检索，要求余数从小到大排序。排序有三个作用</p>
<ol>
<li>检索时只需要扫描到≥余数的桶就可以停止扫描；</li>
<li>在合并QF时可以有序合并；</li>
<li>扩容时效率更高。扩容时增加商的位数，将余数的高位移至商的低位。余数的有序性保证了顺序扫描时新的商和新的余数都是递增的。</li>
</ol>
<p>相同商的指纹的余数构成了一个run，由于冲突的存在，一个run的实际存储位置和正式位置（根据商定位到的bucket）会不同。 run 指的是一段商相同的连续记录的余数，如下图 c、d、e 的商均为 3；cluster 指多个连续的 run，并且首个 run 从商对应的位置开始，而后续的 run 并不是从商对应的位置开始的。如图中标出的 cluster，首个 run 从 3 开始，和商相同，第二个 run 从 6 开始，而余数为 4，第三个 run 从 7 开始，而余数为 6。</p>
<p>其中在存储余数的同时，还会在每个哈希桶中增设 3 个元信息位<code>is_occupied</code>、<code>is_continuation</code>和<code>is_shifted</code>。<code>is_occupied</code>表示过滤器中是否有和余数对应的商，其与下标所对应的商相同，如 c、d、e 的商均为 3，因此下标为 3 的哈希桶<code>is_occupied</code>位是 1。<code>is_continuation</code>表示当前哈希桶中的余数，是否和左边相邻的元素属于一个 run，如下标 4 的哈希桶中余数，与下标 3 的哈希桶中余数属于一个 run，因此<code>is_continuation</code>为 1。<code>is_shifted</code>表示余数存储的位置是否和余数对应的商表示的下标有偏移，如 c 存储的位置与 c 对应的商表示的下标均为 3，因此<code>is_shifted</code>为 0；而 f 存储的位置为 6，f 对应的商表示的下标为 4，因此<code>is_shifted</code>为 1。</p>
<img src="/static/quotient%20filter%205cc6b128afa041a3ae2a565a9479ea03/Untitled.png">
<p>上图给出了一个示例，分别是等价的使用开链和使用线性探测结合元信息bit位的hash表示。</p>
<p><a href="https://en.wikipedia.org/wiki/Quotient_filter">Quotient filter - Wikipedia</a></p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">is_occupied</th>
          <th style="text-align: left">is_continuation</th>
          <th style="text-align: left">is_shifted</th>
          <th style="text-align: left">meaning</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">0</td>
          <td style="text-align: left">0</td>
          <td style="text-align: left">0</td>
          <td style="text-align: left">Empty Slot</td>
      </tr>
      <tr>
          <td style="text-align: left">0</td>
          <td style="text-align: left">0</td>
          <td style="text-align: left">1</td>
          <td style="text-align: left">Slot is holding start of run that has been shifted from its canonical slot.</td>
      </tr>
      <tr>
          <td style="text-align: left">0</td>
          <td style="text-align: left">1</td>
          <td style="text-align: left">0</td>
          <td style="text-align: left">not used.</td>
      </tr>
      <tr>
          <td style="text-align: left">0</td>
          <td style="text-align: left">1</td>
          <td style="text-align: left">1</td>
          <td style="text-align: left">Slot is holding continuation of run that has been shifted from its canonical slot.</td>
      </tr>
      <tr>
          <td style="text-align: left">1</td>
          <td style="text-align: left">0</td>
          <td style="text-align: left">0</td>
          <td style="text-align: left">Slot is holding start of run that is in its canonical slot.This is also the start of the cluster.</td>
      </tr>
      <tr>
          <td style="text-align: left">1</td>
          <td style="text-align: left">0</td>
          <td style="text-align: left">1</td>
          <td style="text-align: left">Slot is holding start of run that has been shifted from its canonical slot.Also the run for which this is the canonical slot exists but is shifted right.</td>
      </tr>
      <tr>
          <td style="text-align: left">1</td>
          <td style="text-align: left">1</td>
          <td style="text-align: left">0</td>
          <td style="text-align: left">not used.</td>
      </tr>
      <tr>
          <td style="text-align: left">1</td>
          <td style="text-align: left">1</td>
          <td style="text-align: left">1</td>
          <td style="text-align: left">Slot is holding continuation of run that has been shifted from its canonical slot.Also the run for which this is the canonical slot exists but is shifted right.</td>
      </tr>
  </tbody>
</table>
<h2 id="实现">实现</h2>
<p>下文中的代码均来自 <a href="https://github.com/vedantk/quotient-filter">https://github.com/vedantk/quotient-filter</a> 。</p>
<h3 id="定位run的起始下标">定位run的起始下标</h3>
<p>fq为要查找的商。由于前面的商可能挤占了fq的位置，fq不一定在正式的位置。</p>
<ol>
<li>第1个循环向左查找，找到cluster的起始位置。cluster起始位置的is-shifted位一定为0.</li>
<li>第2.1个循环跳过其他的run，找到下一个没有设置is-continuation的下标。</li>
<li>第2.2个循环找到下一个run，即设置了is-occupied的下标。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* Find the start index of the run for fq (given that the run exists). */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">uint64_t</span> <span class="nf">find_run_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">quotient_filter</span> <span class="o">*</span><span class="n">qf</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">fq</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="cm">/* Find the start of the cluster. */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint64_t</span> <span class="n">b</span> <span class="o">=</span> <span class="n">fq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span> <span class="p">(</span><span class="nf">is_shifted</span><span class="p">(</span><span class="nf">get_elem</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">b</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">b</span> <span class="o">=</span> <span class="nf">decr</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/* Find the start of the run for fq. */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint64_t</span> <span class="n">s</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span> <span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="n">fq</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">s</span> <span class="o">=</span> <span class="nf">incr</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nf">is_continuation</span><span class="p">(</span><span class="nf">get_elem</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">s</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">b</span> <span class="o">=</span> <span class="nf">incr</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nf">is_occupied</span><span class="p">(</span><span class="nf">get_elem</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">b</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="查找">查找</h3>
<ol>
<li>计算商fq和余数fr，T_fq为fq处存储的值。</li>
<li>如果is-occupied位没有设置，则一定不存在。</li>
<li>找到run的起始位置，依次扫描run中的元素，如果余数相同，则可能存在。如果余数大于fr，则一定不存在。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-elm" data-lang="elm"><span class="line"><span class="cl"><span class="nv">bool</span> <span class="nv">qf_may_contain</span><span class="p">(</span><span class="nv">struct</span> <span class="nv">quotient_filter</span> <span class="nf">*</span><span class="nv">qf</span><span class="p">,</span> <span class="nv">uint</span><span class="mi">64</span><span class="nv">_t</span> <span class="nv">hash</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nv">uint</span><span class="mi">64</span><span class="nv">_t</span> <span class="nv">fq</span> <span class="nf">=</span> <span class="nv">hash_to_quotient</span><span class="p">(</span><span class="nv">qf</span><span class="p">,</span> <span class="nv">hash</span><span class="p">)</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">	<span class="nv">uint</span><span class="mi">64</span><span class="nv">_t</span> <span class="nv">fr</span> <span class="nf">=</span> <span class="nv">hash_to_remainder</span><span class="p">(</span><span class="nv">qf</span><span class="p">,</span> <span class="nv">hash</span><span class="p">)</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">	<span class="nv">uint</span><span class="mi">64</span><span class="nv">_t</span> <span class="kt">T_fq</span> <span class="nf">=</span> <span class="nv">get_elem</span><span class="p">(</span><span class="nv">qf</span><span class="p">,</span> <span class="nv">fq</span><span class="p">)</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">/*</span> <span class="kt">If</span> <span class="nv">this</span> <span class="nv">quotient</span> <span class="nv">has</span> <span class="nv">no</span> <span class="nv">run</span><span class="p">,</span> <span class="nv">give</span> <span class="nv">up</span><span class="nf">.</span> <span class="nf">*/</span>
</span></span><span class="line"><span class="cl">	<span class="kr">if</span> <span class="p">(</span><span class="err">!</span><span class="nv">is_occupied</span><span class="p">(</span><span class="kt">T_fq</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nv">return</span> <span class="nv">false</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">/*</span> <span class="kt">Scan</span> <span class="nv">the</span> <span class="nv">sorted</span> <span class="nv">run</span> <span class="nv">for</span> <span class="nv">the</span> <span class="nv">target</span> <span class="nv">remainder</span><span class="nf">.</span> <span class="nf">*/</span>
</span></span><span class="line"><span class="cl">	<span class="nv">uint</span><span class="mi">64</span><span class="nv">_t</span> <span class="nv">s</span> <span class="nf">=</span> <span class="nv">find_run_index</span><span class="p">(</span><span class="nv">qf</span><span class="p">,</span> <span class="nv">fq</span><span class="p">)</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">	<span class="nv">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nv">uint</span><span class="mi">64</span><span class="nv">_t</span> <span class="nv">rem</span> <span class="nf">=</span> <span class="nv">get_remainder</span><span class="p">(</span><span class="nv">get_elem</span><span class="p">(</span><span class="nv">qf</span><span class="p">,</span> <span class="nv">s</span><span class="p">))</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">		<span class="kr">if</span> <span class="p">(</span><span class="nv">rem</span> <span class="nf">==</span> <span class="nv">fr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nv">return</span> <span class="nv">true</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="kr">else</span> <span class="kr">if</span> <span class="p">(</span><span class="nv">rem</span> <span class="nf">&gt;</span> <span class="nv">fr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nv">return</span> <span class="nv">false</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nv">s</span> <span class="nf">=</span> <span class="nv">incr</span><span class="p">(</span><span class="nv">qf</span><span class="p">,</span> <span class="nv">s</span><span class="p">)</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="nv">while</span> <span class="p">(</span><span class="nv">is_continuation</span><span class="p">(</span><span class="nv">get_elem</span><span class="p">(</span><span class="nv">qf</span><span class="p">,</span> <span class="nv">s</span><span class="p">)))</span><span class="err">;</span>
</span></span><span class="line"><span class="cl">	<span class="nv">return</span> <span class="nv">false</span><span class="err">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="插入">插入</h3>
<p>元信息变更情况：</p>
<ul>
<li>桶fq 的<code>is_occupied</code>需置为 1</li>
<li>若元素并不是 run 内的首个元素，则需要将元素 remainder 的<code>is_continuation</code>置为 1，否则将当前 run 开始的<code>is_continuation</code>置为 1（因为添加完成后，当前 run 的开始变成了延续）</li>
<li>向后移动已有 remainder 时<code>is_shifted</code>均会置 1，<code>is_occupied</code>保持在原有的 quotient 处</li>
</ul>
<p>具体步骤</p>
<ol>
<li>计算余数fq，商fr，T_fq为fq处的值。</li>
<li>第13行为最基本的情况，位置为空，即3个位都没有设置，此时设置is-occupied位，并填充余数就大功告成了。</li>
<li>19行判断如果没有设置过is-occupied位， 则进行设置。</li>
<li>26行判断如果已经设置过is-occupied位，则需要找到fr的插入位置，即已有余数中&gt;fr的第一个位置。38行中fr为run的新head时，原有head需要设置is-continuation位，否则44行设置新元素的is-continuation位。</li>
<li>后面调用insert_into来将entry插入到QF中。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">qf_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">quotient_filter</span> <span class="o">*</span><span class="n">qf</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">hash</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">qf</span><span class="o">-&gt;</span><span class="n">qf_entries</span> <span class="o">&gt;=</span> <span class="n">qf</span><span class="o">-&gt;</span><span class="n">qf_max_size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">uint64_t</span> <span class="n">fq</span> <span class="o">=</span> <span class="nf">hash_to_quotient</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint64_t</span> <span class="n">fr</span> <span class="o">=</span> <span class="nf">hash_to_remainder</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint64_t</span> <span class="n">T_fq</span> <span class="o">=</span> <span class="nf">get_elem</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">fq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint64_t</span> <span class="n">entry</span> <span class="o">=</span> <span class="p">(</span><span class="n">fr</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/* Special-case filling canonical slots to simplify insert_into(). */</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">is_empty_element</span><span class="p">(</span><span class="n">T_fq</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">set_elem</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">fq</span><span class="p">,</span> <span class="nf">set_occupied</span><span class="p">(</span><span class="n">entry</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">		<span class="o">++</span><span class="n">qf</span><span class="o">-&gt;</span><span class="n">qf_entries</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">is_occupied</span><span class="p">(</span><span class="n">T_fq</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">set_elem</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">fq</span><span class="p">,</span> <span class="nf">set_occupied</span><span class="p">(</span><span class="n">T_fq</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">uint64_t</span> <span class="n">start</span> <span class="o">=</span> <span class="nf">find_run_index</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">fq</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint64_t</span> <span class="n">s</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">is_occupied</span><span class="p">(</span><span class="n">T_fq</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="cm">/* Move the cursor to the insert position in the fq run. */</span>
</span></span><span class="line"><span class="cl">		<span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kt">uint64_t</span> <span class="n">rem</span> <span class="o">=</span> <span class="nf">get_remainder</span><span class="p">(</span><span class="nf">get_elem</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">s</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">rem</span> <span class="o">==</span> <span class="n">fr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rem</span> <span class="o">&gt;</span> <span class="n">fr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="n">s</span> <span class="o">=</span> <span class="nf">incr</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nf">is_continuation</span><span class="p">(</span><span class="nf">get_elem</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">s</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="cm">/* The old start-of-run becomes a continuation. */</span>
</span></span><span class="line"><span class="cl">			<span class="kt">uint64_t</span> <span class="n">old_head</span> <span class="o">=</span> <span class="nf">get_elem</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="nf">set_elem</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="nf">set_continuation</span><span class="p">(</span><span class="n">old_head</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="cm">/* The new element becomes a continuation. */</span>
</span></span><span class="line"><span class="cl">			<span class="n">entry</span> <span class="o">=</span> <span class="nf">set_continuation</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="cm">/* Set the shifted bit if we can&#39;t use the canonical slot. */</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">fq</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">entry</span> <span class="o">=</span> <span class="nf">set_shifted</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">insert_into</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="o">++</span><span class="n">qf</span><span class="o">-&gt;</span><span class="n">qf_entries</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>insert_into需要将elt写到s指定的桶。</p>
<ol>
<li>在循环中读取s当前的值prev，如果非空的话，需要设置is-shifted标记，并根据是否is-occupied标记，设置curr的is-occupied位，清理prev的is-occupied位。</li>
<li>更新s的桶为curr。</li>
<li>重复1和2直到遇到一个空桶。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* Insert elt into QF[s], shifting over elements as necessary. */</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">insert_into</span><span class="p">(</span><span class="k">struct</span> <span class="n">quotient_filter</span> <span class="o">*</span><span class="n">qf</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">s</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">elt</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint64_t</span> <span class="n">prev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint64_t</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">elt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="n">empty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">prev</span> <span class="o">=</span> <span class="nf">get_elem</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">empty</span> <span class="o">=</span> <span class="nf">is_empty_element</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">empty</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="cm">/* Fix up `is_shifted&#39; and `is_occupied&#39;. */</span>
</span></span><span class="line"><span class="cl">			<span class="n">prev</span> <span class="o">=</span> <span class="nf">set_shifted</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="nf">is_occupied</span><span class="p">(</span><span class="n">prev</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">curr</span> <span class="o">=</span> <span class="nf">set_occupied</span><span class="p">(</span><span class="n">curr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">				<span class="n">prev</span> <span class="o">=</span> <span class="nf">clr_occupied</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nf">set_elem</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">curr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="n">curr</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">s</span> <span class="o">=</span> <span class="nf">incr</span><span class="p">(</span><span class="n">qf</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">empty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考资料">参考资料</h2>
<p><a href="https://zhuanlan.zhihu.com/p/624438262">Quotient Filter 各类操作分析 - 知乎 (zhihu.com)</a></p>
<p><a href="http://dept.cs.williams.edu/~jannen/teaching/s20/cs333/meetings/Filters-slides.pdf">http://dept.cs.williams.edu/~jannen/teaching/s20/cs333/meetings/Filters-slides.pdf</a></p>
<p><a href="https://en.wikipedia.org/wiki/Quotient_filter">https://en.wikipedia.org/wiki/Quotient_filter</a></p>
<p><a href="https://www.gakhov.com/articles/quotient-filters.html">https://www.gakhov.com/articles/quotient-filters.html</a></p>
<p><a href="https://systemdesign.one/quotient-filter-explained/#variants-of-quotientfilter">https://systemdesign.one/quotient-filter-explained/#variants-of-quotientfilter</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>simple-sqlite源码笔记</title>
      <link>https://egolearner.github.io/post/simple-sqlite-source-read/</link>
      <pubDate>Thu, 08 Dec 2022 08:29:57 +0800</pubDate>
      
      <guid>https://egolearner.github.io/post/simple-sqlite-source-read/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/madushadhanushka/simple-sqlite&#34;&gt;https://github.com/madushadhanushka/simple-sqlite&lt;/a&gt; 是从sqlite 2.5.0 抽取出的核心逻辑，适合用来学习sqlite的后端实现，如&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何实现page buffer&lt;/li&gt;
&lt;li&gt;如何实现基于磁盘的B树&lt;/li&gt;
&lt;li&gt;如何通过rollback journaling来实现事务支持和crash recovery&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;page-buffer-bool&#34;&gt;page buffer bool&lt;/h2&gt;
&lt;h3 id=&#34;page和pager实现&#34;&gt;page和pager实现&lt;/h3&gt;
&lt;p&gt;先看page的实现。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p><a href="https://github.com/madushadhanushka/simple-sqlite">https://github.com/madushadhanushka/simple-sqlite</a> 是从sqlite 2.5.0 抽取出的核心逻辑，适合用来学习sqlite的后端实现，如</p>
<ol>
<li>如何实现page buffer</li>
<li>如何实现基于磁盘的B树</li>
<li>如何通过rollback journaling来实现事务支持和crash recovery</li>
</ol>
<h2 id="page-buffer-bool">page buffer bool</h2>
<h3 id="page和pager实现">page和pager实现</h3>
<p>先看page的实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// page size 大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define SQLITE_PAGE_SIZE 1024
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 页号。0 代表 &#34;not a page&#34;, 文件中的第一个页从1开始。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Pgno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">** Each in-memory image of a page begins with the following header.
</span></span></span><span class="line"><span class="cl"><span class="cm">** This header is only visible to this pager module.  The client
</span></span></span><span class="line"><span class="cl"><span class="cm">** code that calls pager sees only the data that follows the header.
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">PgHdr</span> <span class="n">PgHdr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">PgHdr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Pager</span> <span class="o">*</span><span class="n">pPager</span><span class="p">;</span>                 <span class="cm">/* The pager to which this page belongs */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Pgno</span> <span class="n">pgno</span><span class="p">;</span>                     <span class="cm">/* The page number for this page */</span>
</span></span><span class="line"><span class="cl">  <span class="n">PgHdr</span> <span class="o">*</span><span class="n">pNextHash</span><span class="p">,</span> <span class="o">*</span><span class="n">pPrevHash</span><span class="p">;</span>  <span class="cm">/* Hash collision chain for PgHdr.pgno */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">nRef</span><span class="p">;</span>                      <span class="cm">/* Number of users of this page */</span>
</span></span><span class="line"><span class="cl">  <span class="n">PgHdr</span> <span class="o">*</span><span class="n">pNextFree</span><span class="p">,</span> <span class="o">*</span><span class="n">pPrevFree</span><span class="p">;</span>  <span class="cm">/* Freelist of pages where nRef==0 */</span>
</span></span><span class="line"><span class="cl">  <span class="n">PgHdr</span> <span class="o">*</span><span class="n">pNextAll</span><span class="p">,</span> <span class="o">*</span><span class="n">pPrevAll</span><span class="p">;</span>    <span class="cm">/* A list of all pages */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">inJournal</span><span class="p">;</span>                <span class="cm">/* TRUE if has been written to journal */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">inCkpt</span><span class="p">;</span>                   <span class="cm">/* TRUE if written to the checkpoint journal */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">dirty</span><span class="p">;</span>                    <span class="cm">/* TRUE if we need to write back changes */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* SQLITE_PAGE_SIZE bytes of page data follow this header */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Pager.nExtra bytes of local data follow the page data */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>每个page的大小为SQLITE_PAGE_SIZE。PgHdr是page前面的一段内存，用于簿记一些信息，如是否是脏页(dirty)，是否已写入journal或checkpoint文件(inJournal, inCkpt)，页号（pgno），引用数(nRef)等。此外还记录一些双链表的next/prev指针，pNextHash记录哈希表的冲突链，pNextFree记录空闲页，pNextAll记录所有页。</p>
<p>在内存中布局如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="o">|</span>    <span class="k">sizeof</span><span class="p">(</span><span class="n">PgHdr</span><span class="p">)</span>   <span class="o">|</span>        <span class="n">SQLITE_PAGE_SIZE</span>     <span class="o">|</span>   <span class="n">Pager</span><span class="p">.</span><span class="n">nExtra</span>      <span class="o">|</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>按照上面的布局，定义了如下的宏来做内存地址的转换</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">** Convert a pointer to a PgHdr into a pointer to its data
</span></span></span><span class="line"><span class="cl"><span class="cm">** and back again.
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#define PGHDR_TO_DATA(P)  ((void*)(&amp;(P)[1]))
</span></span></span><span class="line"><span class="cl"><span class="cp">#define DATA_TO_PGHDR(D)  (&amp;((PgHdr*)(D))[-1])
</span></span></span><span class="line"><span class="cl"><span class="cp">#define PGHDR_TO_EXTRA(P) ((void*)&amp;((char*)(&amp;(P)[1]))[SQLITE_PAGE_SIZE])
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我们看PGHDR_TO_DATA的实现。最简单的情况下， <code>PgHdr* P = init xxx;</code> 把P当作一个数组，P[1] 相当于 P + sizeof(PgHdr)，指向了page的内存，&amp;P[1]的类型仍然为PgHdr*， 再将其转为void* 类型。sqlite实现时大量采用了类似的技巧。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">** A open page cache is an instance of the following structure.
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Pager</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="o">*</span><span class="n">zFilename</span><span class="p">;</span>            <span class="cm">/* Name of the database file */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="o">*</span><span class="n">zJournal</span><span class="p">;</span>             <span class="cm">/* Name of the journal file */</span>
</span></span><span class="line"><span class="cl">  <span class="n">OsFile</span> <span class="n">fd</span><span class="p">,</span> <span class="n">jfd</span><span class="p">;</span>             <span class="cm">/* File descriptors for database and journal */</span>
</span></span><span class="line"><span class="cl">  <span class="n">OsFile</span> <span class="n">cpfd</span><span class="p">;</span>                <span class="cm">/* File descriptor for the checkpoint journal */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// page个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">dbSize</span><span class="p">;</span>                 <span class="cm">/* Number of pages in the file */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">origDbSize</span><span class="p">;</span>             <span class="cm">/* dbSize before the current change */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">ckptSize</span><span class="p">,</span> <span class="n">ckptJSize</span><span class="p">;</span>    <span class="cm">/* Size of database and journal at ckpt_begin() */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">nExtra</span><span class="p">;</span>                 <span class="cm">/* Add this many bytes to each in-memory page */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 用于做一些B树的清理工作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">xDestructor</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span> <span class="cm">/* Call this routine when freeing pages */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">nPage</span><span class="p">;</span>                  <span class="cm">/* Total number of in-memory pages */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">nRef</span><span class="p">;</span>                   <span class="cm">/* Number of in-memory pages with PgHdr.nRef&gt;0 */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">mxPage</span><span class="p">;</span>                 <span class="cm">/* Maximum number of pages to hold in cache */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">nHit</span><span class="p">,</span> <span class="n">nMiss</span><span class="p">,</span> <span class="n">nOvfl</span><span class="p">;</span>     <span class="cm">/* Cache hits, missing, and LRU overflows */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u8</span> <span class="n">journalOpen</span><span class="p">;</span>             <span class="cm">/* True if journal file descriptors is valid */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u8</span> <span class="n">ckptOpen</span><span class="p">;</span>                <span class="cm">/* True if the checkpoint journal is open */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u8</span> <span class="n">ckptInUse</span><span class="p">;</span>               <span class="cm">/* True we are in a checkpoint */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u8</span> <span class="n">noSync</span><span class="p">;</span>                  <span class="cm">/* Do not sync the journal if true */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u8</span> <span class="n">state</span><span class="p">;</span>                   <span class="cm">/* SQLITE_UNLOCK, _READLOCK or _WRITELOCK */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u8</span> <span class="n">errMask</span><span class="p">;</span>                 <span class="cm">/* One of several kinds of errors */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u8</span> <span class="n">tempFile</span><span class="p">;</span>                <span class="cm">/* zFilename is a temporary file */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u8</span> <span class="n">readOnly</span><span class="p">;</span>                <span class="cm">/* True for a read-only database */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u8</span> <span class="n">needSync</span><span class="p">;</span>                <span class="cm">/* True if an fsync() is needed on the journal */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u8</span> <span class="n">dirtyFile</span><span class="p">;</span>               <span class="cm">/* True if database file has changed in any way */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u8</span> <span class="o">*</span><span class="n">aInJournal</span><span class="p">;</span>             <span class="cm">/* One bit for each page in the database file */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u8</span> <span class="o">*</span><span class="n">aInCkpt</span><span class="p">;</span>                <span class="cm">/* One bit for each page in the database */</span>
</span></span><span class="line"><span class="cl">  <span class="n">PgHdr</span> <span class="o">*</span><span class="n">pFirst</span><span class="p">,</span> <span class="o">*</span><span class="n">pLast</span><span class="p">;</span>      <span class="cm">/* List of free pages */</span>
</span></span><span class="line"><span class="cl">  <span class="n">PgHdr</span> <span class="o">*</span><span class="n">pAll</span><span class="p">;</span>                <span class="cm">/* List of all pages */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 用于根据页号快速定位到页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">PgHdr</span> <span class="o">*</span><span class="n">aHash</span><span class="p">[</span><span class="n">N_PG_HASH</span><span class="p">];</span>    <span class="cm">/* Hash table to map page number of PgHdr */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Pager表示page cache实现，成员比较多，但都有注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">sqlitepager_open</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">Pager</span> <span class="o">**</span><span class="n">ppPager</span><span class="p">,</span>         <span class="cm">/* Return the Pager structure here */</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">zFilename</span><span class="p">,</span>   <span class="cm">/* Name of the database file to open */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">mxPage</span><span class="p">,</span>              <span class="cm">/* Max number of in-memory cache pages */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">nExtra</span>               <span class="cm">/* Extra bytes append to each in-memory page */</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>sqlitepager_open用于创建一个Pager，其实现稍长，但逻辑比较简单，首先打开数据库文件，然后做成员的初始化。这里不介绍其具体实现。参数中的mxPage控制内存中的最大页数，nExtra是上面的page部局中最后额外分配的一段内存。</p>
<p>pager_lookup用于在内存中根据页号来查询页，如果没有缓存，不会从磁盘中加载。主要逻辑就是在哈希表中查找。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">** Find a page in the hash table given its page number.  Return
</span></span></span><span class="line"><span class="cl"><span class="cm">** a pointer to the page or NULL if not found.
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="n">PgHdr</span> <span class="o">*</span><span class="nf">pager_lookup</span><span class="p">(</span><span class="n">Pager</span> <span class="o">*</span><span class="n">pPager</span><span class="p">,</span> <span class="n">Pgno</span> <span class="n">pgno</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">PgHdr</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">aHash</span><span class="p">[</span><span class="n">pgno</span> <span class="o">%</span> <span class="n">N_PG_HASH</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pgno</span><span class="o">!=</span><span class="n">pgno</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNextHash</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>pager_get和pager_lookup的不同在于，在没有命中缓存时会从磁盘中加载。在没有超过内存页数限制或者超过了但没有空闲页时，会malloc新的内存；否则从空闲页中重用page，如果所有的空闲页都是脏页，执行刷盘，这样所有的空闲页都不是脏页了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sqlitepager_get</span><span class="p">(</span><span class="n">Pager</span> <span class="o">*</span><span class="n">pPager</span><span class="p">,</span> <span class="n">Pgno</span> <span class="n">pgno</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">ppPage</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">PgHdr</span> <span class="o">*</span><span class="n">pPg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Make sure we have not hit any critical errors.
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span> 
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">==</span><span class="mi">0</span> <span class="o">||</span> <span class="n">pgno</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_ERROR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">errMask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PAGER_ERR_FULL</span><span class="p">)</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">pager_errcode</span><span class="p">(</span><span class="n">pPager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* If this is the first page accessed, then get a read lock
</span></span></span><span class="line"><span class="cl"><span class="cm">  ** on the database file.
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">nRef</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">sqliteOsReadLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">)</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="o">*</span><span class="n">ppPage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">SQLITE_BUSY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SQLITE_READLOCK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* If a journal file exists, try to play it back.
</span></span></span><span class="line"><span class="cl"><span class="cm">    */</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// nRef == 0，又存在journal文件，说明是崩溃后重启，需要从journal文件恢复
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span> <span class="n">sqliteOsFileExists</span><span class="p">(</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">zJournal</span><span class="p">)</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Search for page in cache */</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPg</span> <span class="o">=</span> <span class="n">pager_lookup</span><span class="p">(</span><span class="n">pPager</span><span class="p">,</span> <span class="n">pgno</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 没有命中缓存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span> <span class="n">pPg</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* The requested page is not in the page cache. */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">h</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">nMiss</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 没有超过内存上限，或者没有空闲页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">nPage</span><span class="o">&lt;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">mxPage</span> <span class="o">||</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">pFirst</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* Create a new page */</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 内存分配和我们上面的分析是一致的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">pPg</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pPg</span><span class="p">)</span> <span class="o">+</span> <span class="n">SQLITE_PAGE_SIZE</span> <span class="o">+</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">nExtra</span>  <span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">memset</span><span class="p">(</span><span class="n">pPg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pPg</span><span class="p">)</span> <span class="o">+</span> <span class="n">SQLITE_PAGE_SIZE</span> <span class="o">+</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">nExtra</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pPager</span> <span class="o">=</span> <span class="n">pPager</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pNextAll</span> <span class="o">=</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">pAll</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">pAll</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">pAll</span><span class="o">-&gt;</span><span class="n">pPrevAll</span> <span class="o">=</span> <span class="n">pPg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pPrevAll</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">pAll</span> <span class="o">=</span> <span class="n">pPg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">nPage</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* Recycle an older page.  First locate the page to be recycled.
</span></span></span><span class="line"><span class="cl"><span class="cm">      ** Try to find one that is not dirty and is near the head of
</span></span></span><span class="line"><span class="cl"><span class="cm">      ** of the free list */</span>
</span></span><span class="line"><span class="cl">      <span class="n">pPg</span> <span class="o">=</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">pFirst</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 当前没有任何引用的页为free页，但仍然可能为脏页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">while</span><span class="p">(</span> <span class="n">pPg</span> <span class="o">&amp;&amp;</span> <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">pPg</span> <span class="o">=</span> <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pNextFree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// 如果找不到可用的空闲页，则将所有的修改同步磁盘。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 之所以同步所有的页而非只同步一个页，是因为防止短期后续出现需要同步的情况。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span><span class="p">(</span> <span class="n">pPg</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">syncAllPages</span><span class="p">(</span><span class="n">pPager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">!=</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">          <span class="n">sqlitepager_rollback</span><span class="p">(</span><span class="n">pPager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="o">*</span><span class="n">ppPage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="n">SQLITE_IOERR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">pPg</span> <span class="o">=</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">pFirst</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="n">assert</span><span class="p">(</span> <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">nRef</span><span class="o">==</span><span class="mi">0</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">assert</span><span class="p">(</span> <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="o">==</span><span class="mi">0</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="cm">/* Unlink the old page from the free list and the hash table
</span></span></span><span class="line"><span class="cl"><span class="cm">      */</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 省略free链，hash链的维护逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">nOvfl</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pgno</span> <span class="o">=</span> <span class="n">pgno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置是否在journal或checkpoint中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">aInJournal</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">pgno</span><span class="o">&lt;=</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">origDbSize</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">inJournal</span> <span class="o">=</span> <span class="p">(</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">aInJournal</span><span class="p">[</span><span class="n">pgno</span><span class="o">/</span><span class="mi">8</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">pgno</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">)))</span><span class="o">!=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">inJournal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">aInCkpt</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">pgno</span><span class="o">&lt;=</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">ckptSize</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">inCkpt</span> <span class="o">=</span> <span class="p">(</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">aInCkpt</span><span class="p">[</span><span class="n">pgno</span><span class="o">/</span><span class="mi">8</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">pgno</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">)))</span><span class="o">!=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">inCkpt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">nRef</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">REFINFO</span><span class="p">(</span><span class="n">pPg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">nRef</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 维护hash链
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">h</span> <span class="o">=</span> <span class="n">pager_hash</span><span class="p">(</span><span class="n">pgno</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pNextHash</span> <span class="o">=</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">aHash</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">aHash</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">pPg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pNextHash</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">assert</span><span class="p">(</span> <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pNextHash</span><span class="o">-&gt;</span><span class="n">pPrevHash</span><span class="o">==</span><span class="mi">0</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pNextHash</span><span class="o">-&gt;</span><span class="n">pPrevHash</span> <span class="o">=</span> <span class="n">pPg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">dbSize</span><span class="o">&lt;</span><span class="mi">0</span> <span class="p">)</span> <span class="n">sqlitepager_pagecount</span><span class="p">(</span><span class="n">pPager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 对于磁盘上没有的页，置0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">dbSize</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">pgno</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">memset</span><span class="p">(</span><span class="n">PGHDR_TO_DATA</span><span class="p">(</span><span class="n">pPg</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SQLITE_PAGE_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">sqliteOsSeek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="n">pgno</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">SQLITE_PAGE_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 从磁盘读取
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">rc</span> <span class="o">=</span> <span class="n">sqliteOsRead</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">PGHDR_TO_DATA</span><span class="p">(</span><span class="n">pPg</span><span class="p">),</span> <span class="n">SQLITE_PAGE_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">nExtra</span><span class="o">&gt;</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">memset</span><span class="p">(</span><span class="n">PGHDR_TO_EXTRA</span><span class="p">(</span><span class="n">pPg</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">nExtra</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* The requested page is in the page cache. */</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">nHit</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">page_ref</span><span class="p">(</span><span class="n">pPg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">ppPage</span> <span class="o">=</span> <span class="n">PGHDR_TO_DATA</span><span class="p">(</span><span class="n">pPg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>sqlite对page实现了引用计数，引用计数变为0时加入空闲链，变为非0时从空闲链移除。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">page_ref</span><span class="p">(</span><span class="n">PgHdr</span> <span class="o">*</span><span class="n">pPg</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">nRef</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* The page is currently on the freelist.  Remove it. */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pPrevFree</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pPrevFree</span><span class="o">-&gt;</span><span class="n">pNextFree</span> <span class="o">=</span> <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pNextFree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">pFirst</span> <span class="o">=</span> <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pNextFree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pNextFree</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pNextFree</span><span class="o">-&gt;</span><span class="n">pPrevFree</span> <span class="o">=</span> <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pPrevFree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">pLast</span> <span class="o">=</span> <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pPrevFree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">nRef</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">nRef</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">REFINFO</span><span class="p">(</span><span class="n">pPg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="事务及crash-recovery实现">事务及crash recovery实现</h3>
<p>sqlite 3.7.0实现了wal journal，之前采用的是rollback journaling。所谓rollback journaling，是指在修改page前，先将page的内容备份到journal文件中，然后再修改内存中的page，在事务提交时成功刷新到磁盘后再移除journal文件。如果事务在成功提交之前出现crash，在重启时sqlite会从journal文件恢复page，使数据库恢复事务提交前的状态。</p>
<p>在事务开始时，需要调用<code>sqlitepager_begin</code> ，会创建journal文件和维护journal相关的标记位，记录当前文件的页数用于回滚。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sqlitepager_begin</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pData</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">PgHdr</span> <span class="o">*</span><span class="n">pPg</span> <span class="o">=</span> <span class="n">DATA_TO_PGHDR</span><span class="p">(</span><span class="n">pData</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">Pager</span> <span class="o">*</span><span class="n">pPager</span> <span class="o">=</span> <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">==</span><span class="n">SQLITE_READLOCK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">aInJournal</span><span class="o">==</span><span class="mi">0</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 写锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">sqliteOsWriteLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 用于记录哪些页已经写入journal文件了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">aInJournal</span>  <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span>  <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">dbSize</span><span class="o">/</span><span class="mi">8</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">memset</span><span class="p">(</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">aInJournal</span> <span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">dbSize</span><span class="o">/</span><span class="mi">8</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 打开journal文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">sqliteOsOpenExclusive</span><span class="p">(</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">zJournal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">jfd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">journalOpen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">needSync</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">dirtyFile</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SQLITE_WRITELOCK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sqlitepager_pagecount</span><span class="p">(</span><span class="n">pPager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 记录之前的page个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">origDbSize</span> <span class="o">=</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">dbSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 写入magic和之前的page页数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">sqliteOsWrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">jfd</span><span class="p">,</span> <span class="n">aJournalMagic</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">aJournalMagic</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">==</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">rc</span> <span class="o">=</span> <span class="n">sqliteOsWrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">jfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">dbSize</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Pgno</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">rc</span> <span class="o">=</span> <span class="n">pager_unwritelock</span><span class="p">(</span><span class="n">pPager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">==</span><span class="n">SQLITE_OK</span> <span class="p">)</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">SQLITE_FULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在修改page前，需要调用<code>sqlitepager_write</code> ，将page内容备份到journal文件中，并设置dirty标记。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sqlitepager_write</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pData</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">PgHdr</span> <span class="o">*</span><span class="n">pPg</span> <span class="o">=</span> <span class="n">DATA_TO_PGHDR</span><span class="p">(</span><span class="n">pData</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">Pager</span> <span class="o">*</span><span class="n">pPager</span> <span class="o">=</span> <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Check for errors
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">errMask</span> <span class="p">){</span> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">pager_errcode</span><span class="p">(</span><span class="n">pPager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">readOnly</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_PERM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Mark the page as dirty.  If the page has already been written
</span></span></span><span class="line"><span class="cl"><span class="cm">  ** to the journal then we can return right away.
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">inJournal</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pPg</span><span class="o">-&gt;</span><span class="n">inCkpt</span> <span class="o">||</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">ckptInUse</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">dirtyFile</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* If we get this far, it means that the page needs to be
</span></span></span><span class="line"><span class="cl"><span class="cm">  ** written to the transaction journal or the ckeckpoint journal
</span></span></span><span class="line"><span class="cl"><span class="cm">  ** or both.
</span></span></span><span class="line"><span class="cl"><span class="cm">  **
</span></span></span><span class="line"><span class="cl"><span class="cm">  ** First check to see that the transaction journal exists and
</span></span></span><span class="line"><span class="cl"><span class="cm">  ** create it if it does not.
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">!=</span><span class="n">SQLITE_UNLOCK</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 调用sqlitepager_begin，如果之前已经调用过，相当于空操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_begin</span><span class="p">(</span><span class="n">pData</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">dirtyFile</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">==</span><span class="n">SQLITE_WRITELOCK</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">journalOpen</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* The transaction journal now exists and we have a write lock on the
</span></span></span><span class="line"><span class="cl"><span class="cm">  ** main database file.  Write the current page to the transaction 
</span></span></span><span class="line"><span class="cl"><span class="cm">  ** journal if it is not there already.
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果没有备份到journal且在文件原有范围内
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">pPg</span><span class="o">-&gt;</span><span class="n">inJournal</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pgno</span> <span class="o">&lt;=</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">origDbSize</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 写入页号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">sqliteOsWrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">jfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pgno</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Pgno</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">==</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 写入page内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">rc</span> <span class="o">=</span> <span class="n">sqliteOsWrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">jfd</span><span class="p">,</span> <span class="n">pData</span><span class="p">,</span> <span class="n">SQLITE_PAGE_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">aInJournal</span><span class="o">!=</span><span class="mi">0</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置标志位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">aInJournal</span><span class="p">[</span><span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pgno</span><span class="o">/</span><span class="mi">8</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pgno</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">needSync</span> <span class="o">=</span> <span class="o">!</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">noSync</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">inJournal</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Update the database size and return.
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">dbSize</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pgno</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">dbSize</span> <span class="o">=</span> <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pgno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在事务回滚时，调用<code>sqlitepager_rollback</code> ，从journal文件恢复备份的page内容。对于journal文件中所有完整的页，将其读出后写入数据库文件的相应页，并更新到存在的page缓存。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sqlitepager_rollback</span><span class="p">(</span><span class="n">Pager</span> <span class="o">*</span><span class="n">pPager</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">errMask</span><span class="o">!=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">errMask</span><span class="o">!=</span><span class="n">PAGER_ERR_FULL</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">&gt;=</span><span class="n">SQLITE_WRITELOCK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">pager_playback</span><span class="p">(</span><span class="n">pPager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">pager_errcode</span><span class="p">(</span><span class="n">pPager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">!=</span><span class="n">SQLITE_WRITELOCK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 回放
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">rc</span> <span class="o">=</span> <span class="n">pager_playback</span><span class="p">(</span><span class="n">pPager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">SQLITE_CORRUPT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">errMask</span> <span class="o">|=</span> <span class="n">PAGER_ERR_CORRUPT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 设置页数为-1，后面有需要会自动获取实际的页数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">dbSize</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">pager_playback</span><span class="p">(</span><span class="n">Pager</span> <span class="o">*</span><span class="n">pPager</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">nRec</span><span class="p">;</span>                <span class="cm">/* Number of Records */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>                   <span class="cm">/* Loop counter */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Pgno</span> <span class="n">mxPg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>           <span class="cm">/* Size of the original file in pages */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">aMagic</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">aJournalMagic</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Figure out how many records are in the journal.  Abort early if
</span></span></span><span class="line"><span class="cl"><span class="cm">  ** the journal is empty.
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">journalOpen</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">sqliteOsSeek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">jfd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">rc</span> <span class="o">=</span> <span class="n">sqliteOsFileSize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">jfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nRec</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">end_playback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 校验至少需要存储一个完整的page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">nRec</span> <span class="o">=</span> <span class="p">(</span><span class="n">nRec</span> <span class="o">-</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">aMagic</span><span class="p">)</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Pgno</span><span class="p">)))</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PageRecord</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">nRec</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">end_playback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Read the beginning of the journal and truncate the
</span></span></span><span class="line"><span class="cl"><span class="cm">  ** database file back to its original size.
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 校验magic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">rc</span> <span class="o">=</span> <span class="n">sqliteOsRead</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">jfd</span><span class="p">,</span> <span class="n">aMagic</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">aMagic</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="o">||</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">aMagic</span><span class="p">,</span><span class="n">aJournalMagic</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">aMagic</span><span class="p">))</span><span class="o">!=</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">SQLITE_PROTOCOL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">end_playback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 读取最大页数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">rc</span> <span class="o">=</span> <span class="n">sqliteOsRead</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">jfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mxPg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mxPg</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">end_playback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 丢弃最后不完整的页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">rc</span> <span class="o">=</span> <span class="n">sqliteOsTruncate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">mxPg</span><span class="o">*</span><span class="n">SQLITE_PAGE_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">end_playback</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 恢复页数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">dbSize</span> <span class="o">=</span> <span class="n">mxPg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="cm">/* Copy original pages out of the journal and back into the database file.
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">nRec</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">pager_playback_one_page</span><span class="p">(</span><span class="n">pPager</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">jfd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">end_playback</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">pager_unwritelock</span><span class="p">(</span><span class="n">pPager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">errMask</span> <span class="o">|=</span> <span class="n">PAGER_ERR_CORRUPT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">SQLITE_CORRUPT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">pager_unwritelock</span><span class="p">(</span><span class="n">pPager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">pager_playback_one_page</span><span class="p">(</span><span class="n">Pager</span> <span class="o">*</span><span class="n">pPager</span><span class="p">,</span> <span class="n">OsFile</span> <span class="o">*</span><span class="n">jfd</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">PgHdr</span> <span class="o">*</span><span class="n">pPg</span><span class="p">;</span>              <span class="cm">/* An existing page in the cache */</span>
</span></span><span class="line"><span class="cl">  <span class="n">PageRecord</span> <span class="n">pgRec</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 读页号和page内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">rc</span> <span class="o">=</span> <span class="n">sqliteOsRead</span><span class="p">(</span><span class="n">jfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pgRec</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pgRec</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Sanity checking on the page */</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pgRec</span><span class="p">.</span><span class="n">pgno</span><span class="o">&gt;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">dbSize</span> <span class="o">||</span> <span class="n">pgRec</span><span class="p">.</span><span class="n">pgno</span><span class="o">==</span><span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">SQLITE_CORRUPT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Playback the page.  Update the in-memory copy of the page
</span></span></span><span class="line"><span class="cl"><span class="cm">  ** at the same time, if there is one.
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果有缓存的话，也更新到缓存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">pPg</span> <span class="o">=</span> <span class="n">pager_lookup</span><span class="p">(</span><span class="n">pPager</span><span class="p">,</span> <span class="n">pgRec</span><span class="p">.</span><span class="n">pgno</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPg</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">memcpy</span><span class="p">(</span><span class="n">PGHDR_TO_DATA</span><span class="p">(</span><span class="n">pPg</span><span class="p">),</span> <span class="n">pgRec</span><span class="p">.</span><span class="n">aData</span><span class="p">,</span> <span class="n">SQLITE_PAGE_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">memset</span><span class="p">(</span><span class="n">PGHDR_TO_EXTRA</span><span class="p">(</span><span class="n">pPg</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">nExtra</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 写入文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">rc</span> <span class="o">=</span> <span class="n">sqliteOsSeek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="n">pgRec</span><span class="p">.</span><span class="n">pgno</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">SQLITE_PAGE_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">==</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">sqliteOsWrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">pgRec</span><span class="p">.</span><span class="n">aData</span><span class="p">,</span> <span class="n">SQLITE_PAGE_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>事务提交时需要调用<code>sqlitepager_commit</code> ，刷盘并释放写锁。看实现会先同步journal文件，然后将内存中的page写入磁盘并同步数据库文件。在释放写锁时会删除journal文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sqlitepager_commit</span><span class="p">(</span><span class="n">Pager</span> <span class="o">*</span><span class="n">pPager</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">PgHdr</span> <span class="o">*</span><span class="n">pPg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">errMask</span><span class="o">==</span><span class="n">PAGER_ERR_FULL</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_rollback</span><span class="p">(</span><span class="n">pPager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">==</span><span class="n">SQLITE_OK</span> <span class="p">)</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">SQLITE_FULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">errMask</span><span class="o">!=</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">pager_errcode</span><span class="p">(</span><span class="n">pPager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">!=</span><span class="n">SQLITE_WRITELOCK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_ERROR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">journalOpen</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">dirtyFile</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 没有修改直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="cm">/* Exit early (without doing the time-consuming sqliteOsSync() calls)
</span></span></span><span class="line"><span class="cl"><span class="cm">    ** if there have been no changes to the database file. */</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">pager_unwritelock</span><span class="p">(</span><span class="n">pPager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">dbSize</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 同步journal文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">needSync</span> <span class="o">&amp;&amp;</span> <span class="n">sqliteOsSync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">jfd</span><span class="p">)</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">commit_abort</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 写所有的脏页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span><span class="p">(</span><span class="n">pPg</span><span class="o">=</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">pAll</span><span class="p">;</span> <span class="n">pPg</span><span class="p">;</span> <span class="n">pPg</span><span class="o">=</span><span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pNextAll</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="o">==</span><span class="mi">0</span> <span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">sqliteOsSeek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pgno</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">SQLITE_PAGE_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">commit_abort</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">sqliteOsWrite</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">PGHDR_TO_DATA</span><span class="p">(</span><span class="n">pPg</span><span class="p">),</span> <span class="n">SQLITE_PAGE_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">commit_abort</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 同步数据库文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">noSync</span> <span class="o">&amp;&amp;</span> <span class="n">sqliteOsSync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pPager</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">)</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">commit_abort</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 释放写锁时会删除journal文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">rc</span> <span class="o">=</span> <span class="n">pager_unwritelock</span><span class="p">(</span><span class="n">pPager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">dbSize</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/* Jump here if anything goes wrong during the commit process.
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl"><span class="nl">commit_abort</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_rollback</span><span class="p">(</span><span class="n">pPager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">==</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">SQLITE_FULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>某些情况下脏页有可能整页被丢弃，比如在B树删除时可能page被合并到相邻的页，这时可以调用<code>sqlitepager_dont_write</code> 来减少事务提交时的写盘量，通过去掉脏页标记使得事务提交时不需要刷新这个页到磁盘。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">sqlitepager_dont_write</span><span class="p">(</span><span class="n">Pager</span> <span class="o">*</span><span class="n">pPager</span><span class="p">,</span> <span class="n">Pgno</span> <span class="n">pgno</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">PgHdr</span> <span class="o">*</span><span class="n">pPg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pPg</span> <span class="o">=</span> <span class="n">pager_lookup</span><span class="p">(</span><span class="n">pPager</span><span class="p">,</span> <span class="n">pgno</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPg</span> <span class="o">&amp;&amp;</span> <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>某些情况下，在写数据页时可能之前的数据不需要备份到journal文件中，比如重用之前释放的磁盘页时，这时可以调用<code>sqlitepager_dont_rollback</code> ，其主要逻辑为设置在journal文件中的标志位。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">sqlitepager_dont_rollback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pData</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">PgHdr</span> <span class="o">*</span><span class="n">pPg</span> <span class="o">=</span> <span class="n">DATA_TO_PGHDR</span><span class="p">(</span><span class="n">pData</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">Pager</span> <span class="o">*</span><span class="n">pPager</span> <span class="o">=</span> <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">!=</span><span class="n">SQLITE_WRITELOCK</span> <span class="o">||</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">journalOpen</span><span class="o">==</span><span class="mi">0</span> <span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">pPg</span><span class="o">-&gt;</span><span class="n">inJournal</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pgno</span> <span class="o">&lt;=</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">origDbSize</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">aInJournal</span><span class="o">!=</span><span class="mi">0</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">aInJournal</span><span class="p">[</span><span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pgno</span><span class="o">/</span><span class="mi">8</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pgno</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 只设置标志位，但不写入journal文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">inJournal</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">ckptInUse</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">pPager</span><span class="o">-&gt;</span><span class="n">aInCkpt</span><span class="p">[</span><span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pgno</span><span class="o">/</span><span class="mi">8</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">pPg</span><span class="o">-&gt;</span><span class="n">pgno</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">pPg</span><span class="o">-&gt;</span><span class="n">inCkpt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="b树实现">B树实现</h2>
<p>这个版本的sqlite的表和索引都使用了B树实现，还没有实现B+树。</p>
<p>一个打开的数据库用下面的结构体表示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Btree</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Pager</span> <span class="o">*</span><span class="n">pPager</span><span class="p">;</span>        <span class="cm">/* The page cache */</span>
</span></span><span class="line"><span class="cl">  <span class="n">BtCursor</span> <span class="o">*</span><span class="n">pCursor</span><span class="p">;</span>    <span class="cm">/* A list of all open cursors */</span>
</span></span><span class="line"><span class="cl">  <span class="n">PageOne</span> <span class="o">*</span><span class="n">page1</span><span class="p">;</span>       <span class="cm">/* First page of the database */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u8</span> <span class="n">inTrans</span><span class="p">;</span>           <span class="cm">/* True if a transaction is in progress */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u8</span> <span class="n">inCkpt</span><span class="p">;</span>            <span class="cm">/* True if there is a checkpoint on the transaction */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u8</span> <span class="n">readOnly</span><span class="p">;</span>          <span class="cm">/* True if the underlying file is readonly */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Hash</span> <span class="n">locks</span><span class="p">;</span>           <span class="cm">/* Key: root page number.  Data: lock count */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>数据库文件的第1个page，用<code>PageOne</code> 来表示，其中包含标识数据库文件的magic number，以及空闲页的信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">PageOne</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ** This file contains an SQLite 2.1 database **
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">char</span> <span class="n">zMagic</span><span class="p">[</span><span class="n">MAGIC_SIZE</span><span class="p">];</span> <span class="cm">/* String that identifies the file as a database */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 0xdae37528
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">iMagic</span><span class="p">;</span>              <span class="cm">/* Integer to verify correct byte order */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Pgno</span> <span class="n">freeList</span><span class="p">;</span>           <span class="cm">/* First free page in a list of all free pages */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">nFree</span><span class="p">;</span>               <span class="cm">/* Number of pages on the free list */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">aMeta</span><span class="p">[</span><span class="n">SQLITE_N_BTREE_META</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>  <span class="cm">/* User defined integers */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一个数据库文件中可以包含多个B树，这些B树存储在第2个或者页号更大的page中。</p>
<h3 id="空闲页表">空闲页表</h3>
<p>PageOne.freeList指向第一个存储空闲页信息的页。空闲页信息使用<code>FreelistInfo</code> 存储</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">FreelistInfo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">nFree</span><span class="p">;</span>  <span class="c1">// 空闲页的个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Pgno</span> <span class="n">aFree</span><span class="p">[(</span><span class="n">OVERFLOW_SIZE</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Pgno</span><span class="p">)];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>存储空闲页信息的页使用overflow页的格式存储，使用OverflowPage.iNext指向下一个存储空闲页信息的页，这些空闲页信息构成了一个链表。FreelistInfo存储在OverflowPage.aPayload处。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define OVERFLOW_SIZE (SQLITE_PAGE_SIZE-sizeof(Pgno))
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">OverflowPage</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Pgno</span> <span class="n">iNext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">aPayload</span><span class="p">[</span><span class="n">OVERFLOW_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>添加一个页到空闲页表的实现如下。如果存在不满的存储空闲页信息的页，则追加到其中，否则创建一个新的存储空闲页信息的页。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">** Add a page of the database file to the freelist.  Either pgno or
</span></span></span><span class="line"><span class="cl"><span class="cm">** pPage but not both may be 0. 
</span></span></span><span class="line"><span class="cl"><span class="cm">**
</span></span></span><span class="line"><span class="cl"><span class="cm">** sqlitepager_unref() is NOT called for pPage.
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">freePage</span><span class="p">(</span><span class="n">Btree</span> <span class="o">*</span><span class="n">pBt</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pPage</span><span class="p">,</span> <span class="n">Pgno</span> <span class="n">pgno</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">PageOne</span> <span class="o">*</span><span class="n">pPage1</span> <span class="o">=</span> <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">page1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">OverflowPage</span> <span class="o">*</span><span class="n">pOvfl</span> <span class="o">=</span> <span class="p">(</span><span class="n">OverflowPage</span><span class="o">*</span><span class="p">)</span><span class="n">pPage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">needUnref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">MemPage</span> <span class="o">*</span><span class="n">pMemPage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pgno</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span> <span class="n">pOvfl</span><span class="o">!=</span><span class="mi">0</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pgno</span> <span class="o">=</span> <span class="n">sqlitepager_pagenumber</span><span class="p">(</span><span class="n">pOvfl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">pgno</span><span class="o">&gt;</span><span class="mi">2</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_write</span><span class="p">(</span><span class="n">pPage1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 计数加1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">pPage1</span><span class="o">-&gt;</span><span class="n">nFree</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPage1</span><span class="o">-&gt;</span><span class="n">nFree</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pPage1</span><span class="o">-&gt;</span><span class="n">freeList</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">OverflowPage</span> <span class="o">*</span><span class="n">pFreeIdx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_get</span><span class="p">(</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">,</span> <span class="n">pPage1</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pFreeIdx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">==</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">FreelistInfo</span> <span class="o">*</span><span class="n">pInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">FreelistInfo</span><span class="o">*</span><span class="p">)</span><span class="n">pFreeIdx</span><span class="o">-&gt;</span><span class="n">aPayload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 如果有空闲空间，则写入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span><span class="p">(</span> <span class="n">pInfo</span><span class="o">-&gt;</span><span class="n">nFree</span><span class="o">&lt;</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pInfo</span><span class="o">-&gt;</span><span class="n">aFree</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pInfo</span><span class="o">-&gt;</span><span class="n">aFree</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_write</span><span class="p">(</span><span class="n">pFreeIdx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">==</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">          <span class="n">pInfo</span><span class="o">-&gt;</span><span class="n">aFree</span><span class="p">[</span><span class="n">pInfo</span><span class="o">-&gt;</span><span class="n">nFree</span><span class="p">]</span> <span class="o">=</span> <span class="n">pgno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="n">pInfo</span><span class="o">-&gt;</span><span class="n">nFree</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pFreeIdx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 取消pgno页的脏页标记
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">sqlitepager_dont_write</span><span class="p">(</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">,</span> <span class="n">pgno</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pFreeIdx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 运行到这里意味着所有的存储空闲页信息的页都已写满，需要用当前页来存储空闲页信息。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span> <span class="n">pOvfl</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span> <span class="n">pgno</span><span class="o">&gt;</span><span class="mi">0</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_get</span><span class="p">(</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">,</span> <span class="n">pgno</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pOvfl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">needUnref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_write</span><span class="p">(</span><span class="n">pOvfl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">needUnref</span> <span class="p">)</span> <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pOvfl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 维护链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">pOvfl</span><span class="o">-&gt;</span><span class="n">iNext</span> <span class="o">=</span> <span class="n">pPage1</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pPage1</span><span class="o">-&gt;</span><span class="n">freeList</span> <span class="o">=</span> <span class="n">pgno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// memset也保证了FreelistInfo.nFree == 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">memset</span><span class="p">(</span><span class="n">pOvfl</span><span class="o">-&gt;</span><span class="n">aPayload</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">OVERFLOW_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">pMemPage</span> <span class="o">=</span> <span class="p">(</span><span class="n">MemPage</span><span class="o">*</span><span class="p">)</span><span class="n">pPage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pMemPage</span><span class="o">-&gt;</span><span class="n">isInit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pMemPage</span><span class="o">-&gt;</span><span class="n">pParent</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pMemPage</span><span class="o">-&gt;</span><span class="n">pParent</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pMemPage</span><span class="o">-&gt;</span><span class="n">pParent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">needUnref</span> <span class="p">)</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pOvfl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从空闲页表分配一个页的实现如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">allocatePage</span><span class="p">(</span><span class="n">Btree</span> <span class="o">*</span><span class="n">pBt</span><span class="p">,</span> <span class="n">MemPage</span> <span class="o">**</span><span class="n">ppPage</span><span class="p">,</span> <span class="n">Pgno</span> <span class="o">*</span><span class="n">pPgno</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">PageOne</span> <span class="o">*</span><span class="n">pPage1</span> <span class="o">=</span> <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">page1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果有空闲页，从空闲页分配；否则从磁盘加载，分配一个新页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span> <span class="n">pPage1</span><span class="o">-&gt;</span><span class="n">freeList</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">OverflowPage</span> <span class="o">*</span><span class="n">pOvfl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">FreelistInfo</span> <span class="o">*</span><span class="n">pInfo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_write</span><span class="p">(</span><span class="n">pPage1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPage1</span><span class="o">-&gt;</span><span class="n">nFree</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_get</span><span class="p">(</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">,</span> <span class="n">pPage1</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pOvfl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_write</span><span class="p">(</span><span class="n">pOvfl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pOvfl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">pInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">FreelistInfo</span><span class="o">*</span><span class="p">)</span><span class="n">pOvfl</span><span class="o">-&gt;</span><span class="n">aPayload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">pInfo</span><span class="o">-&gt;</span><span class="n">nFree</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 这个空闲页信息页只的空闲页为0，把这个页本身分配出去。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="o">*</span><span class="n">pPgno</span> <span class="o">=</span> <span class="n">pPage1</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">pPage1</span><span class="o">-&gt;</span><span class="n">freeList</span> <span class="o">=</span> <span class="n">pOvfl</span><span class="o">-&gt;</span><span class="n">iNext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="o">*</span><span class="n">ppPage</span> <span class="o">=</span> <span class="p">(</span><span class="n">MemPage</span><span class="o">*</span><span class="p">)</span><span class="n">pOvfl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 从中拿一个页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">pInfo</span><span class="o">-&gt;</span><span class="n">nFree</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="o">*</span><span class="n">pPgno</span> <span class="o">=</span> <span class="n">pInfo</span><span class="o">-&gt;</span><span class="n">aFree</span><span class="p">[</span><span class="n">pInfo</span><span class="o">-&gt;</span><span class="n">nFree</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_get</span><span class="p">(</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">,</span> <span class="o">*</span><span class="n">pPgno</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="n">ppPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pOvfl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">==</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// 设置空闲页的内容不需要回滚
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">sqlitepager_dont_rollback</span><span class="p">(</span><span class="o">*</span><span class="n">ppPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_write</span><span class="p">(</span><span class="o">*</span><span class="n">ppPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">pPgno</span> <span class="o">=</span> <span class="n">sqlitepager_pagecount</span><span class="p">(</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 从Pager分配一个新页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_get</span><span class="p">(</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">,</span> <span class="o">*</span><span class="n">pPgno</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="n">ppPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_write</span><span class="p">(</span><span class="o">*</span><span class="n">ppPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="b树节点页实现">B树节点页实现</h3>
<p>节点使用下面的结构体来表示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">MemPage</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">aDisk</span><span class="p">[</span><span class="n">SQLITE_PAGE_SIZE</span><span class="p">];</span>  <span class="cm">/* Page data stored on disk */</span>
</span></span><span class="line"><span class="cl">    <span class="n">PageHdr</span> <span class="n">hdr</span><span class="p">;</span>                   <span class="cm">/* Overlay page header */</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="n">u</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">isInit</span><span class="p">;</span>                    <span class="cm">/* True if auxiliary data is initialized */</span>
</span></span><span class="line"><span class="cl">  <span class="n">MemPage</span> <span class="o">*</span><span class="n">pParent</span><span class="p">;</span>              <span class="cm">/* The parent of this page.  NULL for root */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 空闲字节数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">nFree</span><span class="p">;</span>                     <span class="cm">/* Number of free bytes in u.aDisk[] */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 存储的cell个数。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">nCell</span><span class="p">;</span>                     <span class="cm">/* Number of entries on this page */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 是否已经overfull，即超出page size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">isOverfull</span><span class="p">;</span>                <span class="cm">/* Some apCell[] points outside u.aDisk[] */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 排序的Cell列表。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Cell</span> <span class="o">*</span><span class="n">apCell</span><span class="p">[</span><span class="n">MX_CELL</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span>       <span class="cm">/* All data entires in sorted order */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#define EXTRA_SIZE (sizeof(MemPage)-SQLITE_PAGE_SIZE)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>MemPage.u对应磁盘上的page，之后的数据只在内存中存储。在创建Pager时，会设置Pager.nExtra = EXTRA_SIZE以便在创建内存中的页时分配足够的内存。</p>
<p>每个节点的KV和左子指针，使用Cell结构来表示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">CellHdr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Pgno</span> <span class="n">leftChild</span><span class="p">;</span> <span class="cm">/* Child page that comes before this cell */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u16</span> <span class="n">nKey</span><span class="p">;</span>       <span class="cm">/* Number of bytes in the key */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u16</span> <span class="n">iNext</span><span class="p">;</span>      <span class="cm">/* Index in MemPage.u.aDisk[] of next cell in sorted order */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u8</span> <span class="n">nKeyHi</span><span class="p">;</span>      <span class="cm">/* Upper 8 bits of key size for keys larger than 64K bytes */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u8</span> <span class="n">nDataHi</span><span class="p">;</span>     <span class="cm">/* Upper 8 bits of data size when the size is more than 64K */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u16</span> <span class="n">nData</span><span class="p">;</span>      <span class="cm">/* Number of bytes of data */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#define NKEY(h)  (h.nKey + h.nKeyHi*65536)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define NDATA(h) (h.nData + h.nDataHi*65536)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Cell的最小大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define MIN_CELL_SIZE  (sizeof(CellHdr)+4)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// 一个页中最多可以存多少个Cell
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define MX_CELL ((SQLITE_PAGE_SIZE-sizeof(PageHdr))/MIN_CELL_SIZE)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define USABLE_SPACE  (SQLITE_PAGE_SIZE - sizeof(PageHdr))
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// 不使用overflow页时Cell的最大字节数，保证一个page至少可以存4个Cell
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define MX_LOCAL_PAYLOAD ((USABLE_SPACE/4-(sizeof(CellHdr)+sizeof(Pgno)))&amp;~3)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Cell</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">CellHdr</span> <span class="n">h</span><span class="p">;</span>                        <span class="cm">/* The cell header */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">aPayload</span><span class="p">[</span><span class="n">MX_LOCAL_PAYLOAD</span><span class="p">];</span>  <span class="cm">/* Key and data */</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 第一个overflow页的页号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Pgno</span> <span class="n">ovfl</span><span class="p">;</span>                        <span class="cm">/* The first overflow page */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Cell由CellHdr和payload数据以及第一个overflow页的页号构成。虽然Cell的结构体的长度是固定的，但实际Cell是变长的，通过CellHdr来确定Cell的实际长度。payload至少4个字节，最多MX_LOCAL_PAYLOAD个字节，如果payload需要的空间大于MX_LOCAL_PAYLOAD时会分配overflow页。</p>
<p>CellHdr描述了key和value的长度，都使用了24个bit表示，为了节省空间拆分为高位8bit的nKeyHi和16 bit的nKey（如果不这么拆分的话要占用32个bit），定义了NKEY和NDATA宏来得到K和V的长度。CellHdr.leftChild指向了左子树的页号，其中存储的key都小于这个Cell的key。</p>
<p>分配一个Cell的实现如下，如果空间不足，会分配overflow页来存储。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">fillInCell</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">Btree</span> <span class="o">*</span><span class="n">pBt</span><span class="p">,</span>              <span class="cm">/* The whole Btree.  Needed to allocate pages */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Cell</span> <span class="o">*</span><span class="n">pCell</span><span class="p">,</span>             <span class="cm">/* Populate this Cell structure */</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pKey</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nKey</span><span class="p">,</span>    <span class="cm">/* The key */</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pData</span><span class="p">,</span><span class="kt">int</span> <span class="n">nData</span>    <span class="cm">/* The data */</span>
</span></span><span class="line"><span class="cl"><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">OverflowPage</span> <span class="o">*</span><span class="n">pOvfl</span><span class="p">,</span> <span class="o">*</span><span class="n">pPrior</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Pgno</span> <span class="o">*</span><span class="n">pNext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">spaceLeft</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">nPayload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pPayload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="o">*</span><span class="n">pSpace</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">pCell</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 设置size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">pCell</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">nKey</span> <span class="o">=</span> <span class="n">nKey</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pCell</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">nKeyHi</span> <span class="o">=</span> <span class="n">nKey</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pCell</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">nData</span> <span class="o">=</span> <span class="n">nData</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pCell</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">nDataHi</span> <span class="o">=</span> <span class="n">nData</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pCell</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">iNext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">pNext</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pCell</span><span class="o">-&gt;</span><span class="n">ovfl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pSpace</span> <span class="o">=</span> <span class="n">pCell</span><span class="o">-&gt;</span><span class="n">aPayload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">spaceLeft</span> <span class="o">=</span> <span class="n">MX_LOCAL_PAYLOAD</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pPayload</span> <span class="o">=</span> <span class="n">pKey</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pKey</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">nPayload</span> <span class="o">=</span> <span class="n">nKey</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pPrior</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span> <span class="n">nPayload</span><span class="o">&gt;</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">spaceLeft</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 分配一个overflow页，页号设置到pCell-&gt;ovfl或者pOvfl-&gt;iNext中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">rc</span> <span class="o">=</span> <span class="n">allocatePage</span><span class="p">(</span><span class="n">pBt</span><span class="p">,</span> <span class="p">(</span><span class="n">MemPage</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pOvfl</span><span class="p">,</span> <span class="n">pNext</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="n">pNext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span> <span class="n">pPrior</span> <span class="p">)</span> <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pPrior</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">clearCell</span><span class="p">(</span><span class="n">pBt</span><span class="p">,</span> <span class="n">pCell</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="n">pPrior</span> <span class="o">=</span> <span class="n">pOvfl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">spaceLeft</span> <span class="o">=</span> <span class="n">OVERFLOW_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">pSpace</span> <span class="o">=</span> <span class="n">pOvfl</span><span class="o">-&gt;</span><span class="n">aPayload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">pNext</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pOvfl</span><span class="o">-&gt;</span><span class="n">iNext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">n</span> <span class="o">=</span> <span class="n">nPayload</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">n</span><span class="o">&gt;</span><span class="n">spaceLeft</span> <span class="p">)</span> <span class="n">n</span> <span class="o">=</span> <span class="n">spaceLeft</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 挎包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">memcpy</span><span class="p">(</span><span class="n">pSpace</span><span class="p">,</span> <span class="n">pPayload</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">nPayload</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">nPayload</span><span class="o">==</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pData</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// key写完后接着写value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">pPayload</span> <span class="o">=</span> <span class="n">pData</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">nPayload</span> <span class="o">=</span> <span class="n">nData</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">pData</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">pPayload</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">spaceLeft</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pSpace</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">pNext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPrior</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pPrior</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>释放Cell涉及到两个函数。<code>clearCell</code> 负责释放Cell分配的overflow页。<code>dropCell</code> 负责将Cell非溢出的内存加入空闲链表中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">clearCell</span><span class="p">(</span><span class="n">Btree</span> <span class="o">*</span><span class="n">pBt</span><span class="p">,</span> <span class="n">Cell</span> <span class="o">*</span><span class="n">pCell</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">Pager</span> <span class="o">*</span><span class="n">pPager</span> <span class="o">=</span> <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">OverflowPage</span> <span class="o">*</span><span class="n">pOvfl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Pgno</span> <span class="n">ovfl</span><span class="p">,</span> <span class="n">nextOvfl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">NKEY</span><span class="p">(</span><span class="n">pCell</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">)</span> <span class="o">+</span> <span class="n">NDATA</span><span class="p">(</span><span class="n">pCell</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">MX_LOCAL_PAYLOAD</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">ovfl</span> <span class="o">=</span> <span class="n">pCell</span><span class="o">-&gt;</span><span class="n">ovfl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pCell</span><span class="o">-&gt;</span><span class="n">ovfl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span> <span class="n">ovfl</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 释放overflow页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_get</span><span class="p">(</span><span class="n">pPager</span><span class="p">,</span> <span class="n">ovfl</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pOvfl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">nextOvfl</span> <span class="o">=</span> <span class="n">pOvfl</span><span class="o">-&gt;</span><span class="n">iNext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">freePage</span><span class="p">(</span><span class="n">pBt</span><span class="p">,</span> <span class="n">pOvfl</span><span class="p">,</span> <span class="n">ovfl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pOvfl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">ovfl</span> <span class="o">=</span> <span class="n">nextOvfl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">dropCell</span><span class="p">(</span><span class="n">MemPage</span> <span class="o">*</span><span class="n">pPage</span><span class="p">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">idx</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span><span class="o">&lt;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">sz</span><span class="o">==</span><span class="n">cellSize</span><span class="p">(</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">sqlitepager_iswriteable</span><span class="p">(</span><span class="n">pPage</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 释放Cell本身占的空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">freeSpace</span><span class="p">(</span><span class="n">pPage</span><span class="p">,</span> <span class="n">Addr</span><span class="p">(</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">-</span> <span class="n">Addr</span><span class="p">(</span><span class="n">pPage</span><span class="p">),</span> <span class="n">sz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">idx</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">/</span>
</span></span><span class="line"><span class="cl"><span class="o">**</span> <span class="n">Most</span> <span class="n">of</span> <span class="n">the</span> <span class="n">effort</span> <span class="n">here</span> <span class="n">is</span> <span class="n">involved</span> <span class="n">in</span> <span class="n">coalesing</span> <span class="n">adjacent</span>
</span></span><span class="line"><span class="cl"><span class="o">**</span> <span class="n">free</span> <span class="n">blocks</span> <span class="n">into</span> <span class="n">a</span> <span class="n">single</span> <span class="n">big</span> <span class="n">free</span> <span class="n">block</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="err">*/</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="n">freeSpace</span><span class="p">(</span><span class="n">MemPage</span> <span class="o">*</span><span class="n">pPage</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">u16</span> <span class="o">*</span><span class="n">pIdx</span><span class="p">,</span> <span class="n">idx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">FreeBlk</span> <span class="o">*</span><span class="n">pFBlk</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">FreeBlk</span> <span class="o">*</span><span class="n">pNew</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">FreeBlk</span> <span class="o">*</span><span class="n">pNext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">sqlitepager_iswriteable</span><span class="p">(</span><span class="n">pPage</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">size</span> <span class="o">==</span> <span class="n">ROUNDUP</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">start</span> <span class="o">==</span> <span class="n">ROUNDUP</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">pIdx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">firstFree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">idx</span> <span class="o">=</span> <span class="o">*</span><span class="n">pIdx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span> <span class="n">idx</span><span class="o">!=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span><span class="o">&lt;</span><span class="n">start</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">pFBlk</span> <span class="o">=</span> <span class="p">(</span><span class="n">FreeBlk</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">aDisk</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">pFBlk</span><span class="o">-&gt;</span><span class="n">iSize</span> <span class="o">==</span> <span class="n">start</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">pFBlk</span><span class="o">-&gt;</span><span class="n">iSize</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">pFBlk</span><span class="o">-&gt;</span><span class="n">iSize</span> <span class="o">==</span> <span class="n">pFBlk</span><span class="o">-&gt;</span><span class="n">iNext</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果可以和下一个区间合并
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">pNext</span> <span class="o">=</span> <span class="p">(</span><span class="n">FreeBlk</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">aDisk</span><span class="p">[</span><span class="n">pFBlk</span><span class="o">-&gt;</span><span class="n">iNext</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">pFBlk</span><span class="o">-&gt;</span><span class="n">iSize</span> <span class="o">+=</span> <span class="n">pNext</span><span class="o">-&gt;</span><span class="n">iSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">pFBlk</span><span class="o">-&gt;</span><span class="n">iNext</span> <span class="o">=</span> <span class="n">pNext</span><span class="o">-&gt;</span><span class="n">iNext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nFree</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">pIdx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pFBlk</span><span class="o">-&gt;</span><span class="n">iNext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">idx</span> <span class="o">=</span> <span class="o">*</span><span class="n">pIdx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">pNew</span> <span class="o">=</span> <span class="p">(</span><span class="n">FreeBlk</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">aDisk</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 检查是否可以和后面的区间合并
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span> <span class="n">idx</span> <span class="o">!=</span> <span class="n">end</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">iSize</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">iNext</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">pNext</span> <span class="o">=</span> <span class="p">(</span><span class="n">FreeBlk</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">aDisk</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">iSize</span> <span class="o">=</span> <span class="n">size</span> <span class="o">+</span> <span class="n">pNext</span><span class="o">-&gt;</span><span class="n">iSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">iNext</span> <span class="o">=</span> <span class="n">pNext</span><span class="o">-&gt;</span><span class="n">iNext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">pIdx</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nFree</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一个MemPage逻辑上来说由多个排序的Cell组成，但在物理存储时即不保证有序也不保证连续。由于插入数据时不一定有序，因此要保证物理存储有序需要移动数据而导致额外的开销，因此实现时并不会移动数据，但通过CellHdr.iNext构成了一个有序的Cell链表。由于删除数据时也不会移动数据，因此Cell之间可能有空洞，这些空洞使用FreeBlk表示，并通过FreeBlk.iNext构成了一个链表。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">FreeBlk</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">u16</span> <span class="n">iSize</span><span class="p">;</span>      <span class="cm">/* Number of bytes in this block of free space */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u16</span> <span class="n">iNext</span><span class="p">;</span>      <span class="cm">/* Index in MemPage.u.aDisk[] of the next free block */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从磁盘加载page后，通过initPage维护内存中的辅助信息，将所有Cell加载到内存中的apCell数组，计算总的空闲字节数信息。initPage后，可以通过apCell随机访问一个Cell，而不需要通过Cell链表顺序访问。在插入时，新的Cell可能超出page size，在短暂的时间内apCell会有指向aDisk外的Cell。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">initPage</span><span class="p">(</span><span class="n">MemPage</span> <span class="o">*</span><span class="n">pPage</span><span class="p">,</span> <span class="n">Pgno</span> <span class="n">pgnoThis</span><span class="p">,</span> <span class="n">MemPage</span> <span class="o">*</span><span class="n">pParent</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>           <span class="cm">/* An index into pPage-&gt;u.aDisk[] */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Cell</span> <span class="o">*</span><span class="n">pCell</span><span class="p">;</span>       <span class="cm">/* A pointer to a Cell in pPage-&gt;u.aDisk[] */</span>
</span></span><span class="line"><span class="cl">  <span class="n">FreeBlk</span> <span class="o">*</span><span class="n">pFBlk</span><span class="p">;</span>    <span class="cm">/* A pointer to a free block in pPage-&gt;u.aDisk[] */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>            <span class="cm">/* The size of a Cell in bytes */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">freeSpace</span><span class="p">;</span>     <span class="cm">/* Amount of free space on the page */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">pParent</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">pParent</span><span class="o">==</span><span class="n">pParent</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pParent</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">pParent</span> <span class="o">=</span> <span class="n">pParent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 增加引用计数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">sqlitepager_ref</span><span class="p">(</span><span class="n">pParent</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">isInit</span> <span class="p">)</span> <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">isInit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">freeSpace</span> <span class="o">=</span> <span class="n">USABLE_SPACE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">idx</span> <span class="o">=</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">firstCell</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span> <span class="n">idx</span><span class="o">!=</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 剩余空间存不下一个Cell  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span> <span class="n">idx</span><span class="o">&gt;</span><span class="n">SQLITE_PAGE_SIZE</span><span class="o">-</span><span class="n">MIN_CELL_SIZE</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">page_format_error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 起始地址在PageHdr内
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span> <span class="n">idx</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">PageHdr</span><span class="p">)</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">page_format_error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 没有4字节对齐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span> <span class="n">idx</span><span class="o">!=</span><span class="n">ROUNDUP</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">page_format_error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pCell</span> <span class="o">=</span> <span class="p">(</span><span class="n">Cell</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">aDisk</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">sz</span> <span class="o">=</span> <span class="n">cellSize</span><span class="p">(</span><span class="n">pCell</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 超过了page size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span> <span class="n">idx</span><span class="o">+</span><span class="n">sz</span> <span class="o">&gt;</span> <span class="n">SQLITE_PAGE_SIZE</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">page_format_error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">freeSpace</span> <span class="o">-=</span> <span class="n">sz</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 加载到cell数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">pCell</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">idx</span> <span class="o">=</span> <span class="n">pCell</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">iNext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nFree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">idx</span> <span class="o">=</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">firstFree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span> <span class="n">idx</span><span class="o">!=</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">idx</span><span class="o">&gt;</span><span class="n">SQLITE_PAGE_SIZE</span><span class="o">-</span><span class="k">sizeof</span><span class="p">(</span><span class="n">FreeBlk</span><span class="p">)</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">page_format_error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">idx</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">PageHdr</span><span class="p">)</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">page_format_error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pFBlk</span> <span class="o">=</span> <span class="p">(</span><span class="n">FreeBlk</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">aDisk</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 维护空闲byte数统计信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nFree</span> <span class="o">+=</span> <span class="n">pFBlk</span><span class="o">-&gt;</span><span class="n">iSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">pFBlk</span><span class="o">-&gt;</span><span class="n">iNext</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pFBlk</span><span class="o">-&gt;</span><span class="n">iNext</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">page_format_error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">idx</span> <span class="o">=</span> <span class="n">pFBlk</span><span class="o">-&gt;</span><span class="n">iNext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span><span class="o">==</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nFree</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* As a special case, an uninitialized root page appears to be
</span></span></span><span class="line"><span class="cl"><span class="cm">    ** an empty database */</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nFree</span><span class="o">!=</span><span class="n">freeSpace</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">page_format_error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">page_format_error</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">SQLITE_CORRUPT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="b树操作">B树操作</h2>
<h3 id="创建b树">创建B树</h3>
<p>先看创建数据库的实现。如果已经至少有2个页，则直接返回。否则创建2个页，并初始化第1个页为PageOne，对第2个页调用zeroPage来重置为一个包含0项的B树节点页。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">newDatabase</span><span class="p">(</span><span class="n">Btree</span> <span class="o">*</span><span class="n">pBt</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">MemPage</span> <span class="o">*</span><span class="n">pRoot</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">PageOne</span> <span class="o">*</span><span class="n">pP1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">sqlitepager_pagecount</span><span class="p">(</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="p">)</span> <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pP1</span> <span class="o">=</span> <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">page1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_write</span><span class="p">(</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">page1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_get</span><span class="p">(</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pRoot</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_write</span><span class="p">(</span><span class="n">pRoot</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pRoot</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">strcpy</span><span class="p">(</span><span class="n">pP1</span><span class="o">-&gt;</span><span class="n">zMagic</span><span class="p">,</span> <span class="n">zMagicHeader</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">pP1</span><span class="o">-&gt;</span><span class="n">iMagic</span> <span class="o">=</span> <span class="n">MAGIC</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">zeroPage</span><span class="p">(</span><span class="n">pRoot</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pRoot</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>sqliteBtreeCreateTable</code> 要做的事情很简单，分配一个页作为根页，返回页号。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sqliteBtreeCreateTable</span><span class="p">(</span><span class="n">Btree</span> <span class="o">*</span><span class="n">pBt</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">piTable</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">MemPage</span> <span class="o">*</span><span class="n">pRoot</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Pgno</span> <span class="n">pgnoRoot</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">inTrans</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_ERROR</span><span class="p">;</span>  <span class="cm">/* Must start a transaction first */</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">readOnly</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_READONLY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果有空闲的，用空闲的，否则分配一个新page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">rc</span> <span class="o">=</span> <span class="n">allocatePage</span><span class="p">(</span><span class="n">pBt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pRoot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pgnoRoot</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">sqlitepager_iswriteable</span><span class="p">(</span><span class="n">pRoot</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">zeroPage</span><span class="p">(</span><span class="n">pRoot</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 不在使用中就调unref
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pRoot</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 返回根所在的页号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">*</span><span class="n">piTable</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">pgnoRoot</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="cursor操作">Cursor操作</h3>
<p>Cursor用于B树的遍历或者定位，其定义如下。mPage指向当前的page，idx指向当前的项。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">** A cursor is a pointer to a particular entry in the BTree.
</span></span></span><span class="line"><span class="cl"><span class="cm">** The entry is identified by its MemPage and the index in
</span></span></span><span class="line"><span class="cl"><span class="cm">** MemPage.apCell[] of the entry.
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">BtCursor</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Btree</span> <span class="o">*</span><span class="n">pBt</span><span class="p">;</span>               <span class="cm">/* The Btree to which this cursor belongs */</span>
</span></span><span class="line"><span class="cl">  <span class="n">BtCursor</span> <span class="o">*</span><span class="n">pNext</span><span class="p">,</span> <span class="o">*</span><span class="n">pPrev</span><span class="p">;</span>  <span class="cm">/* Forms a linked list of all cursors */</span>
</span></span><span class="line"><span class="cl">  <span class="n">Pgno</span> <span class="n">pgnoRoot</span><span class="p">;</span>            <span class="cm">/* The root page of this tree */</span>
</span></span><span class="line"><span class="cl">  <span class="n">MemPage</span> <span class="o">*</span><span class="n">pPage</span><span class="p">;</span>           <span class="cm">/* Page that contains the entry */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>                  <span class="cm">/* Index of the entry in pPage-&gt;apCell[] */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u8</span> <span class="n">wrFlag</span><span class="p">;</span>                <span class="cm">/* True if writable */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u8</span> <span class="n">bSkipNext</span><span class="p">;</span>             <span class="cm">/* sqliteBtreeNext() is no-op if true */</span>
</span></span><span class="line"><span class="cl">  <span class="n">u8</span> <span class="n">iMatch</span><span class="p">;</span>                <span class="cm">/* compare result from last sqliteBtreeMoveto() */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>调用<code>sqliteBtreeCursor</code> 创建一个Cursor</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sqliteBtreeCursor</span><span class="p">(</span><span class="n">Btree</span> <span class="o">*</span><span class="n">pBt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iTable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wrFlag</span><span class="p">,</span> <span class="n">BtCursor</span> <span class="o">**</span><span class="n">ppCur</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">BtCursor</span> <span class="o">*</span><span class="n">pCur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ptr</span> <span class="n">nLock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">page1</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 打开PageOne，并获取一个数据库读锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">lockBtree</span><span class="p">(</span><span class="n">pBt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="o">*</span><span class="n">ppCur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">wrFlag</span> <span class="o">&amp;&amp;</span> <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">readOnly</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">ppCur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_READONLY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">pCur</span> <span class="o">=</span> <span class="n">sqliteMalloc</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pCur</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pCur</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">SQLITE_NOMEM</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">create_cursor_exception</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 设置root页号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pgnoRoot</span> <span class="o">=</span> <span class="p">(</span><span class="n">Pgno</span><span class="p">)</span><span class="n">iTable</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 获取当前页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_get</span><span class="p">(</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">,</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pgnoRoot</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">create_cursor_exception</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 初始化page在内存中的额外辅助信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">rc</span> <span class="o">=</span> <span class="n">initPage</span><span class="p">(</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="p">,</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pgnoRoot</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">create_cursor_exception</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">nLock</span> <span class="o">=</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span><span class="n">sqliteHashFind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">iTable</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// nLock &lt; 0说明已被别人上了写锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// nLock &gt; 0 说明已被别人上了读锁，如果wrFlag为true，则获取写锁失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span> <span class="n">nLock</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">nLock</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">wrFlag</span><span class="p">)</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">SQLITE_LOCKED</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">goto</span> <span class="n">create_cursor_exception</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 写锁为负，读锁为正，0即NULL表示没有锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">nLock</span> <span class="o">=</span> <span class="n">wrFlag</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">nLock</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">sqliteHashInsert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">iTable</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">nLock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pBt</span> <span class="o">=</span> <span class="n">pBt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">wrFlag</span> <span class="o">=</span> <span class="n">wrFlag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 维护cursor链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pNext</span> <span class="o">=</span> <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pCursor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pNext</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="o">-&gt;</span><span class="n">pPrev</span> <span class="o">=</span> <span class="n">pCur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPrev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pCursor</span> <span class="o">=</span> <span class="n">pCur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">ppCur</span> <span class="o">=</span> <span class="n">pCur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">create_cursor_exception</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">ppCur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pCur</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span> <span class="p">)</span> <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">sqliteFree</span><span class="p">(</span><span class="n">pCur</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">unlockBtreeIfUnused</span><span class="p">(</span><span class="n">pBt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个版本的Cursor支持的操作为First, Last, Next, Moveto，分别指向第一个、最后一个、下一个、指定的key。</p>
<p><code>sqliteBtreeFirst</code> 先将Cursor指向root，然后沿着左子指针不断移动。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sqliteBtreeFirst</span><span class="p">(</span><span class="n">BtCursor</span> <span class="o">*</span><span class="n">pCur</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pRes</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="o">==</span><span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">SQLITE_ABORT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">rc</span> <span class="o">=</span> <span class="n">moveToRoot</span><span class="p">(</span><span class="n">pCur</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">pRes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">pRes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">rc</span> <span class="o">=</span> <span class="n">moveToLeftmost</span><span class="p">(</span><span class="n">pCur</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">bSkipNext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">moveToRoot</span><span class="p">(</span><span class="n">BtCursor</span> <span class="o">*</span><span class="n">pCur</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">MemPage</span> <span class="o">*</span><span class="n">pNew</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 载入page，并修改cursor指向的page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_get</span><span class="p">(</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">,</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pgnoRoot</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pNew</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">rc</span> <span class="o">=</span> <span class="n">initPage</span><span class="p">(</span><span class="n">pNew</span><span class="p">,</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pgnoRoot</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span> <span class="o">=</span> <span class="n">pNew</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 重置idx为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">moveToLeftmost</span><span class="p">(</span><span class="n">BtCursor</span> <span class="o">*</span><span class="n">pCur</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">Pgno</span> <span class="n">pgno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 沿着最左的child指针不断移动
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span><span class="p">(</span> <span class="p">(</span><span class="n">pgno</span> <span class="o">=</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">leftChild</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">moveToChild</span><span class="p">(</span><span class="n">pCur</span><span class="p">,</span> <span class="n">pgno</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">moveToChild</span><span class="p">(</span><span class="n">BtCursor</span> <span class="o">*</span><span class="n">pCur</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newPgno</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">MemPage</span> <span class="o">*</span><span class="n">pNewPage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 载入page，并修改cursor指向的page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_get</span><span class="p">(</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">,</span> <span class="n">newPgno</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pNewPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">rc</span> <span class="o">=</span> <span class="n">initPage</span><span class="p">(</span><span class="n">pNewPage</span><span class="p">,</span> <span class="n">newPgno</span><span class="p">,</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span> <span class="o">=</span> <span class="n">pNewPage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>sqliteBtreeNext</code> 移动到下一个KV。如果这一层还没遍历完，先将idx指向下一个Cell，然后移动到该Cell下层的最左节点。否则向上层回溯，由于采用的是B树实现，回溯到上层的有效节点就可以返回了，因为中间节点也存储着数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sqliteBtreeNext</span><span class="p">(</span><span class="n">BtCursor</span> <span class="o">*</span><span class="n">pCur</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pRes</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">pRes</span> <span class="p">)</span> <span class="o">*</span><span class="n">pRes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_ABORT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 之前的操作已经指向了下一个元素，直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">bSkipNext</span> <span class="o">&amp;&amp;</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span><span class="o">&lt;</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">bSkipNext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">pRes</span> <span class="p">)</span> <span class="o">*</span><span class="n">pRes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// idx + 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 已经遍历完这个page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span><span class="o">&gt;=</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果存在右子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">rightChild</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 移动到右子树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">rc</span> <span class="o">=</span> <span class="n">moveToChild</span><span class="p">(</span><span class="n">pCur</span><span class="p">,</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">rightChild</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 移动到右子树下的最左节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">rc</span> <span class="o">=</span> <span class="n">moveToLeftmost</span><span class="p">(</span><span class="n">pCur</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span> <span class="n">pRes</span> <span class="p">)</span> <span class="o">*</span><span class="n">pRes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// pParent == 0 说明整个树已遍历完
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span><span class="p">(</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">pParent</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span> <span class="n">pRes</span> <span class="p">)</span> <span class="o">*</span><span class="n">pRes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 移动到parent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">rc</span> <span class="o">=</span> <span class="n">moveToParent</span><span class="p">(</span><span class="n">pCur</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">while</span><span class="p">(</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span><span class="o">&gt;=</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// B树的中间节点也存储数据，因此这里返回了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span> <span class="n">pRes</span> <span class="p">)</span> <span class="o">*</span><span class="n">pRes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 移动到该节点下的最左节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">rc</span> <span class="o">=</span> <span class="n">moveToLeftmost</span><span class="p">(</span><span class="n">pCur</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pRes</span> <span class="p">)</span> <span class="o">*</span><span class="n">pRes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">moveToParent</span><span class="p">(</span><span class="n">BtCursor</span> <span class="o">*</span><span class="n">pCur</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">Pgno</span> <span class="n">oldPgno</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">MemPage</span> <span class="o">*</span><span class="n">pParent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pParent</span> <span class="o">=</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">pParent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pParent</span><span class="o">==</span><span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">SQLITE_INTERNAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">oldPgno</span> <span class="o">=</span> <span class="n">sqlitepager_pagenumber</span><span class="p">(</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">sqlitepager_ref</span><span class="p">(</span><span class="n">pParent</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span> <span class="o">=</span> <span class="n">pParent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="n">pParent</span><span class="o">-&gt;</span><span class="n">nCell</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">pParent</span><span class="o">-&gt;</span><span class="n">nCell</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">pParent</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">leftChild</span><span class="o">==</span><span class="n">oldPgno</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 设置idx为包含原child的Cell的下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>sqliteBtreeMoveto</code> 将Cursor移动到指定key附近的KV。在key不存在时，有可能指向在该key之前或之后的key，使用*pRes的值来表示不同的结果（&lt;0 之前的key，=0 恰好指向，&gt;0 之后的key）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sqliteBtreeMoveto</span><span class="p">(</span><span class="n">BtCursor</span> <span class="o">*</span><span class="n">pCur</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pKey</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nKey</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pRes</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="o">==</span><span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">SQLITE_ABORT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">bSkipNext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 先移动到root页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">rc</span> <span class="o">=</span> <span class="n">moveToRoot</span><span class="p">(</span><span class="n">pCur</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(;;){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">lwr</span><span class="p">,</span> <span class="n">upr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Pgno</span> <span class="n">chldPg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">MemPage</span> <span class="o">*</span><span class="n">pPage</span> <span class="o">=</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">lwr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">upr</span> <span class="o">=</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 二分查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span> <span class="n">lwr</span><span class="o">&lt;=</span><span class="n">upr</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">lwr</span><span class="o">+</span><span class="n">upr</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 比较当前idx指向的Cell和key的大小关系，必要时会加载overflow页的数据。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">rc</span> <span class="o">=</span> <span class="n">sqliteBtreeKeyCompare</span><span class="p">(</span><span class="n">pCur</span><span class="p">,</span> <span class="n">pKey</span><span class="p">,</span> <span class="n">nKey</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span> <span class="n">c</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">iMatch</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span> <span class="n">pRes</span> <span class="p">)</span> <span class="o">*</span><span class="n">pRes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span> <span class="n">c</span><span class="o">&lt;</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">lwr</span> <span class="o">=</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">upr</span> <span class="o">=</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span> <span class="n">lwr</span><span class="o">==</span><span class="n">upr</span><span class="o">+</span><span class="mi">1</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">lwr</span><span class="o">&gt;=</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">chldPg</span> <span class="o">=</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">rightChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">chldPg</span> <span class="o">=</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">lwr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">leftChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 没有child页了则返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span> <span class="n">chldPg</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">iMatch</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span> <span class="n">pRes</span> <span class="p">)</span> <span class="o">*</span><span class="n">pRes</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 从该child处继续找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">moveToChild</span><span class="p">(</span><span class="n">pCur</span><span class="p">,</span> <span class="n">chldPg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* NOT REACHED */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="插入删除">插入删除</h3>
<p>在插入KV时，先将Cursor移动到key附近，然后根据是否存在key做一些不同<code>apCell</code> 数组的维护工作，最后调用rebalance来做树平衡。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">** Insert a new record into the BTree.  The key is given by (pKey,nKey)
</span></span></span><span class="line"><span class="cl"><span class="cm">** and the data is given by (pData,nData).  The cursor is used only to
</span></span></span><span class="line"><span class="cl"><span class="cm">** define what database the record should be inserted into.  The cursor
</span></span></span><span class="line"><span class="cl"><span class="cm">** is left pointing at the new record.
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sqliteBtreeInsert</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">BtCursor</span> <span class="o">*</span><span class="n">pCur</span><span class="p">,</span>                <span class="cm">/* Insert data into the table of this cursor */</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pKey</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nKey</span><span class="p">,</span>    <span class="cm">/* The key of the new record */</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">pData</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nData</span>   <span class="cm">/* The data of the new record */</span>
</span></span><span class="line"><span class="cl"><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">Cell</span> <span class="n">newCell</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">loc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">szNew</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">MemPage</span> <span class="o">*</span><span class="n">pPage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Btree</span> <span class="o">*</span><span class="n">pBt</span> <span class="o">=</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pBt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_ABORT</span><span class="p">;</span>  <span class="cm">/* A rollback destroyed this cursor */</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">inTrans</span> <span class="o">||</span> <span class="n">nKey</span><span class="o">+</span><span class="n">nData</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_ERROR</span><span class="p">;</span>  <span class="cm">/* Must start a transaction first */</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">wrFlag</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_PERM</span><span class="p">;</span>   <span class="cm">/* Cursor not open for writing */</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 移动到key附近
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">rc</span> <span class="o">=</span> <span class="n">sqliteBtreeMoveto</span><span class="p">(</span><span class="n">pCur</span><span class="p">,</span> <span class="n">pKey</span><span class="p">,</span> <span class="n">nKey</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">loc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pPage</span> <span class="o">=</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_write</span><span class="p">(</span><span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 分配一个cell来存放key/value，可能有overflow 页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">rc</span> <span class="o">=</span> <span class="n">fillInCell</span><span class="p">(</span><span class="n">pBt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newCell</span><span class="p">,</span> <span class="n">pKey</span><span class="p">,</span> <span class="n">nKey</span><span class="p">,</span> <span class="n">pData</span><span class="p">,</span> <span class="n">nData</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">szNew</span> <span class="o">=</span> <span class="n">cellSize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newCell</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">loc</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 恰好匹配，需要删除之前的Cell。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 调用clearCell释放涉及的overflow页，调用dropCell来从apCell数组中删除。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">newCell</span><span class="p">.</span><span class="n">h</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">leftChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">clearCell</span><span class="p">(</span><span class="n">pBt</span><span class="p">,</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">dropCell</span><span class="p">(</span><span class="n">pPage</span><span class="p">,</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">(</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">]));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="n">loc</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span><span class="o">&gt;</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">rightChild</span><span class="o">==</span><span class="mi">0</span> <span class="p">);</span>  <span class="cm">/* Must be a leaf page */</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// idx+1指向下一个位置，和下面的else得到相同的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// rightChild说明是leaf页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">rightChild</span><span class="o">==</span><span class="mi">0</span> <span class="p">);</span>  <span class="cm">/* Must be a leaf page */</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 将新的Cell插入，执行完成后有可能超出page size，后面的balance会处理。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">insertCell</span><span class="p">(</span><span class="n">pPage</span><span class="p">,</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newCell</span><span class="p">,</span> <span class="n">szNew</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">rc</span> <span class="o">=</span> <span class="n">balance</span><span class="p">(</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pBt</span><span class="p">,</span> <span class="n">pPage</span><span class="p">,</span> <span class="n">pCur</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* sqliteBtreePageDump(pCur-&gt;pBt, pCur-&gt;pgnoRoot, 1); */</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* fflush(stdout); */</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">insertCell</span><span class="p">(</span><span class="n">MemPage</span> <span class="o">*</span><span class="n">pPage</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">Cell</span> <span class="o">*</span><span class="n">pCell</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">sz</span><span class="o">==</span><span class="n">cellSize</span><span class="p">(</span><span class="n">pCell</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">sqlitepager_iswriteable</span><span class="p">(</span><span class="n">pPage</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 分配空间不足，idx==0说明没有足够的空间。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">idx</span> <span class="o">=</span> <span class="n">allocateSpace</span><span class="p">(</span><span class="n">pPage</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span><span class="p">;</span> <span class="n">j</span><span class="o">&gt;</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">idx</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 空间不足，标记已overfull
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">isOverfull</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pCell</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">aDisk</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">pCell</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Cell</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">aDisk</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">allocateSpace</span><span class="p">(</span><span class="n">MemPage</span> <span class="o">*</span><span class="n">pPage</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nByte</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">FreeBlk</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">u16</span> <span class="o">*</span><span class="n">pIdx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">sqlitepager_iswriteable</span><span class="p">(</span><span class="n">pPage</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">nByte</span><span class="o">==</span><span class="n">ROUNDUP</span><span class="p">(</span><span class="n">nByte</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 空间不足或者之前已经不足过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nFree</span><span class="o">&lt;</span><span class="n">nByte</span> <span class="o">||</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">isOverfull</span> <span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pIdx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">firstFree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">FreeBlk</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">aDisk</span><span class="p">[</span><span class="o">*</span><span class="n">pIdx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">iSize</span><span class="o">&lt;</span><span class="n">nByte</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span> <span class="n">cnt</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">SQLITE_PAGE_SIZE</span><span class="o">/</span><span class="mi">4</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">iNext</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 没有一个足够大的空闲块，需要整理页。将所有的Cell移动到页的开始，最后有一个大的空闲块。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">defragmentPage</span><span class="p">(</span><span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">pIdx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">firstFree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">pIdx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">iNext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">FreeBlk</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">aDisk</span><span class="p">[</span><span class="o">*</span><span class="n">pIdx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 正好匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">iSize</span><span class="o">==</span><span class="n">nByte</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">start</span> <span class="o">=</span> <span class="o">*</span><span class="n">pIdx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">pIdx</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">iNext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 分裂出一个新块
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">FreeBlk</span> <span class="o">*</span><span class="n">pNew</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">start</span> <span class="o">=</span> <span class="o">*</span><span class="n">pIdx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pNew</span> <span class="o">=</span> <span class="p">(</span><span class="n">FreeBlk</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">aDisk</span><span class="p">[</span><span class="n">start</span> <span class="o">+</span> <span class="n">nByte</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">iNext</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">iNext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">iSize</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">iSize</span> <span class="o">-</span> <span class="n">nByte</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">pIdx</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">nByte</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nFree</span> <span class="o">-=</span> <span class="n">nByte</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>sqliteBtreeDelete</code> 用于删除Cursor当前指向的KV。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sqliteBtreeDelete</span><span class="p">(</span><span class="n">BtCursor</span> <span class="o">*</span><span class="n">pCur</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">MemPage</span> <span class="o">*</span><span class="n">pPage</span> <span class="o">=</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Cell</span> <span class="o">*</span><span class="n">pCell</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Pgno</span> <span class="n">pgnoChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_ABORT</span><span class="p">;</span>  <span class="cm">/* A rollback destroyed this cursor */</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">inTrans</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_ERROR</span><span class="p">;</span>  <span class="cm">/* Must start a transaction first */</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_ERROR</span><span class="p">;</span>  <span class="cm">/* The cursor is not pointing to anything */</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">wrFlag</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">SQLITE_PERM</span><span class="p">;</span>   <span class="cm">/* Did not open this cursor for writing */</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_write</span><span class="p">(</span><span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pCell</span> <span class="o">=</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="n">pgnoChild</span> <span class="o">=</span> <span class="n">pCell</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">leftChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">clearCell</span><span class="p">(</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pBt</span><span class="p">,</span> <span class="n">pCell</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pgnoChild</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">    ** The entry we are about to delete is not a leaf so if we do not
</span></span></span><span class="line"><span class="cl"><span class="cm">    ** do something we will leave a hole on an internal page.
</span></span></span><span class="line"><span class="cl"><span class="cm">    ** We have to fill the hole by moving in a cell from a leaf.  The
</span></span></span><span class="line"><span class="cl"><span class="cm">    ** next Cell after the one to be deleted is guaranteed to exist and
</span></span></span><span class="line"><span class="cl"><span class="cm">    ** to be a leaf so we can use it.
</span></span></span><span class="line"><span class="cl"><span class="cm">    */</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果不是叶节点，将该节点的下一个节点移动过来，以满足B树的要求。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">BtCursor</span> <span class="n">leafCur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Cell</span> <span class="o">*</span><span class="n">pNext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">szNext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">getTempCursor</span><span class="p">(</span><span class="n">pCur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">leafCur</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 找到next节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">sqliteBtreeNext</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leafCur</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">SQLITE_CORRUPT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_write</span><span class="p">(</span><span class="n">leafCur</span><span class="p">.</span><span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 从当前page drop当前cell
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">dropCell</span><span class="p">(</span><span class="n">pPage</span><span class="p">,</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">(</span><span class="n">pCell</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">pNext</span> <span class="o">=</span> <span class="n">leafCur</span><span class="p">.</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">leafCur</span><span class="p">.</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">szNext</span> <span class="o">=</span> <span class="n">cellSize</span><span class="p">(</span><span class="n">pNext</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 修改next节点的leftChild值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pNext</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">pgnoChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将next节点插入到当前的page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">insertCell</span><span class="p">(</span><span class="n">pPage</span><span class="p">,</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">,</span> <span class="n">pNext</span><span class="p">,</span> <span class="n">szNext</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 平衡
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">balance</span><span class="p">(</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pBt</span><span class="p">,</span> <span class="n">pPage</span><span class="p">,</span> <span class="n">pCur</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">bSkipNext</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 将next节点drop掉
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">dropCell</span><span class="p">(</span><span class="n">leafCur</span><span class="p">.</span><span class="n">pPage</span><span class="p">,</span> <span class="n">leafCur</span><span class="p">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">szNext</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 平衡
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">balance</span><span class="p">(</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pBt</span><span class="p">,</span> <span class="n">leafCur</span><span class="p">.</span><span class="n">pPage</span><span class="p">,</span> <span class="n">pCur</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">releaseTempCursor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">leafCur</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// drop cell  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">dropCell</span><span class="p">(</span><span class="n">pPage</span><span class="p">,</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">(</span><span class="n">pCell</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span><span class="o">&gt;=</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span><span class="o">&lt;</span><span class="mi">0</span> <span class="p">){</span> 
</span></span><span class="line"><span class="cl">        <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">bSkipNext</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">bSkipNext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">bSkipNext</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">balance</span><span class="p">(</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pBt</span><span class="p">,</span> <span class="n">pPage</span><span class="p">,</span> <span class="n">pCur</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="平衡操作">平衡操作</h3>
<p>在看balance实现之前，先看几个辅助函数</p>
<p><code>relinkCellList</code> 用于在插入或删除Cell后，更新<code>MemPage.u.aDisk</code> 中的next指针，这是因为在insertCell和dropCell中只处理了MemPage.apCell，没有处理aDisk中的iNext。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">relinkCellList</span><span class="p">(</span><span class="n">MemPage</span> <span class="o">*</span><span class="n">pPage</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">u16</span> <span class="o">*</span><span class="n">pIdx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">sqlitepager_iswriteable</span><span class="p">(</span><span class="n">pPage</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">pIdx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">firstCell</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">Addr</span><span class="p">(</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">Addr</span><span class="p">(</span><span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span> <span class="n">idx</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span><span class="o">&lt;</span><span class="n">SQLITE_PAGE_SIZE</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">pIdx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pIdx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">iNext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">pIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>copyPage</code> 用于拷贝存在overfull时的page，对于不在page的Cell，拷贝后的page仍然指向原内存。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">copyPage</span><span class="p">(</span><span class="n">MemPage</span> <span class="o">*</span><span class="n">pTo</span><span class="p">,</span> <span class="n">MemPage</span> <span class="o">*</span><span class="n">pFrom</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">uptr</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">memcpy</span><span class="p">(</span><span class="n">pTo</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">aDisk</span><span class="p">,</span> <span class="n">pFrom</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">aDisk</span><span class="p">,</span> <span class="n">SQLITE_PAGE_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">pTo</span><span class="o">-&gt;</span><span class="n">pParent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pTo</span><span class="o">-&gt;</span><span class="n">isInit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pTo</span><span class="o">-&gt;</span><span class="n">nCell</span> <span class="o">=</span> <span class="n">pFrom</span><span class="o">-&gt;</span><span class="n">nCell</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pTo</span><span class="o">-&gt;</span><span class="n">nFree</span> <span class="o">=</span> <span class="n">pFrom</span><span class="o">-&gt;</span><span class="n">nFree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pTo</span><span class="o">-&gt;</span><span class="n">isOverfull</span> <span class="o">=</span> <span class="n">pFrom</span><span class="o">-&gt;</span><span class="n">isOverfull</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">to</span> <span class="o">=</span> <span class="n">Addr</span><span class="p">(</span><span class="n">pTo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">from</span> <span class="o">=</span> <span class="n">Addr</span><span class="p">(</span><span class="n">pFrom</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">pTo</span><span class="o">-&gt;</span><span class="n">nCell</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">uptr</span> <span class="n">x</span> <span class="o">=</span> <span class="n">Addr</span><span class="p">(</span><span class="n">pFrom</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果在page范围内，更新，否则用from的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span> <span class="n">x</span><span class="o">&gt;</span><span class="n">from</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">&lt;</span><span class="n">from</span><span class="o">+</span><span class="n">SQLITE_PAGE_SIZE</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="o">*</span><span class="p">((</span><span class="n">uptr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pTo</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">to</span> <span class="o">-</span> <span class="n">from</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">pTo</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pFrom</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>reparentChildPages</code> 用于在移动page后修改内存中的child页的<code>pParent</code> 指针，因为<code>pParent</code> 指针仅在内存中存储，所以在实现时不需要从磁盘加载没有缓存的page。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">reparentChildPages</span><span class="p">(</span><span class="n">Pager</span> <span class="o">*</span><span class="n">pPager</span><span class="p">,</span> <span class="n">MemPage</span> <span class="o">*</span><span class="n">pPage</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">reparentPage</span><span class="p">(</span><span class="n">pPager</span><span class="p">,</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">leftChild</span><span class="p">,</span> <span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">reparentPage</span><span class="p">(</span><span class="n">pPager</span><span class="p">,</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">rightChild</span><span class="p">,</span> <span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">reparentPage</span><span class="p">(</span><span class="n">Pager</span> <span class="o">*</span><span class="n">pPager</span><span class="p">,</span> <span class="n">Pgno</span> <span class="n">pgno</span><span class="p">,</span> <span class="n">MemPage</span> <span class="o">*</span><span class="n">pNewParent</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="n">MemPage</span> <span class="o">*</span><span class="n">pThis</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pgno</span><span class="o">==</span><span class="mi">0</span> <span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">pPager</span><span class="o">!=</span><span class="mi">0</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 只需要修改内存中缓存的页的parent，因此调lookup而不是get
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">pThis</span> <span class="o">=</span> <span class="n">sqlitepager_lookup</span><span class="p">(</span><span class="n">pPager</span><span class="p">,</span> <span class="n">pgno</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pThis</span> <span class="o">&amp;&amp;</span> <span class="n">pThis</span><span class="o">-&gt;</span><span class="n">isInit</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">pThis</span><span class="o">-&gt;</span><span class="n">pParent</span><span class="o">!=</span><span class="n">pNewParent</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span> <span class="n">pThis</span><span class="o">-&gt;</span><span class="n">pParent</span> <span class="p">)</span> <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pThis</span><span class="o">-&gt;</span><span class="n">pParent</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">pThis</span><span class="o">-&gt;</span><span class="n">pParent</span> <span class="o">=</span> <span class="n">pNewParent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span> <span class="n">pNewParent</span> <span class="p">)</span> <span class="n">sqlitepager_ref</span><span class="p">(</span><span class="n">pNewParent</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pThis</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>铺垫完成，下面来看B树的平衡实现。</p>
<p><code>balance</code> 用于实现B树的平衡，它的基本思想很简单，找到页面相邻的两个兄弟页面，然后根据这三个页面的总空间需求，分配新的页面来存储，新的页面的free空间尽可能均匀。最终兄弟页面的个数可能会加1或减1，目标是页面的空间使用在66%到100%之间。</p>
<p>1 先看root page的处理。</p>
<ul>
<li>如果Cell个数为0，且有rightChild，将rightChild的页拷贝过来作为新的root page。拷贝之后需要修改内存中child页的parent指针。</li>
<li>如果root页overfull，创建一个新的child页拷贝过去，然后将root页设置为空，并且rightChild指向新页，后面的逻辑会执行新页的split。通过这样的处理可以复用非root页的balance逻辑。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">balance</span><span class="p">(</span><span class="n">Btree</span> <span class="o">*</span><span class="n">pBt</span><span class="p">,</span> <span class="n">MemPage</span> <span class="o">*</span><span class="n">pPage</span><span class="p">,</span> <span class="n">BtCursor</span> <span class="o">*</span><span class="n">pCur</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 省略一些变量定义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">pParent</span> <span class="o">=</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">pParent</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 1 root页处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span> <span class="n">pParent</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">Pgno</span> <span class="n">pgnoChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">MemPage</span> <span class="o">*</span><span class="n">pChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 如果root page没有cell但rightChild不为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span><span class="p">(</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">rightChild</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">        ** The root page is empty.  Copy the one child page
</span></span></span><span class="line"><span class="cl"><span class="cm">        ** into the root page and return.  This reduces the depth
</span></span></span><span class="line"><span class="cl"><span class="cm">        ** of the BTree by one.
</span></span></span><span class="line"><span class="cl"><span class="cm">        */</span>
</span></span><span class="line"><span class="cl">        <span class="n">pgnoChild</span> <span class="o">=</span> <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">rightChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_get</span><span class="p">(</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">,</span> <span class="n">pgnoChild</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pChild</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 拷贝过来后重新初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">memcpy</span><span class="p">(</span><span class="n">pPage</span><span class="p">,</span> <span class="n">pChild</span><span class="p">,</span> <span class="n">SQLITE_PAGE_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">isInit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">rc</span> <span class="o">=</span> <span class="n">initPage</span><span class="p">(</span><span class="n">pPage</span><span class="p">,</span> <span class="n">sqlitepager_pagenumber</span><span class="p">(</span><span class="n">pPage</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">assert</span><span class="p">(</span> <span class="n">rc</span><span class="o">==</span><span class="n">SQLITE_OK</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 拷贝之后，修改内存中的child页的parent指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">reparentChildPages</span><span class="p">(</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">,</span> <span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span> <span class="n">pCur</span> <span class="o">&amp;&amp;</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="o">==</span><span class="n">pChild</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">          <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pChild</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span> <span class="o">=</span> <span class="n">pPage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="n">sqlitepager_ref</span><span class="p">(</span><span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">freePage</span><span class="p">(</span><span class="n">pBt</span><span class="p">,</span> <span class="n">pChild</span><span class="p">,</span> <span class="n">pgnoChild</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pChild</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">relinkCellList</span><span class="p">(</span><span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">isOverfull</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/* It is OK for the root page to be less than half full.
</span></span></span><span class="line"><span class="cl"><span class="cm">      */</span>
</span></span><span class="line"><span class="cl">      <span class="n">relinkCellList</span><span class="p">(</span><span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">    ** If we get to here, it means the root page is overfull.
</span></span></span><span class="line"><span class="cl"><span class="cm">    ** When this happens, Create a new child page and copy the
</span></span></span><span class="line"><span class="cl"><span class="cm">    ** contents of the root into the child.  Then make the root
</span></span></span><span class="line"><span class="cl"><span class="cm">    ** page an empty page with rightChild pointing to the new
</span></span></span><span class="line"><span class="cl"><span class="cm">    ** child.  Then fall thru to the code below which will cause
</span></span></span><span class="line"><span class="cl"><span class="cm">    ** the overfull child page to be split.
</span></span></span><span class="line"><span class="cl"><span class="cm">    */</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// root页overfull，创建一个新的child页拷贝过去，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 然后将root页设置为空，并且rightChild指向新页，后面的逻辑会执行新页的split
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_write</span><span class="p">(</span><span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">allocatePage</span><span class="p">(</span><span class="n">pBt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pChild</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pgnoChild</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span> <span class="n">sqlitepager_iswriteable</span><span class="p">(</span><span class="n">pChild</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 和上面memcpy然后initPage的区别在于，copyPage会考虑overfull，这些cell仍然指向pFrom的原始内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">copyPage</span><span class="p">(</span><span class="n">pChild</span><span class="p">,</span> <span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pChild</span><span class="o">-&gt;</span><span class="n">pParent</span> <span class="o">=</span> <span class="n">pPage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sqlitepager_ref</span><span class="p">(</span><span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pChild</span><span class="o">-&gt;</span><span class="n">isOverfull</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">pCur</span> <span class="o">&amp;&amp;</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="o">==</span><span class="n">pPage</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span> <span class="o">=</span> <span class="n">pChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">extraUnref</span> <span class="o">=</span> <span class="n">pChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">zeroPage</span><span class="p">(</span><span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">pgnoChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pParent</span> <span class="o">=</span> <span class="n">pPage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pPage</span> <span class="o">=</span> <span class="n">pChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 需要修改parent页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_write</span><span class="p">(</span><span class="n">pParent</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>2 在页的左右各取一个兄弟。如果页是最左或最右时，会取同一边的两个兄弟。如果兄弟个数少于等于3，会用上所有的兄弟页。这些页的Cell加上parent中分割的Cell会一起计算总的空间需求，用于分配新页。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">  <span class="c1">// 省略一些逻辑，设置idx为parent页指向本页的Cell的下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 2 在页左右各取一个兄弟。如果页是最左或最右时，会取同一边的两个兄弟。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 如果兄弟个数少于等于3，会用上所有的兄弟页。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span><span class="p">(</span> <span class="n">idx</span><span class="o">==</span><span class="n">pParent</span><span class="o">-&gt;</span><span class="n">nCell</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">nxDiv</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">nxDiv</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">nxDiv</span><span class="o">&lt;</span><span class="mi">0</span> <span class="p">)</span> <span class="n">nxDiv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">nDiv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">nxDiv</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">k</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">pParent</span><span class="o">-&gt;</span><span class="n">nCell</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// parent只分割Cell的index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">idxDiv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 获取parent中的分割Cell，会和兄弟page的Cell一起用于分配新页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">apDiv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pParent</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="n">nDiv</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">pgnoOld</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">apDiv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">leftChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">k</span><span class="o">==</span><span class="n">pParent</span><span class="o">-&gt;</span><span class="n">nCell</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">pgnoOld</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pParent</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">rightChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 加载兄弟页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_get</span><span class="p">(</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">,</span> <span class="n">pgnoOld</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">apOld</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">balance_cleanup</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">initPage</span><span class="p">(</span><span class="n">apOld</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pgnoOld</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pParent</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">balance_cleanup</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">nOld</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>3 将找到的兄弟页拷贝到内存中的临时页，因为这些兄弟页后续可能会修改。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 3 将这些页拷贝到内存中新页，因为原始页有可能修改。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nOld</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">copyPage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aOld</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">apOld</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">freePage</span><span class="p">(</span><span class="n">pBt</span><span class="p">,</span> <span class="n">apOld</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pgnoOld</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">balance_cleanup</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">apOld</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="n">apOld</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">aOld</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>4  计算兄弟页和parent中的分割Cell需要使用的空间，把这些Cell都拷贝到apCell数组，然后计算需要分配多少新页，每个新页的剩余空间保证相对均匀。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// 4 计算兄弟页和parent中的分割Cell需要使用的空间，把这些Cell都拷贝到apCell数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Cell</span> <span class="o">*</span><span class="n">apCell</span><span class="p">[</span><span class="n">MX_CELL</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">5</span><span class="p">];</span>   <span class="cm">/* All cells from pages being balanceed */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">szCell</span><span class="p">[</span><span class="n">MX_CELL</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">5</span><span class="p">];</span>     <span class="cm">/* Local size of all cells */</span>
</span></span><span class="line"><span class="cl">  <span class="n">nCell</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nOld</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">MemPage</span> <span class="o">*</span><span class="n">pOld</span> <span class="o">=</span> <span class="n">apOld</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">pOld</span><span class="o">-&gt;</span><span class="n">nCell</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">apCell</span><span class="p">[</span><span class="n">nCell</span><span class="p">]</span> <span class="o">=</span> <span class="n">pOld</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="n">szCell</span><span class="p">[</span><span class="n">nCell</span><span class="p">]</span> <span class="o">=</span> <span class="n">cellSize</span><span class="p">(</span><span class="n">apCell</span><span class="p">[</span><span class="n">nCell</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">      <span class="n">nCell</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 拷贝parent中的分割Cell
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nOld</span><span class="o">-</span><span class="mi">1</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">szCell</span><span class="p">[</span><span class="n">nCell</span><span class="p">]</span> <span class="o">=</span> <span class="n">cellSize</span><span class="p">(</span><span class="n">apDiv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">      <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aTemp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">apDiv</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">szCell</span><span class="p">[</span><span class="n">nCell</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">      <span class="n">apCell</span><span class="p">[</span><span class="n">nCell</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">aTemp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 临时从parent中删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">dropCell</span><span class="p">(</span><span class="n">pParent</span><span class="p">,</span> <span class="n">nxDiv</span><span class="p">,</span> <span class="n">szCell</span><span class="p">[</span><span class="n">nCell</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">      <span class="n">assert</span><span class="p">(</span> <span class="n">apCell</span><span class="p">[</span><span class="n">nCell</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">leftChild</span><span class="o">==</span><span class="n">pgnoOld</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">apCell</span><span class="p">[</span><span class="n">nCell</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">pOld</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">rightChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">nCell</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 计算总的size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">totalSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nCell</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">totalSize</span> <span class="o">+=</span> <span class="n">szCell</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">cntNew</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>               <span class="cm">/* Index in apCell[] of cell after i-th page */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">szNew</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>                <span class="cm">/* Combined size of cells place on i-th page */</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">subtotal</span><span class="o">=</span><span class="n">k</span><span class="o">=</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nCell</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">subtotal</span> <span class="o">+=</span> <span class="n">szCell</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// #define USABLE_SPACE  (SQLITE_PAGE_SIZE - sizeof(PageHdr))
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 分配一个新页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span><span class="p">(</span> <span class="n">subtotal</span> <span class="o">&gt;</span> <span class="n">USABLE_SPACE</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">szNew</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">subtotal</span> <span class="o">-</span> <span class="n">szCell</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="n">cntNew</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">subtotal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">k</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">szNew</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">subtotal</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">cntNew</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">nCell</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">k</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 经过上一个循环，前面的页会接近满，而后面的页有可能接近空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 下面的循环再进行调整，至少占满USABLE_SPACE/2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span> <span class="n">szNew</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">USABLE_SPACE</span><span class="o">/</span><span class="mi">2</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 从前面挪Cell
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">cntNew</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">assert</span><span class="p">(</span> <span class="n">cntNew</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">szNew</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">szCell</span><span class="p">[</span><span class="n">cntNew</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]];</span>
</span></span><span class="line"><span class="cl">      <span class="n">szNew</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">szCell</span><span class="p">[</span><span class="n">cntNew</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">cntNew</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// 分配k个新页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">allocatePage</span><span class="p">(</span><span class="n">pBt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">apNew</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">pgnoNew</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">balance_cleanup</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">nNew</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">zeroPage</span><span class="p">(</span><span class="n">apNew</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="n">apNew</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">isInit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>5 将新页按照页号排序，然后写入Cell到新页，并把分割的Cell插入到parent中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">  <span class="c1">// 5 将新页按照页号排序，排序后磁盘文件是有序的，scan操作是线性的。注释中说排序可以让大的插入和删除快25%。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">minV</span> <span class="o">=</span> <span class="n">pgnoNew</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">minI</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">k</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span> <span class="n">pgnoNew</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">minV</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">minI</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">minV</span> <span class="o">=</span> <span class="n">pgnoNew</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">minI</span><span class="o">&gt;</span><span class="n">i</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">MemPage</span> <span class="o">*</span><span class="n">pT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">t</span> <span class="o">=</span> <span class="n">pgnoNew</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="n">pT</span> <span class="o">=</span> <span class="n">apNew</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="n">pgnoNew</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pgnoNew</span><span class="p">[</span><span class="n">minI</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="n">apNew</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">apNew</span><span class="p">[</span><span class="n">minI</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="n">pgnoNew</span><span class="p">[</span><span class="n">minI</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">apNew</span><span class="p">[</span><span class="n">minI</span><span class="p">]</span> <span class="o">=</span> <span class="n">pT</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">  ** Evenly distribute the data in apCell[] across the new pages.
</span></span></span><span class="line"><span class="cl"><span class="cm">  ** Insert divider cells into pParent as necessary.
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nNew</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">MemPage</span> <span class="o">*</span><span class="n">pNew</span> <span class="o">=</span> <span class="n">apNew</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">cntNew</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">assert</span><span class="p">(</span> <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">nFree</span><span class="o">&gt;=</span><span class="n">szCell</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 插入到页中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">insertCell</span><span class="p">(</span><span class="n">pNew</span><span class="p">,</span> <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">nCell</span><span class="p">,</span> <span class="n">apCell</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">szCell</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">      <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span> <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">nCell</span><span class="o">&gt;</span><span class="mi">0</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span> <span class="o">!</span><span class="n">pNew</span><span class="o">-&gt;</span><span class="n">isOverfull</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 维护Cell的next指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">relinkCellList</span><span class="p">(</span><span class="n">pNew</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nNew</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nCell</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 按照B树的性质，右兄弟节点的子结点也大于自己，所以这里是设置rightChild
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">apCell</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">leftChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 设置parent的分割Cell的leftChild为pgnoNew[i]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">apCell</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">pgnoNew</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 分割的Cell插入parent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">insertCell</span><span class="p">(</span><span class="n">pParent</span><span class="p">,</span> <span class="n">nxDiv</span><span class="p">,</span> <span class="n">apCell</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">szCell</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">      <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">nxDiv</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">j</span><span class="o">==</span><span class="n">nCell</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">apNew</span><span class="p">[</span><span class="n">nNew</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">apOld</span><span class="p">[</span><span class="n">nOld</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">rightChild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">nxDiv</span><span class="o">==</span><span class="n">pParent</span><span class="o">-&gt;</span><span class="n">nCell</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">pParent</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">rightChild</span> <span class="o">=</span> <span class="n">pgnoNew</span><span class="p">[</span><span class="n">nNew</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">pParent</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">nxDiv</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">pgnoNew</span><span class="p">[</span><span class="n">nNew</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>6 最后做一些维护工作。由于balance可能修改parent，所以对parent调用balance。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">  ** Reparent children of all cells.
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nNew</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">reparentChildPages</span><span class="p">(</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">,</span> <span class="n">apNew</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">reparentChildPages</span><span class="p">(</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">,</span> <span class="n">pParent</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">  ** balance the parent page.
</span></span></span><span class="line"><span class="cl"><span class="cm">  */</span>
</span></span><span class="line"><span class="cl">  <span class="n">rc</span> <span class="o">=</span> <span class="n">balance</span><span class="p">(</span><span class="n">pBt</span><span class="p">,</span> <span class="n">pParent</span><span class="p">,</span> <span class="n">pCur</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="事务操作">事务操作</h3>
<p>多个读事务可以同时执行。</p>
<p>写事务执行时，其他读写事务都不能执行。</p>
<p>事务实现基本就是调用下Pager的事务操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sqliteBtreeBeginTrans</span><span class="p">(</span><span class="n">Btree</span> <span class="o">*</span><span class="n">pBt</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">inTrans</span> <span class="p">)</span> <span class="k">return</span> <span class="n">SQLITE_ERROR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">page1</span><span class="o">==</span><span class="mi">0</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 加载页面，如果数据库不为空，校验magic number
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">lockBtree</span><span class="p">(</span><span class="n">pBt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">!=</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">readOnly</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">rc</span> <span class="o">=</span> <span class="n">sqlitepager_begin</span><span class="p">(</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">page1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">==</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">rc</span> <span class="o">=</span> <span class="n">newDatabase</span><span class="p">(</span><span class="n">pBt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">rc</span><span class="o">==</span><span class="n">SQLITE_OK</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">inTrans</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">inCkpt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">unlockBtreeIfUnused</span><span class="p">(</span><span class="n">pBt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sqliteBtreeRollback</span><span class="p">(</span><span class="n">Btree</span> <span class="o">*</span><span class="n">pBt</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">BtCursor</span> <span class="o">*</span><span class="n">pCur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">inTrans</span><span class="o">==</span><span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">SQLITE_OK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">inTrans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">inCkpt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">pCur</span><span class="o">=</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pCursor</span><span class="p">;</span> <span class="n">pCur</span><span class="p">;</span> <span class="n">pCur</span><span class="o">=</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span> <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">sqlitepager_unref</span><span class="p">(</span><span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">pCur</span><span class="o">-&gt;</span><span class="n">pPage</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">rc</span> <span class="o">=</span> <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">readOnly</span> <span class="o">?</span> <span class="nl">SQLITE_OK</span> <span class="p">:</span> <span class="n">sqlitepager_rollback</span><span class="p">(</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">unlockBtreeIfUnused</span><span class="p">(</span><span class="n">pBt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sqliteBtreeCommit</span><span class="p">(</span><span class="n">Btree</span> <span class="o">*</span><span class="n">pBt</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span> <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">inTrans</span><span class="o">==</span><span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="n">SQLITE_ERROR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">rc</span> <span class="o">=</span> <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">readOnly</span> <span class="o">?</span> <span class="nl">SQLITE_OK</span> <span class="p">:</span> <span class="n">sqlitepager_commit</span><span class="p">(</span><span class="n">pBt</span><span class="o">-&gt;</span><span class="n">pPager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">inTrans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pBt</span><span class="o">-&gt;</span><span class="n">inCkpt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">unlockBtreeIfUnused</span><span class="p">(</span><span class="n">pBt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="对比boltdb">对比BoltDB</h2>
<ol>
<li>sqlite自己做page buffer管理，需要处理page淘汰、脏页写盘，而BoltDB使用系统mmap来管理内存，很多管理逻辑都委托给OS，实现相对简单。</li>
<li>这个版本的sqlite只有B树实现，而BoltDB使用B+树实现。</li>
<li>sqlite的rebalance实现更加复杂，BoltDB相对简单。</li>
</ol>
<h2 id="代码技巧">代码技巧</h2>
<p>sqlite实现中的一些代码技巧值得学习</p>
<ol>
<li>
<p>将地址当作数组访问，然后方便的定位到该结构体前后的内存。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define PGHDR_TO_DATA(P)  ((void*)(&amp;(P)[1]))
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>通过指针来简化一些处理，类似于<a href="https://coolshell.cn/articles/8990.html">Linus：利用二级指针删除单向链表 | 酷 壳 - CoolShell</a>的技巧。</p>
<p>比如下面的代码中，如果不用指针，firstCell和iNext需要分别去设置，但通过指针把它们的设置逻辑统一了起来。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">relinkCellList</span><span class="p">(</span><span class="n">MemPage</span> <span class="o">*</span><span class="n">pPage</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">u16</span> <span class="o">*</span><span class="n">pIdx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span> <span class="n">sqlitepager_iswriteable</span><span class="p">(</span><span class="n">pPage</span><span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">pIdx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr</span><span class="p">.</span><span class="n">firstCell</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">nCell</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">Addr</span><span class="p">(</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">Addr</span><span class="p">(</span><span class="n">pPage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span> <span class="n">idx</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">idx</span><span class="o">&lt;</span><span class="n">SQLITE_PAGE_SIZE</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">pIdx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">pIdx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pPage</span><span class="o">-&gt;</span><span class="n">apCell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">.</span><span class="n">iNext</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">pIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>BoltDB源码笔记</title>
      <link>https://egolearner.github.io/post/boltdb-source-read/</link>
      <pubDate>Thu, 01 Dec 2022 19:43:42 +0800</pubDate>
      
      <guid>https://egolearner.github.io/post/boltdb-source-read/</guid>
      <description>&lt;p&gt;BoltDB 受LMDB启发，是基于append only B+ tree实现的KV存储。&lt;/p&gt;
&lt;h2 id=&#34;page实现&#34;&gt;page实现&lt;/h2&gt;
&lt;p&gt;boltdb没有实现自己的page buffer管理器，而是直接用mmap来从磁盘读取page。page的大小和OS的内存页大小相同。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>BoltDB 受LMDB启发，是基于append only B+ tree实现的KV存储。</p>
<h2 id="page实现">page实现</h2>
<p>boltdb没有实现自己的page buffer管理器，而是直接用mmap来从磁盘读取page。page的大小和OS的内存页大小相同。</p>
<p>page header结构如下，从ptr开始为page页的存储内容。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">pgid</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">page</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">id</span>       <span class="nx">pgid</span>    <span class="c1">// page id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">flags</span>    <span class="kt">uint16</span>  <span class="c1">// page 类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">count</span>    <span class="kt">uint16</span>  <span class="c1">// 元素的个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">overflow</span> <span class="kt">uint32</span>  <span class="c1">// 是否有overflow页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ptr</span>      <span class="kt">uintptr</span> <span class="c1">// ptr开始为数据存储。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>page.flags</code> 取值如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">branchPageFlag</span>   <span class="p">=</span> <span class="mh">0x01</span>  <span class="c1">// 内部页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">leafPageFlag</span>     <span class="p">=</span> <span class="mh">0x02</span>  <span class="c1">// leaf 页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">metaPageFlag</span>     <span class="p">=</span> <span class="mh">0x04</span>  <span class="c1">// meta 页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">freelistPageFlag</span> <span class="p">=</span> <span class="mh">0x10</span>  <span class="c1">// 空闲page列表页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过boltdb学到了如何用go写底层代码，如将一个 <code>byte[]</code> 作为page访问是这样的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// pageInBuffer retrieves a page reference from a given byte array based on the current page size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">pageInBuffer</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">id</span> <span class="nx">pgid</span><span class="p">)</span> <span class="o">*</span><span class="nx">page</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">page</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">[</span><span class="nx">id</span><span class="o">*</span><span class="nf">pgid</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">pageSize</span><span class="p">)]))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="meta页">meta页</h3>
<p>boltdb数据库的前两个页为meta页，存储元数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">meta</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">magic</span>    <span class="kt">uint32</span>  <span class="c1">// 0xED0CDAED, 用于文件校验
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">version</span>  <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pageSize</span> <span class="kt">uint32</span>  <span class="c1">// 页大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">flags</span>    <span class="kt">uint32</span>  <span class="c1">// 貌似未使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">root</span>     <span class="nx">bucket</span>  <span class="c1">// root bucket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">freelist</span> <span class="nx">pgid</span>    <span class="c1">// 空闲page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">pgid</span>     <span class="nx">pgid</span>    <span class="c1">// 数据库文件的最大page id，超过需要重新mmap或者说明有错误。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">txid</span>     <span class="nx">txid</span>    <span class="c1">// 用来分配写事务的id。id更大的meta页是最新的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">checksum</span> <span class="kt">uint64</span>  <span class="c1">// 文件损坏校验
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>meta</code> 存储在 <code>page</code> 结构的 <code>page.ptr</code> 位置，所以从page访问meta是这样的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// meta returns a pointer to the metadata section of the page.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">page</span><span class="p">)</span> <span class="nf">meta</span><span class="p">()</span> <span class="o">*</span><span class="nx">meta</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">meta</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">ptr</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>boltdb的两个meta页随着写入的进行会来回切换，最新的meta页包含当前的最新状态。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// meta retrieves the current meta page reference.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">meta</span><span class="p">()</span> <span class="o">*</span><span class="nx">meta</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// We have to return the meta with the highest txid which doesn&#39;t fail
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// validation. Otherwise, we can cause errors when in fact the database is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// in a consistent state. metaA is the one with the higher txid.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">metaA</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">meta0</span>
</span></span><span class="line"><span class="cl">	<span class="nx">metaB</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">meta1</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nx">meta1</span><span class="p">.</span><span class="nx">txid</span> <span class="p">&gt;</span> <span class="nx">db</span><span class="p">.</span><span class="nx">meta0</span><span class="p">.</span><span class="nx">txid</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">metaA</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">meta1</span>
</span></span><span class="line"><span class="cl">		<span class="nx">metaB</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">meta0</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Use higher meta page if valid. Otherwise fallback to previous, if valid.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">metaA</span><span class="p">.</span><span class="nf">validate</span><span class="p">();</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">metaA</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">metaB</span><span class="p">.</span><span class="nf">validate</span><span class="p">();</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">metaB</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// This should never be reached, because both meta1 and meta0 were validated
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// on mmap() and we do fsync() on every write.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;bolt.DB.meta(): invalid meta pages&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="branch页">branch页</h3>
<p>branch页存储B+树的内部节点数据，由<code>branchPageElement</code> 数组和key数据构成。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// branchPageElement represents a node on a branch page.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">branchPageElement</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pos</span>   <span class="kt">uint32</span>  <span class="c1">// key 存储位置相对branchPageElement存储位置的偏移量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ksize</span> <span class="kt">uint32</span>  <span class="c1">// key size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">pgid</span>  <span class="nx">pgid</span>    <span class="c1">// page id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>branchPageElement数组同样存储在<code>page</code> 结构的 <code>page.ptr</code> 位置</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// branchPageElement retrieves the branch node by index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">page</span><span class="p">)</span> <span class="nf">branchPageElement</span><span class="p">(</span><span class="nx">index</span> <span class="kt">uint16</span><span class="p">)</span> <span class="o">*</span><span class="nx">branchPageElement</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="p">((</span><span class="o">*</span><span class="p">[</span><span class="mh">0x7FFFFFF</span><span class="p">]</span><span class="nx">branchPageElement</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">ptr</span><span class="p">)))[</span><span class="nx">index</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// branchPageElements retrieves a list of branch nodes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">page</span><span class="p">)</span> <span class="nf">branchPageElements</span><span class="p">()</span> <span class="p">[]</span><span class="nx">branchPageElement</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">((</span><span class="o">*</span><span class="p">[</span><span class="mh">0x7FFFFFF</span><span class="p">]</span><span class="nx">branchPageElement</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">ptr</span><span class="p">)))[:]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>branchPageElement.pos</code> 存储的是key存储位置相对branchPageElement存储位置的偏移量，所以得到key的实现如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// key returns a byte slice of the node key.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">branchPageElement</span><span class="p">)</span> <span class="nf">key</span><span class="p">()</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">buf</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nx">maxAllocSize</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// n的地址加上n.pos得到key的起始地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nx">maxAllocSize</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">[</span><span class="nx">n</span><span class="p">.</span><span class="nx">pos</span><span class="p">]))[:</span><span class="nx">n</span><span class="p">.</span><span class="nx">ksize</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="leaf页">leaf页</h3>
<p>leaf页存储B+树的页节点数据，布局和branch页类似，只不过多了value。leaf页由<code>leafPageElement</code> 数组和key, value数据构成。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// leafPageElement represents a node on a leaf page.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">leafPageElement</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">flags</span> <span class="kt">uint32</span>  <span class="c1">// 为1表示子bucket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">pos</span>   <span class="kt">uint32</span>  <span class="c1">// key, value存储位置的相对偏移量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ksize</span> <span class="kt">uint32</span>  <span class="c1">// key size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">vsize</span> <span class="kt">uint32</span>  <span class="c1">// value size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>从page根据下标访问</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// leafPageElement retrieves the leaf node by index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">page</span><span class="p">)</span> <span class="nf">leafPageElement</span><span class="p">(</span><span class="nx">index</span> <span class="kt">uint16</span><span class="p">)</span> <span class="o">*</span><span class="nx">leafPageElement</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">n</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="p">((</span><span class="o">*</span><span class="p">[</span><span class="mh">0x7FFFFFF</span><span class="p">]</span><span class="nx">leafPageElement</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">ptr</span><span class="p">)))[</span><span class="nx">index</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>访问key, value实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// key returns a byte slice of the node key.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">leafPageElement</span><span class="p">)</span> <span class="nf">key</span><span class="p">()</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">buf</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nx">maxAllocSize</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 最后的:n.ksize用来限制slice的compacity
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nx">maxAllocSize</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">[</span><span class="nx">n</span><span class="p">.</span><span class="nx">pos</span><span class="p">]))[:</span><span class="nx">n</span><span class="p">.</span><span class="nx">ksize</span><span class="p">:</span><span class="nx">n</span><span class="p">.</span><span class="nx">ksize</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// value returns a byte slice of the node value.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">leafPageElement</span><span class="p">)</span> <span class="nf">value</span><span class="p">()</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">buf</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nx">maxAllocSize</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nx">maxAllocSize</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">buf</span><span class="p">[</span><span class="nx">n</span><span class="p">.</span><span class="nx">pos</span><span class="o">+</span><span class="nx">n</span><span class="p">.</span><span class="nx">ksize</span><span class="p">]))[:</span><span class="nx">n</span><span class="p">.</span><span class="nx">vsize</span><span class="p">:</span><span class="nx">n</span><span class="p">.</span><span class="nx">vsize</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="freelist页">freelist页</h3>
<p>freelist页存储空闲的页表，用于重用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// freelist represents a list of all pages that are available for allocation.
</span></span></span><span class="line"><span class="cl"><span class="c1">// It also tracks pages that have been freed but are still in use by open transactions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">freelist</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ids</span>     <span class="p">[]</span><span class="nx">pgid</span>          <span class="c1">// all free and available free page ids.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 记录执行中的事务用到的页表，用于安全的重用页表。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">pending</span> <span class="kd">map</span><span class="p">[</span><span class="nx">txid</span><span class="p">][]</span><span class="nx">pgid</span> <span class="c1">// mapping of soon-to-be free page ids by tx.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 记录页是否空闲
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">cache</span>   <span class="kd">map</span><span class="p">[</span><span class="nx">pgid</span><span class="p">]</span><span class="kt">bool</span>   <span class="c1">// fast lookup of all free and pending page ids.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>磁盘上只需要存储 <code>freelist.ids</code> ，而pending和cache只在内存中维护。下面的加载函数，从磁盘上加载空闲页的id数组，然后通过reindex来重建cache字段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// read initializes the freelist from a freelist page.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">freelist</span><span class="p">)</span> <span class="nf">read</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">page</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// If the page.count is at the max uint16 value (64k) then it&#39;s considered
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// an overflow and the size of the freelist is stored as the first element.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">idx</span><span class="p">,</span> <span class="nx">count</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">count</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">count</span> <span class="o">==</span> <span class="mh">0xFFFF</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">idx</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="nx">count</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(((</span><span class="o">*</span><span class="p">[</span><span class="nx">maxAllocSize</span><span class="p">]</span><span class="nx">pgid</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">ptr</span><span class="p">)))[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Copy the list of page ids from the freelist.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">f</span><span class="p">.</span><span class="nx">ids</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ids</span> <span class="o">:=</span> <span class="p">((</span><span class="o">*</span><span class="p">[</span><span class="nx">maxAllocSize</span><span class="p">]</span><span class="nx">pgid</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">ptr</span><span class="p">)))[</span><span class="nx">idx</span><span class="p">:</span><span class="nx">count</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="nx">f</span><span class="p">.</span><span class="nx">ids</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">pgid</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ids</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nb">copy</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">ids</span><span class="p">,</span> <span class="nx">ids</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Make sure they&#39;re sorted.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">sort</span><span class="p">.</span><span class="nf">Sort</span><span class="p">(</span><span class="nf">pgids</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">ids</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Rebuild the page cache.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">f</span><span class="p">.</span><span class="nf">reindex</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在allocate函数中，会检查是否存在n个连续的页，如果存在的返回起始页的page id，否则返回0.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// allocate returns the starting page id of a contiguous list of pages of a given size.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If a contiguous block cannot be found then 0 is returned.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">freelist</span><span class="p">)</span> <span class="nf">allocate</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">pgid</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">initial</span><span class="p">,</span> <span class="nx">previd</span> <span class="nx">pgid</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">id</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">f</span><span class="p">.</span><span class="nx">ids</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">id</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;invalid page allocation: %d&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Reset initial page if this is not contiguous.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">previd</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">id</span><span class="o">-</span><span class="nx">previd</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">initial</span> <span class="p">=</span> <span class="nx">id</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// If we found a contiguous block then remove it and return it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="nx">id</span><span class="o">-</span><span class="nx">initial</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="nf">pgid</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// If we&#39;re allocating off the beginning then take the fast path
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// and just adjust the existing slice. This will use extra memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// temporarily but the append() in free() will realloc the slice
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// as is necessary.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nx">n</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">f</span><span class="p">.</span><span class="nx">ids</span> <span class="p">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">ids</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nb">copy</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">ids</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="nx">f</span><span class="p">.</span><span class="nx">ids</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
</span></span><span class="line"><span class="cl">				<span class="nx">f</span><span class="p">.</span><span class="nx">ids</span> <span class="p">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">ids</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">ids</span><span class="p">)</span><span class="o">-</span><span class="nx">n</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="c1">// Remove from the free cache.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nf">pgid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nf">pgid</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nb">delete</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">cache</span><span class="p">,</span> <span class="nx">initial</span><span class="o">+</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">initial</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">previd</span> <span class="p">=</span> <span class="nx">id</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="node结构">node结构</h3>
<p>page结构体和磁盘上存储的结构直接对应，使用时并不方便，比如上面介绍的 <code>page.meta()</code> 函数就是为了方便访问元数据字段的。boltdb中最多的还是branch页和leaf页，因此专门定义了node来表示加载到内存中的page，便于访问branch页和leaf页的数据。写事务执行的插入和删除也是先更新到内存中的node中，在事务提交时才刷新到磁盘。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// inode represents an internal node inside of a node.
</span></span></span><span class="line"><span class="cl"><span class="c1">// It can be used to point to elements in a page or point
</span></span></span><span class="line"><span class="cl"><span class="c1">// to an element which hasn&#39;t been added to a page yet.
</span></span></span><span class="line"><span class="cl"><span class="c1">// inode 统一表示中间节点和叶节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">inode</span> <span class="kd">struct</span> 
</span></span><span class="line"><span class="cl">	<span class="nx">flags</span> <span class="kt">uint32</span>  <span class="c1">// 对应leafPageElement.flags
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">pgid</span>  <span class="nx">pgid</span>
</span></span><span class="line"><span class="cl">	<span class="nx">key</span>   <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">	<span class="nx">value</span> <span class="p">[]</span><span class="kt">byte</span>  <span class="c1">// 中间节点的value为nil
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">inodes</span> <span class="p">[]</span><span class="nx">inode</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// node represents an in-memory, deserialized page.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">node</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bucket</span>     <span class="o">*</span><span class="nx">Bucket</span>
</span></span><span class="line"><span class="cl">	<span class="nx">isLeaf</span>     <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">	<span class="nx">unbalanced</span> <span class="kt">bool</span>  <span class="c1">// 有删除时会设置为true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">spilled</span>    <span class="kt">bool</span>  <span class="c1">// 是否已经分裂和分配脏页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">key</span>        <span class="p">[]</span><span class="kt">byte</span>  <span class="c1">// 第0个key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">pgid</span>       <span class="nx">pgid</span>
</span></span><span class="line"><span class="cl">	<span class="nx">parent</span>     <span class="o">*</span><span class="nx">node</span>
</span></span><span class="line"><span class="cl">	<span class="nx">children</span>   <span class="nx">nodes</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 叶子节点的key/value数组，中间节点的key数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">inodes</span> <span class="nx">inodes</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">nodes</span> <span class="p">[]</span><span class="o">*</span><span class="nx">node</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>node和page的相互转换逻辑如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// read initializes the node from a page.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">read</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">page</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">n</span><span class="p">.</span><span class="nx">pgid</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">id</span>
</span></span><span class="line"><span class="cl">	<span class="nx">n</span><span class="p">.</span><span class="nx">isLeaf</span> <span class="p">=</span> <span class="p">((</span><span class="nx">p</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">leafPageFlag</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">inodes</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">count</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">count</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">inode</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">isLeaf</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">elem</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">leafPageElement</span><span class="p">(</span><span class="nb">uint16</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="nx">inode</span><span class="p">.</span><span class="nx">flags</span> <span class="p">=</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">flags</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 从page读到key/value，写入inode结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">inode</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="nx">elem</span><span class="p">.</span><span class="nf">key</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">inode</span><span class="p">.</span><span class="nx">value</span> <span class="p">=</span> <span class="nx">elem</span><span class="p">.</span><span class="nf">value</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">elem</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">branchPageElement</span><span class="p">(</span><span class="nb">uint16</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="nx">inode</span><span class="p">.</span><span class="nx">pgid</span> <span class="p">=</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">pgid</span>
</span></span><span class="line"><span class="cl">			<span class="nx">inode</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="nx">elem</span><span class="p">.</span><span class="nf">key</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nf">_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">inode</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;read: zero-length inode key&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Save first key so we can find the node in the parent when we spill.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">key</span>
</span></span><span class="line"><span class="cl">		<span class="nf">_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;read: zero-length node key&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// write writes the items onto one or more pages.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">write</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">page</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Initialize page.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">isLeaf</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">p</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">leafPageFlag</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">p</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">branchPageFlag</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mh">0xFFFF</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;inode overflow: %d (pgid=%d)&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">),</span> <span class="nx">p</span><span class="p">.</span><span class="nx">id</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p</span><span class="p">.</span><span class="nx">count</span> <span class="p">=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Stop here if there are no items to write.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Loop over each item and write it to the page.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// b指向key/value或key的起始位置。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nx">maxAllocSize</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">ptr</span><span class="p">))[</span><span class="nx">n</span><span class="p">.</span><span class="nf">pageElementSize</span><span class="p">()</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">):]</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;write: zero-length inode key&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Write the page element.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">isLeaf</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">elem</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">leafPageElement</span><span class="p">(</span><span class="nb">uint16</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// pos为b与elem的地址差
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">elem</span><span class="p">.</span><span class="nx">pos</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">-</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">elem</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">			<span class="nx">elem</span><span class="p">.</span><span class="nx">flags</span> <span class="p">=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">flags</span>
</span></span><span class="line"><span class="cl">			<span class="nx">elem</span><span class="p">.</span><span class="nx">ksize</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">key</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="nx">elem</span><span class="p">.</span><span class="nx">vsize</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">value</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">elem</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">branchPageElement</span><span class="p">(</span><span class="nb">uint16</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="nx">elem</span><span class="p">.</span><span class="nx">pos</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">-</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">elem</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">			<span class="nx">elem</span><span class="p">.</span><span class="nx">ksize</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">key</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="nx">elem</span><span class="p">.</span><span class="nx">pgid</span> <span class="p">=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">pgid</span>
</span></span><span class="line"><span class="cl">			<span class="nf">_assert</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">pgid</span> <span class="o">!=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="s">&#34;write: circular dependency occurred&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// If the length of key+value is larger than the max allocation size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// then we need to reallocate the byte array pointer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// See: https://github.com/boltdb/bolt/pull/335
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">klen</span><span class="p">,</span> <span class="nx">vlen</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">key</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">klen</span><span class="o">+</span><span class="nx">vlen</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">b</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nx">maxAllocSize</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]))[:]</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Write data for the element to the end of the page.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 复制key和value，然后更新b到下一个key/value或key的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nb">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">:],</span> <span class="nx">item</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">[</span><span class="nx">klen</span><span class="p">:]</span>
</span></span><span class="line"><span class="cl">		<span class="nb">copy</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">:],</span> <span class="nx">item</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">[</span><span class="nx">vlen</span><span class="p">:]</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// DEBUG ONLY: n.dump()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在插入删除KV时会先修改在内存中node结构，此时B+树可能是不平衡的，在事务提交时会进行rebalance和写盘。在删除key时，将二分找到的下标位置的元素删除，只会修改内存，在事务提交时才会实际刷新到磁盘。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// del removes a key from the node.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">del</span><span class="p">(</span><span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Find index of key.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">index</span> <span class="o">:=</span> <span class="nx">sort</span><span class="p">.</span><span class="nf">Search</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">),</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">Compare</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">key</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Exit if the key isn&#39;t found.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">)</span> <span class="o">||</span> <span class="p">!</span><span class="nx">bytes</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">[</span><span class="nx">index</span><span class="p">].</span><span class="nx">key</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Delete inode from the node.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 从inodes中删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">[:</span><span class="nx">index</span><span class="p">],</span> <span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">[</span><span class="nx">index</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Mark the node as needing rebalancing.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">n</span><span class="p">.</span><span class="nx">unbalanced</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>插入key的实现类似，同样只会修改内存。</p>
<h2 id="bucket实现">Bucket实现</h2>
<p>boltdb中的Bucket相当于mysql的表，可以存储KV对。Bucket也支持嵌套。boltdb中有一个唯一的根Bucket，其他的Bucket都是它的子孙Bucket。在 <code>meta.root</code> 中存储根Bucket的root页id。在事务初始化时会用来设置事务的root.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// init initializes the transaction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nf">init</span><span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span> <span class="p">=</span> <span class="nx">db</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tx</span><span class="p">.</span><span class="nx">pages</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Copy the meta page since it can be changed by the writer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">meta</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">db</span><span class="p">.</span><span class="nf">meta</span><span class="p">().</span><span class="nb">copy</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Copy over the root bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nx">root</span> <span class="p">=</span> <span class="nf">newBucket</span><span class="p">(</span><span class="nx">tx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tx</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">bucket</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置root
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="o">*</span><span class="nx">tx</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">root</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Increment the transaction id and add a page cache for writable transactions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">writable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">tx</span><span class="p">.</span><span class="nx">pages</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">pgid</span><span class="p">]</span><span class="o">*</span><span class="nx">page</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">txid</span> <span class="o">+=</span> <span class="nf">txid</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>每个子Bucket都存储在父Bucket的leaf页中，此时<code>leafPageElement.flags</code> 会设置为<code>bucketLeafFlag</code> 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bucketLeafFlag</span> <span class="p">=</span> <span class="mh">0x01</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>磁盘上的bucket结构如下，主要字段为root页的page id。Bucket没有嵌套的Bucket且空间比较小时，不会分配一个完整的page来存储，而是直接存储到父Bucket的leaf页中，此时 <code>bucket.root</code> 为0.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// bucket represents the on-file representation of a bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1">// This is stored as the &#34;value&#34; of a bucket key. If the bucket is small enough,
</span></span></span><span class="line"><span class="cl"><span class="c1">// then its root page can be stored inline in the &#34;value&#34;, after the bucket
</span></span></span><span class="line"><span class="cl"><span class="c1">// header. In the case of inline buckets, the &#34;root&#34; will be 0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">bucket</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">root</span>     <span class="nx">pgid</span>   <span class="c1">// page id of the bucket&#39;s root-level page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sequence</span> <span class="kt">uint64</span> <span class="c1">// monotonically incrementing, used by NextSequence()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>内存中的Bucket结构如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Bucket represents a collection of key/value pairs inside the database.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Bucket</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">bucket</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tx</span>       <span class="o">*</span><span class="nx">Tx</span>                <span class="c1">// the associated transaction
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">buckets</span>  <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">Bucket</span> <span class="c1">// subbucket cache
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">page</span>     <span class="o">*</span><span class="nx">page</span>              <span class="c1">// inline page reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">rootNode</span> <span class="o">*</span><span class="nx">node</span>              <span class="c1">// materialized node for the root page.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">nodes</span>    <span class="kd">map</span><span class="p">[</span><span class="nx">pgid</span><span class="p">]</span><span class="o">*</span><span class="nx">node</span>     <span class="c1">// node cache
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Sets the threshold for filling nodes when they split. By default,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// the bucket will fill to 50% but it can be useful to increase this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// amount if you know that your write workloads are mostly append-only.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// This is non-persisted across transactions so it must be set in every Tx.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">FillPercent</span> <span class="kt">float64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建Bucket</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// CreateBucket creates a new bucket at the given key and returns the new bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Returns an error if the key already exists, if the bucket name is blank, or if the bucket name is too long.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The bucket instance is only valid for the lifetime of the transaction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Bucket</span><span class="p">)</span> <span class="nf">CreateBucket</span><span class="p">(</span><span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Bucket</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrTxClosed</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">!</span><span class="nx">b</span><span class="p">.</span><span class="nx">tx</span><span class="p">.</span><span class="nx">writable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrTxNotWritable</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrBucketNameRequired</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Move cursor to correct position.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Cursor</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">k</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">flags</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">seek</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Return an error if there is an existing key.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// key已存在时报错，根据是否是bucket返回不同的错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">bucketLeafFlag</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrBucketExists</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrIncompatibleValue</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Create empty, inline bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">bucket</span> <span class="p">=</span> <span class="nx">Bucket</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">bucket</span><span class="p">:</span>      <span class="o">&amp;</span><span class="nx">bucket</span><span class="p">{},</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rootNode</span><span class="p">:</span>    <span class="o">&amp;</span><span class="nx">node</span><span class="p">{</span><span class="nx">isLeaf</span><span class="p">:</span> <span class="kc">true</span><span class="p">},</span>
</span></span><span class="line"><span class="cl">		<span class="nx">FillPercent</span><span class="p">:</span> <span class="nx">DefaultFillPercent</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">value</span> <span class="p">=</span> <span class="nx">bucket</span><span class="p">.</span><span class="nf">write</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Insert into node.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">key</span> <span class="p">=</span> <span class="nf">cloneBytes</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 写入到node中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nf">node</span><span class="p">().</span><span class="nf">put</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">bucketLeafFlag</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Since subbuckets are not allowed on inline buckets, we need to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// dereference the inline page, if it exists. This will cause the bucket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// to be treated as a regular, non-inline bucket for the rest of the tx.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">b</span><span class="p">.</span><span class="nx">page</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 打开Bucket以返回Bucket对象。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Bucket</span><span class="p">(</span><span class="nx">key</span><span class="p">),</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建Bucket的key和普通的KV在同一namespace中，不允许和普通的key重复。在实现中，将创建的Bucket转为byte[]然后写入到所在node中，然后再调用 <code>b.Bucket(key)</code>  返回Bucket对象。</p>
<p>打开Bucket的逻辑如下</p>
<ol>
<li>检查是否存在key，以及是否为Bucket</li>
<li>调用openBucket，反序列化为Bucket结构体。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Bucket retrieves a nested bucket by name.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Returns nil if the bucket does not exist.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The bucket instance is only valid for the lifetime of the transaction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Bucket</span><span class="p">)</span> <span class="nf">Bucket</span><span class="p">(</span><span class="nx">name</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="o">*</span><span class="nx">Bucket</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buckets</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 如果在缓存中，直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">child</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buckets</span><span class="p">[</span><span class="nb">string</span><span class="p">(</span><span class="nx">name</span><span class="p">)];</span> <span class="nx">child</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">child</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Move cursor to key.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Cursor</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">flags</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">seek</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Return nil if the key doesn&#39;t exist or it is not a bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">bytes</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">bucketLeafFlag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Otherwise create a bucket and cache it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">child</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">openBucket</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buckets</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 设置到缓存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">b</span><span class="p">.</span><span class="nx">buckets</span><span class="p">[</span><span class="nb">string</span><span class="p">(</span><span class="nx">name</span><span class="p">)]</span> <span class="p">=</span> <span class="nx">child</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">child</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Helper method that re-interprets a sub-bucket value
</span></span></span><span class="line"><span class="cl"><span class="c1">// from a parent into a Bucket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Bucket</span><span class="p">)</span> <span class="nf">openBucket</span><span class="p">(</span><span class="nx">value</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="o">*</span><span class="nx">Bucket</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">child</span> <span class="p">=</span> <span class="nf">newBucket</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// If unaligned load/stores are broken on this arch and value is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// unaligned simply clone to an aligned byte array.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">unaligned</span> <span class="o">:=</span> <span class="nx">brokenUnaligned</span> <span class="o">&amp;&amp;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">&amp;</span><span class="mi">3</span> <span class="o">!=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">unaligned</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">value</span> <span class="p">=</span> <span class="nf">cloneBytes</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// If this is a writable transaction then we need to copy the bucket entry.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Read-only transactions can point directly at the mmap entry.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tx</span><span class="p">.</span><span class="nx">writable</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">unaligned</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 写事务或者未对齐时，会分配新的内存并拷贝，否则直接指向mmap的内存。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">child</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">bucket</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">		<span class="o">*</span><span class="nx">child</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">bucket</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">child</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bucket</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Save a reference to the inline page if the bucket is inline.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 处理inline page。刚创建的Bucket必然为inline page。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">child</span><span class="p">.</span><span class="nx">root</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">child</span><span class="p">.</span><span class="nx">page</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">page</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">value</span><span class="p">[</span><span class="nx">bucketHeaderSize</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">child</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="b树操作及维护">B+树操作及维护</h2>
<h3 id="cursor实现">Cursor实现</h3>
<p>在boltdb访问数据时，使用Cursor来查找数据或者实现遍历功能。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// elemRef represents a reference to an element on a given page/node.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">elemRef</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">page</span>  <span class="o">*</span><span class="nx">page</span>  <span class="c1">// 页面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">node</span>  <span class="o">*</span><span class="nx">node</span>  <span class="c1">// 打开的页面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">index</span> <span class="kt">int</span>    <span class="c1">// 当前访问到的成员下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Cursor represents an iterator that can traverse over all key/value pairs in a bucket in sorted order.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Cursors see nested buckets with value == nil.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Cursor</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bucket</span> <span class="o">*</span><span class="nx">Bucket</span>    <span class="c1">// 指向的Bucket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">stack</span>  <span class="p">[]</span><span class="nx">elemRef</span>  <span class="c1">// 访问栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Put 实现如下，基本逻辑为利用B+树的性质不断二分查找，直到到达leaf页，然后插入。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Put sets the value for a key in the bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If the key exist then its previous value will be overwritten.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Supplied value must remain valid for the life of the transaction.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Returns an error if the bucket was created from a read-only transaction, if the key is blank, if the key is too large, or if the value is too large.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Bucket</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">value</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">ErrTxClosed</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">!</span><span class="nx">b</span><span class="p">.</span><span class="nf">Writable</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">ErrTxNotWritable</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">ErrKeyRequired</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">MaxKeySize</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">ErrKeyTooLarge</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="p">&gt;</span> <span class="nx">MaxValueSize</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">ErrValueTooLarge</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Move cursor to correct position.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Cursor</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 定位到指定的key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">k</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">flags</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">seek</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Return an error if there is an existing key with a bucket value.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 如果key位置存在Bucket，则报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">bucketLeafFlag</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">ErrIncompatibleValue</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Insert into node.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 之所以拷贝key不拷贝value，是因为value要求在事务结束前保持有效，而key没有这样的要求。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">key</span> <span class="p">=</span> <span class="nf">cloneBytes</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 更新或者插入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nf">node</span><span class="p">().</span><span class="nf">put</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>将Cursor定位到指定的key的实现如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// seek moves the cursor to a given key and returns it.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If the key does not exist then the next key is used.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cursor</span><span class="p">)</span> <span class="nf">seek</span><span class="p">(</span><span class="nx">seek</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">value</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">flags</span> <span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">_assert</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">,</span> <span class="s">&#34;tx closed&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Start from root page/node and traverse to correct page.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 清空栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">stack</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="nx">seek</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">root</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ref</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// If the cursor is pointing to the end of page/node then return nil.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">ref</span><span class="p">.</span><span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">ref</span><span class="p">.</span><span class="nf">count</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// If this is a bucket then return a nil value.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">keyValue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// search recursively performs a binary search against a given page/node until it finds a given key.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cursor</span><span class="p">)</span> <span class="nf">search</span><span class="p">(</span><span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">pgid</span> <span class="nx">pgid</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 打开page，可能返回page或者node结构，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 因此后面分别有从page或者从node检索的逻辑。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 这里有个疑问是为什么没有统一为node，看node.read(p *page) 开销也不大。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 我理解是Bucket.node()实现会将其记录到Bucket.nodes中，用于B+树的平衡操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 对于读的场景，不需要做这些操作，因此没有统一逻辑。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">p</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nf">pageNode</span><span class="p">(</span><span class="nx">pgid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">branchPageFlag</span><span class="p">|</span><span class="nx">leafPageFlag</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;invalid page type: %d: %x&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">flags</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">elemRef</span><span class="p">{</span><span class="nx">page</span><span class="p">:</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">node</span><span class="p">:</span> <span class="nx">n</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 加入到栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// If we&#39;re on a leaf page/node then find the specific node.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nf">isLeaf</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nf">nsearch</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">n</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nf">searchNode</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">searchPage</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// nsearch searches the leaf node on the top of the stack for a key.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cursor</span><span class="p">)</span> <span class="nf">nsearch</span><span class="p">(</span><span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">e</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">page</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">node</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// If we have a node then search its inodes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 二分查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">index</span> <span class="o">:=</span> <span class="nx">sort</span><span class="p">.</span><span class="nf">Search</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">),</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">Compare</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">key</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="p">})</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 设置index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">e</span><span class="p">.</span><span class="nx">index</span> <span class="p">=</span> <span class="nx">index</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// If we have a page then search its leaf elements.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">inodes</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">leafPageElements</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 使用page来二分查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">index</span> <span class="o">:=</span> <span class="nx">sort</span><span class="p">.</span><span class="nf">Search</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">count</span><span class="p">),</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">Compare</span><span class="p">(</span><span class="nx">inodes</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">key</span><span class="p">(),</span> <span class="nx">key</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 设置index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nx">index</span> <span class="p">=</span> <span class="nx">index</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Next实现如下，将Cursor移动到下一个key。boltdb的B+树中没有指针来指向相邻的叶子page，因此是通过栈回溯来找到相邻的叶子page的，主要还是为了避免无谓的page修改。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Next moves the cursor to the next item in the bucket and returns its key and value.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If the cursor is at the end of the bucket then a nil key and value are returned.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The returned key and value are only valid for the life of the transaction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cursor</span><span class="p">)</span> <span class="nf">Next</span><span class="p">()</span> <span class="p">(</span><span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">value</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">_assert</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">,</span> <span class="s">&#34;tx closed&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">k</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">flags</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">bucketLeafFlag</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">k</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// next moves to the next leaf element and returns the key and value.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If the cursor is at the last leaf element then it stays there and returns nil.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cursor</span><span class="p">)</span> <span class="nf">next</span><span class="p">()</span> <span class="p">(</span><span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">value</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">flags</span> <span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Attempt to move over one element until we&#39;re successful.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Move up the stack as we hit the end of each page in our stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="kd">var</span> <span class="nx">i</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">i</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">elem</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">stack</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">index</span> <span class="p">&lt;</span> <span class="nx">elem</span><span class="p">.</span><span class="nf">count</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 如果任何一层还没完全访问，则将其index+1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="nx">elem</span><span class="p">.</span><span class="nx">index</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// If we&#39;ve hit the root page then stop and return. This will leave the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// cursor on the last element of the last page.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 所有层都访问过了，即cursor在最后一个节点上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Otherwise start from where we left off in the stack and find the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// first element of the first leaf page.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">stack</span><span class="p">[:</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 移动到下面的第一个leaf节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">first</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// If this is an empty page then restart and move back up the stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// https://github.com/boltdb/bolt/issues/450
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">count</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">keyValue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// first moves the cursor to the first leaf element under the last page in the stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cursor</span><span class="p">)</span> <span class="nf">first</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Exit when we hit a leaf page.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="kd">var</span> <span class="nx">ref</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// leaf则break
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">ref</span><span class="p">.</span><span class="nf">isLeaf</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Keep adding pages pointing to the first element to the stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="kd">var</span> <span class="nx">pgid</span> <span class="nx">pgid</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">ref</span><span class="p">.</span><span class="nx">node</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">pgid</span> <span class="p">=</span> <span class="nx">ref</span><span class="p">.</span><span class="nx">node</span><span class="p">.</span><span class="nx">inodes</span><span class="p">[</span><span class="nx">ref</span><span class="p">.</span><span class="nx">index</span><span class="p">].</span><span class="nx">pgid</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">pgid</span> <span class="p">=</span> <span class="nx">ref</span><span class="p">.</span><span class="nx">page</span><span class="p">.</span><span class="nf">branchPageElement</span><span class="p">(</span><span class="nb">uint16</span><span class="p">(</span><span class="nx">ref</span><span class="p">.</span><span class="nx">index</span><span class="p">)).</span><span class="nx">pgid</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">p</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nf">pageNode</span><span class="p">(</span><span class="nx">pgid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 访问下一层节点，设置下一层节点的index为0，从第一个开始访问。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">elemRef</span><span class="p">{</span><span class="nx">page</span><span class="p">:</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">node</span><span class="p">:</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">index</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Cursor的其他函数不再赘述，基本都是B+树的标准操作。</p>
<h3 id="b树-rebalance">B+树 rebalance</h3>
<p>在插入或删除key时，都是通过cursor.node()操作的.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">c</span><span class="p">.</span><span class="nf">node</span><span class="p">().</span><span class="nf">del</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 插入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">c</span><span class="p">.</span><span class="nf">node</span><span class="p">().</span><span class="nf">put</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>根据B+树的性质，访问路径上的page都有可能被修改，因此cursor.node()会将这些page都解析为node，并缓存到Bucket.nodes中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cursor</span><span class="p">)</span> <span class="nf">node</span><span class="p">()</span> <span class="o">*</span><span class="nx">node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;accessing a node with a zero-length cursor stack&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// If the top of the stack is a leaf node then just return it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">ref</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="nx">ref</span><span class="p">.</span><span class="nx">node</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">ref</span><span class="p">.</span><span class="nf">isLeaf</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">ref</span><span class="p">.</span><span class="nx">node</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Start from root and traverse down the hierarchy.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">n</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">node</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nf">node</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">page</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ref</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">_assert</span><span class="p">(!</span><span class="nx">n</span><span class="p">.</span><span class="nx">isLeaf</span><span class="p">,</span> <span class="s">&#34;expected branch node&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nf">childAt</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">ref</span><span class="p">.</span><span class="nx">index</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">_assert</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">isLeaf</span><span class="p">,</span> <span class="s">&#34;expected leaf node&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// node creates a node from a page and associates it with a given parent.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Bucket</span><span class="p">)</span> <span class="nf">node</span><span class="p">(</span><span class="nx">pgid</span> <span class="nx">pgid</span><span class="p">,</span> <span class="nx">parent</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="o">*</span><span class="nx">node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">_assert</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">nodes</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">,</span> <span class="s">&#34;nodes map expected&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Retrieve node if it&#39;s already been created.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">nodes</span><span class="p">[</span><span class="nx">pgid</span><span class="p">];</span> <span class="nx">n</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Otherwise create a node and cache it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">n</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">node</span><span class="p">{</span><span class="nx">bucket</span><span class="p">:</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">parent</span><span class="p">:</span> <span class="nx">parent</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">parent</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">b</span><span class="p">.</span><span class="nx">rootNode</span> <span class="p">=</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">parent</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parent</span><span class="p">.</span><span class="nx">children</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Use the inline page if this is an inline bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">p</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">page</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">p</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tx</span><span class="p">.</span><span class="nf">page</span><span class="p">(</span><span class="nx">pgid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Read the page into the node and cache it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">n</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 纪录到缓存中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">b</span><span class="p">.</span><span class="nx">nodes</span><span class="p">[</span><span class="nx">pgid</span><span class="p">]</span> <span class="p">=</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Update statistics.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">b</span><span class="p">.</span><span class="nx">tx</span><span class="p">.</span><span class="nx">stats</span><span class="p">.</span><span class="nx">NodeCount</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>由上面的分析可见，在rebalance时只需要检查Bucket.nodes缓存中的node是否需要分裂或合并即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// rebalance attempts to balance all nodes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Bucket</span><span class="p">)</span> <span class="nf">rebalance</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">b</span><span class="p">.</span><span class="nx">nodes</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 依次调用node.rebalance()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">n</span><span class="p">.</span><span class="nf">rebalance</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">child</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 处理每个子Bucket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">child</span><span class="p">.</span><span class="nf">rebalance</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>node rebalance实现</p>
<p>rebalance中会将过小的page和兄弟page合并，并不是通常意义上说的B+树的再平衡。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// rebalance attempts to combine the node with sibling nodes if the node fill
</span></span></span><span class="line"><span class="cl"><span class="c1">// size is below a threshold or if there are not enough keys.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">rebalance</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 在delete key时会设置unbalanced为true，而insert并不会设置。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 因此经过node.rebalance()后，node有可能会超过page大小，是在另外的地方处理的。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">n</span><span class="p">.</span><span class="nx">unbalanced</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">n</span><span class="p">.</span><span class="nx">unbalanced</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Update statistics.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">n</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">tx</span><span class="p">.</span><span class="nx">stats</span><span class="p">.</span><span class="nx">Rebalance</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Ignore if node is above threshold (25%) and has enough keys.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">threshold</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">pageSize</span> <span class="o">/</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// node大小超过25%且有足够的key(leaf至少为1个，否则至少为2个）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">threshold</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">n</span><span class="p">.</span><span class="nf">minKeys</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Root node has special handling.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">parent</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// If root node is a branch and only has one node then collapse it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">n</span><span class="p">.</span><span class="nx">isLeaf</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// Move root&#39;s child up.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// 将child移动到root节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">child</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nf">node</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">pgid</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">n</span><span class="p">.</span><span class="nx">isLeaf</span> <span class="p">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">isLeaf</span>
</span></span><span class="line"><span class="cl">			<span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span> <span class="p">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">inodes</span><span class="p">[:]</span>
</span></span><span class="line"><span class="cl">			<span class="nx">n</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="nx">child</span><span class="p">.</span><span class="nx">children</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="c1">// Reparent all child nodes being moved.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">inode</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">child</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">nodes</span><span class="p">[</span><span class="nx">inode</span><span class="p">.</span><span class="nx">pgid</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">child</span><span class="p">.</span><span class="nx">parent</span> <span class="p">=</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="c1">// Remove old child.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">child</span><span class="p">.</span><span class="nx">parent</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">			<span class="nb">delete</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">nodes</span><span class="p">,</span> <span class="nx">child</span><span class="p">.</span><span class="nx">pgid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">child</span><span class="p">.</span><span class="nf">free</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// If node has no keys then just remove it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nf">numChildren</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nf">del</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nf">removeChild</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nb">delete</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">nodes</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">pgid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span><span class="p">.</span><span class="nf">free</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nf">rebalance</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">_assert</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nf">numChildren</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#34;parent must have at least 2 children&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Destination node is right sibling if idx == 0, otherwise left sibling.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">target</span> <span class="o">*</span><span class="nx">node</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">useNextSibling</span> <span class="p">=</span> <span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nf">childIndex</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">useNextSibling</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">target</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nf">nextSibling</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">target</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nf">prevSibling</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// If both this node and the target node are too small then merge them.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 直接合并，后面再做split
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">useNextSibling</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Reparent all child nodes being moved.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">inode</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">target</span><span class="p">.</span><span class="nx">inodes</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">child</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">nodes</span><span class="p">[</span><span class="nx">inode</span><span class="p">.</span><span class="nx">pgid</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">child</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nf">removeChild</span><span class="p">(</span><span class="nx">child</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="nx">child</span><span class="p">.</span><span class="nx">parent</span> <span class="p">=</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl">				<span class="nx">child</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">children</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Copy over inodes from target and remove target.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">,</span> <span class="nx">target</span><span class="p">.</span><span class="nx">inodes</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nf">del</span><span class="p">(</span><span class="nx">target</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nf">removeChild</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nb">delete</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">nodes</span><span class="p">,</span> <span class="nx">target</span><span class="p">.</span><span class="nx">pgid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">target</span><span class="p">.</span><span class="nf">free</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Reparent all child nodes being moved.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">inode</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">child</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">nodes</span><span class="p">[</span><span class="nx">inode</span><span class="p">.</span><span class="nx">pgid</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">child</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nf">removeChild</span><span class="p">(</span><span class="nx">child</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="nx">child</span><span class="p">.</span><span class="nx">parent</span> <span class="p">=</span> <span class="nx">target</span>
</span></span><span class="line"><span class="cl">				<span class="nx">child</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">children</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Copy over inodes to target and remove node.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">target</span><span class="p">.</span><span class="nx">inodes</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">target</span><span class="p">.</span><span class="nx">inodes</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nf">del</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nf">removeChild</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nb">delete</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">nodes</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">pgid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span><span class="p">.</span><span class="nf">free</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Either this node or the target node was deleted from the parent so rebalance it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 经过删除后，parent也需要rebalance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">n</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nf">rebalance</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的node.rebalance完成后，有可能有node的大小超过page size，一方面rebalance并不会处理插入元素，另一方面，rebalance时可能会合并兄弟节点。这个问题是在准备分配脏页时处理的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// spill writes the nodes to dirty pages and splits nodes as it goes.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Returns an error if dirty pages cannot be allocated.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">spill</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">tx</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">tx</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 已经分配过，直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">spilled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Spill child nodes first. Child nodes can materialize sibling nodes in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// the case of split-merge so we cannot use a range loop. We have to check
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// the children size on every loop iteration.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sort</span><span class="p">.</span><span class="nf">Sort</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">children</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">children</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">spill</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// We no longer need the child list because it&#39;s only used for spill tracking.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">n</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Split nodes into appropriate sizes. The first node will always be n.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 根据page size有可能分裂成多个页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">nodes</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">pageSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">node</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">nodes</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Add node&#39;s page to the freelist if it&#39;s not new.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">pgid</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">freelist</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">txid</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">page</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">pgid</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="nx">node</span><span class="p">.</span><span class="nx">pgid</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Allocate contiguous space for the node.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// 为每个page分配新页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">allocate</span><span class="p">((</span><span class="nx">node</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">/</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">pageSize</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Write the node.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">id</span> <span class="o">&gt;=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">pgid</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;pgid (%d) above high water mark (%d)&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">pgid</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">node</span><span class="p">.</span><span class="nx">pgid</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">id</span>
</span></span><span class="line"><span class="cl">		<span class="nx">node</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">node</span><span class="p">.</span><span class="nx">spilled</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Insert into parent inodes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">parent</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kd">var</span> <span class="nx">key</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">key</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">key</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">key</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">inodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">key</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 更新到parent中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">node</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">inodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">key</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">pgid</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">node</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">inodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">key</span>
</span></span><span class="line"><span class="cl">			<span class="nf">_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;spill: zero-length node key&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Update the statistics.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">tx</span><span class="p">.</span><span class="nx">stats</span><span class="p">.</span><span class="nx">Spill</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// If the root node split and created a new root then we need to spill that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// as well. We&#39;ll clear out the children to make sure it doesn&#39;t try to respill.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">parent</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">pgid</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">n</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">n</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nf">spill</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>分配脏页时，会将超过page size的页拆分为多个页，这是基于磁盘page的B+树与内存B+树的不同点之一，而内存中的B+树一般是有固定的key数的，超过key数时才需要拆分。</p>
<h2 id="事务处理">事务处理</h2>
<p>boltdb任一时刻只允许一个写事务，但允许多个读事务同时运行。由于采用了append only B+ tree实现，写事务不会更新已有的数据页，因此写事务运行时多个读事务也可以正常进行。</p>
<h3 id="读事务">读事务</h3>
<p>boltdb提供了View函数来方便执行读事务，不管成功还是失败最后都会调用Rollback来关闭事务。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// View executes a function within the context of a managed read-only transaction.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Any error that is returned from the function is returned from the View() method.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Attempting to manually rollback within the function will cause a panic.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">View</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Begin</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Make sure the transaction rolls back in the event of a panic.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">db</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">t</span><span class="p">.</span><span class="nf">rollback</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Mark as a managed tx so that the inner function cannot manually rollback.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">t</span><span class="p">.</span><span class="nx">managed</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// If an error is returned from the function then pass it through.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">err</span> <span class="p">=</span> <span class="nf">fn</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span><span class="p">.</span><span class="nx">managed</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">_</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Rollback</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 用来释放page页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Rollback</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">beginTx</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">Tx</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Lock the meta pages while we initialize the transaction. We obtain
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// the meta lock before the mmap lock because that&#39;s the order that the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// write transaction will obtain them.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">metalock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Obtain a read-only lock on the mmap. When the mmap is remapped it will
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// obtain a write lock so all transactions must finish before it can be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// remapped.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 读事务运行时会一直持有mmaplock的读锁，一般不会block写事务。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 长时间执行的读事务为了防止block写事务，需要设置InitialMmapSize为比较大的值，以便让写事务不需要重新mmap。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">mmaplock</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Exit if the database is not open yet.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">db</span><span class="p">.</span><span class="nx">opened</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">db</span><span class="p">.</span><span class="nx">mmaplock</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">db</span><span class="p">.</span><span class="nx">metalock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrDatabaseNotOpen</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Create a transaction associated with the database.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Tx</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">db</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Keep track of transaction until it closes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 记录运行中的读事务，用于安全的释放page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">txs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">txs</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">txs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Unlock the meta pages.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">metalock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Update the transaction stats.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">statlock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">db</span><span class="p">.</span><span class="nx">stats</span><span class="p">.</span><span class="nx">TxN</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">	<span class="nx">db</span><span class="p">.</span><span class="nx">stats</span><span class="p">.</span><span class="nx">OpenTxN</span> <span class="p">=</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl">	<span class="nx">db</span><span class="p">.</span><span class="nx">statlock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">t</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>读事务执行完成后，需要关闭事务，以便释放资源。读事务是通过调用Rollback来关闭。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nb">close</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">writable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">removeTx</span><span class="p">(</span><span class="nx">tx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Clear all references.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tx</span><span class="p">.</span><span class="nx">root</span> <span class="p">=</span> <span class="nx">Bucket</span><span class="p">{</span><span class="nx">tx</span><span class="p">:</span> <span class="nx">tx</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tx</span><span class="p">.</span><span class="nx">pages</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// removeTx removes a transaction from the database.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">removeTx</span><span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Release the read lock on the mmap.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 释放mmap读锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">mmaplock</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Use the meta lock to restrict access to the DB object.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">metalock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Remove the transaction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 移除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">t</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">db</span><span class="p">.</span><span class="nx">txs</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="nx">tx</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">last</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">txs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">			<span class="nx">db</span><span class="p">.</span><span class="nx">txs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">txs</span><span class="p">[</span><span class="nx">last</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">			<span class="nx">db</span><span class="p">.</span><span class="nx">txs</span><span class="p">[</span><span class="nx">last</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">			<span class="nx">db</span><span class="p">.</span><span class="nx">txs</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">txs</span><span class="p">[:</span><span class="nx">last</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">txs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Unlock the meta pages.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">metalock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Merge statistics.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">statlock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">db</span><span class="p">.</span><span class="nx">stats</span><span class="p">.</span><span class="nx">OpenTxN</span> <span class="p">=</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl">	<span class="nx">db</span><span class="p">.</span><span class="nx">stats</span><span class="p">.</span><span class="nx">TxStats</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tx</span><span class="p">.</span><span class="nx">stats</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">db</span><span class="p">.</span><span class="nx">statlock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="写事务">写事务</h3>
<p>boltdb提供了Update函数来方便执行写事务，在成功时自动Commit，在失败时自动回滚。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Update executes a function within the context of a read-write managed transaction.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If no error is returned from the function then the transaction is committed.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If an error is returned then the entire transaction is rolled back.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Any error that is returned from the function or returned from the commit is
</span></span></span><span class="line"><span class="cl"><span class="c1">// returned from the Update() method.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Attempting to manually commit or rollback within the function will cause a panic.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">Update</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Begin</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Make sure the transaction rolls back in the event of a panic.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">db</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">t</span><span class="p">.</span><span class="nf">rollback</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Mark as a managed tx so that the inner function cannot manually commit.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">t</span><span class="p">.</span><span class="nx">managed</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// If an error is returned from the function then rollback and return error.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">err</span> <span class="p">=</span> <span class="nf">fn</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span><span class="p">.</span><span class="nx">managed</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">_</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Rollback</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Commit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 开始写事务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">beginRWTx</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">Tx</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// If the database was opened with Options.ReadOnly, return an error.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nx">readOnly</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrDatabaseReadOnly</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Obtain writer lock. This is released by the transaction when it closes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// This enforces only one writer transaction at a time.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 限制只能有一个写事务在同时运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">rwlock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Once we have the writer lock then we can lock the meta pages so that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// we can set up the transaction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">metalock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nx">metalock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Exit if the database is not open yet.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">db</span><span class="p">.</span><span class="nx">opened</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">db</span><span class="p">.</span><span class="nx">rwlock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrDatabaseNotOpen</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Create a transaction associated with the database.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Tx</span><span class="p">{</span><span class="nx">writable</span><span class="p">:</span> <span class="kc">true</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 写事务在init中初始化pages map，用来记录需要写的page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 在tx.allocate中会执行 tx.pages[p.id] = p
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">t</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">db</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">db</span><span class="p">.</span><span class="nx">rwtx</span> <span class="p">=</span> <span class="nx">t</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Free any pages associated with closed read-only transactions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">minid</span> <span class="nx">txid</span> <span class="p">=</span> <span class="mh">0xFFFFFFFFFFFFFFFF</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">t</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">db</span><span class="p">.</span><span class="nx">txs</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">txid</span> <span class="p">&lt;</span> <span class="nx">minid</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">minid</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">txid</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">minid</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 释放已经执行完的事务用到的page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">db</span><span class="p">.</span><span class="nx">freelist</span><span class="p">.</span><span class="nf">release</span><span class="p">(</span><span class="nx">minid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">t</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>回滚事务的逻辑相对简单</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nf">rollback</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">writable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 回滚写事务即将释放的页，这些页本来要释放成空闲页，改为不释放了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">freelist</span><span class="p">.</span><span class="nf">rollback</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">txid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 重新加载空闲页列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">freelist</span><span class="p">.</span><span class="nf">reload</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">page</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">meta</span><span class="p">().</span><span class="nx">freelist</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tx</span><span class="p">.</span><span class="nb">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nb">close</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">writable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Remove transaction ref &amp; writer lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">rwtx</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 释放锁，以便让其他写事务执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">rwlock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Merge statistics.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">statlock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 更新一些统计信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">statlock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">removeTx</span><span class="p">(</span><span class="nx">tx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Clear all references.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tx</span><span class="p">.</span><span class="nx">root</span> <span class="p">=</span> <span class="nx">Bucket</span><span class="p">{</span><span class="nx">tx</span><span class="p">:</span> <span class="nx">tx</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tx</span><span class="p">.</span><span class="nx">pages</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>提交事务的实现如下</p>
<ol>
<li>调用rebalance来合并过小的页</li>
<li>调用splil来分配脏页，并split过大的页</li>
<li>分配新的freelist页，写盘</li>
<li>脏页写盘</li>
<li>写入新的meta页</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Commit writes all changes to disk and updates the meta page.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Returns an error if a disk write error occurs, or if Commit is
</span></span></span><span class="line"><span class="cl"><span class="c1">// called on a read-only transaction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nf">Commit</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">_assert</span><span class="p">(!</span><span class="nx">tx</span><span class="p">.</span><span class="nx">managed</span><span class="p">,</span> <span class="s">&#34;managed tx commit not allowed&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">ErrTxClosed</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">!</span><span class="nx">tx</span><span class="p">.</span><span class="nx">writable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">ErrTxNotWritable</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// TODO(benbjohnson): Use vectorized I/O to write out dirty pages.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Rebalance nodes which have had deletions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">startTime</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 调用rebalance来合并过小的page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nf">rebalance</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">stats</span><span class="p">.</span><span class="nx">Rebalance</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">tx</span><span class="p">.</span><span class="nx">stats</span><span class="p">.</span><span class="nx">RebalanceTime</span> <span class="o">+=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">startTime</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// spill data onto dirty pages.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">startTime</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 调用Bucket.spill来分配脏页，并split过大的页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nf">spill</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">tx</span><span class="p">.</span><span class="nf">rollback</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tx</span><span class="p">.</span><span class="nx">stats</span><span class="p">.</span><span class="nx">SpillTime</span> <span class="o">+=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">startTime</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Free the old root bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">root</span> <span class="p">=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">root</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">opgid</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">pgid</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Free the freelist and allocate new pages for it. This will overestimate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// the size of the freelist but not underestimate the size (which would be bad).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">freelist</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">txid</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">page</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">freelist</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 分配新的freelist页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">allocate</span><span class="p">((</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">freelist</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">/</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">pageSize</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">tx</span><span class="p">.</span><span class="nf">rollback</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 写入freelist页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">freelist</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">tx</span><span class="p">.</span><span class="nf">rollback</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">freelist</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">id</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// If the high water mark has moved up then attempt to grow the database.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 如果文件变大了，则调用truncate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">pgid</span> <span class="p">&gt;</span> <span class="nx">opgid</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">grow</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">pgid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">pageSize</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">tx</span><span class="p">.</span><span class="nf">rollback</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Write dirty pages to disk.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">startTime</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 将涉及的脏页调用write写盘，并将没有overflow的内存page加入page pool中以便后续重用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">write</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">tx</span><span class="p">.</span><span class="nf">rollback</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// If strict mode is enabled then perform a consistency check.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Only the first consistency error is reported in the panic.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">StrictMode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ch</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Check</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="kd">var</span> <span class="nx">errs</span> <span class="p">[]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">err</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">errs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">errs</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">errs</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;check fail: &#34;</span> <span class="o">+</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">errs</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Write meta to disk.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 写入meta页
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">writeMeta</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">tx</span><span class="p">.</span><span class="nf">rollback</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">tx</span><span class="p">.</span><span class="nx">stats</span><span class="p">.</span><span class="nx">WriteTime</span> <span class="o">+=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">startTime</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Finalize the transaction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nb">close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Execute commit handlers now that the locks have been removed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">commitHandlers</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">fn</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Bucket的spill实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// spill writes all the nodes for this bucket to dirty pages.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Bucket</span><span class="p">)</span> <span class="nf">spill</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Spill all child buckets first.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">child</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">b</span><span class="p">.</span><span class="nx">buckets</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// If the child bucket is small enough and it has no child buckets then
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// write it inline into the parent bucket&#39;s page. Otherwise spill it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// like a normal bucket and make the parent value a pointer to the page.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="kd">var</span> <span class="nx">value</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">child</span><span class="p">.</span><span class="nf">inlineable</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">child</span><span class="p">.</span><span class="nf">free</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 内嵌页处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">value</span> <span class="p">=</span> <span class="nx">child</span><span class="p">.</span><span class="nf">write</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 对child bucket调用spill
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">child</span><span class="p">.</span><span class="nf">spill</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="c1">// Update the child bucket header in this bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">value</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">bucket</span><span class="p">{}))</span>
</span></span><span class="line"><span class="cl">			<span class="kd">var</span> <span class="nx">bucket</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bucket</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">			<span class="o">*</span><span class="nx">bucket</span> <span class="p">=</span> <span class="o">*</span><span class="nx">child</span><span class="p">.</span><span class="nx">bucket</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Skip writing the bucket if there are no materialized nodes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">child</span><span class="p">.</span><span class="nx">rootNode</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Update parent node.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="kd">var</span> <span class="nx">c</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Cursor</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">k</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">flags</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">seek</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">name</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">!</span><span class="nx">bytes</span><span class="p">.</span><span class="nf">Equal</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">name</span><span class="p">),</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;misplaced bucket header: %x -&gt; %x&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">name</span><span class="p">),</span> <span class="nx">k</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">bucketLeafFlag</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;unexpected bucket header flag: %x&#34;</span><span class="p">,</span> <span class="nx">flags</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 写入node中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nf">node</span><span class="p">().</span><span class="nf">put</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">name</span><span class="p">),</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">name</span><span class="p">),</span> <span class="nx">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">bucketLeafFlag</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Ignore if there&#39;s not a materialized root node.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">rootNode</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Spill nodes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 调用node.spill
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">rootNode</span><span class="p">.</span><span class="nf">spill</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span><span class="p">.</span><span class="nx">rootNode</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">rootNode</span><span class="p">.</span><span class="nf">root</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Update the root node for this bucket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">rootNode</span><span class="p">.</span><span class="nx">pgid</span> <span class="o">&gt;=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">pgid</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;pgid (%d) above high water mark (%d)&#34;</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">rootNode</span><span class="p">.</span><span class="nx">pgid</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">pgid</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span><span class="p">.</span><span class="nx">root</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">rootNode</span><span class="p">.</span><span class="nx">pgid</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="mvcc">MVCC</h3>
<p>多版本并发控制(MVCC)是指数据库中同时保存数据的多个版本，以便支持多个事务的隔离和同时运行。写事务并不会直接修改数据，而是创建数据的一个新版本。</p>
<p>在boltdb中，支持多个读事务同时运行，任一时间只有一个写事务能够运行。从上面的事务处理分析可见，写事务并不会修改已有的page，而是分配新的page然后写入，因此同时运行的读事务可以继续访问老版本的数据而不受影响。写事务在提交时会修改meta页，此后创建的读写事务会用最新meta页来初始化事务，也就可以读到最新版本的数据。</p>
<h2 id="crash-recovery">crash recovery</h2>
<p>boltdb没有做专门的crash recovery，是通过控制修改的顺序来保证数据完整性的，先写入树结构，再写入meta页。在写事务提交过程中机器宕机时，如果meta页还未修改，会用之前的状态重新打开DB，如果meta页写入不完整，会用另一个meta页来重新打开DB。需要注意的是，对于mmap而言，仅控制写入的并不能保证同步到磁盘的顺序，因此boltdb实现时都有显式的调用<code>fdatasync</code> ，保证前面的修改同步到磁盘后才进行后面的操作。</p>
<h2 id="总结">总结</h2>
<p>boltdb代码还是很值得阅读和学习的，通过4000行左右的代码，实现了高效的KV数据库。</p>
<ul>
<li>boltdb借助mmap来简化buffer管理器的实现，通过控制写盘顺序而不需要专门的crash recovery处理。</li>
<li>boltdb实现了append only B+树。</li>
<li>boltdb的页分配算法比较巧妙的是只会分配连续的页，简化了后续的处理逻辑。</li>
</ul>
<p>参考资料</p>
<ul>
<li><a href="https://github.com/jaydenwen123/boltdb_book/blob/master/boltdb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md">boltdb_book/boltdb源码分析.md at master · jaydenwen123/boltdb_book · GitHub</a></li>
<li><a href="https://www.codedump.info/post/20200625-boltdb-1/">boltdb 1.3.0实现分析（一） - codedump的网络日志</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>论文笔记：PacificA: Replication in Log-Based Distributed Storage Systems</title>
      <link>https://egolearner.github.io/post/pacifica/</link>
      <pubDate>Sun, 27 Nov 2022 21:21:11 +0800</pubDate>
      
      <guid>https://egolearner.github.io/post/pacifica/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Authors: Mao Yang, Wei Lin&lt;/li&gt;
&lt;li&gt;Created: November 26, 2022 8:29 PM&lt;/li&gt;
&lt;li&gt;PublishedAt: MSR-TR-2008-25&lt;/li&gt;
&lt;li&gt;Tags: distributed-system&lt;/li&gt;
&lt;li&gt;URL: &lt;a href=&#34;https://www.microsoft.com/en-us/research/wp-content/uploads/2008/02/tr-2008-25.pdf&#34;&gt;https://www.microsoft.com/en-us/research/wp-content/uploads/2008/02/tr-2008-25.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Year: 2008&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;summary&#34;&gt;&lt;strong&gt;Summary&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;论文提出了一种基于日志的分布式存储系统实现方式，将复制组的成员管理和数据复制解耦开来，前者使用配置管理器（如Paxos）来管理，后者使用primary/backup机制：主节点接收到客户端的写请求后，将其复制到所有的从节点后再向客户端发送响应；在强一致性模式下只有主节点会处理读请求；数据管理节点最多可以容忍n-1个节点失败。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<ul>
<li>Authors: Mao Yang, Wei Lin</li>
<li>Created: November 26, 2022 8:29 PM</li>
<li>PublishedAt: MSR-TR-2008-25</li>
<li>Tags: distributed-system</li>
<li>URL: <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2008/02/tr-2008-25.pdf">https://www.microsoft.com/en-us/research/wp-content/uploads/2008/02/tr-2008-25.pdf</a></li>
<li>Year: 2008</li>
</ul>
<h1 id="summary"><strong>Summary</strong></h1>
<p>论文提出了一种基于日志的分布式存储系统实现方式，将复制组的成员管理和数据复制解耦开来，前者使用配置管理器（如Paxos）来管理，后者使用primary/backup机制：主节点接收到客户端的写请求后，将其复制到所有的从节点后再向客户端发送响应；在强一致性模式下只有主节点会处理读请求；数据管理节点最多可以容忍n-1个节点失败。</p>
<h2 id="strength"><strong>Strength</strong></h2>
<ul>
<li>容易理解和论证正确性，工程上容易实现。</li>
<li>最多可以容忍n-1个节点失败。</li>
</ul>
<h2 id="weakness"><strong>Weakness</strong></h2>
<ul>
<li>节点抖动时容易出现写请求停滞，依赖于合理的配置租约过期时间。</li>
</ul>
<h2 id="我的思考">我的思考</h2>
<p>论文提出的模式在工程上容易实现，ES就采用了PacificA的模式。这篇论文发表时Raft还没有发表，应该也没有可用的Paxos库，因此这个模式是有意义的，使用已有的Paxos服务来做成员管理，然后自己实现数据复制。在有很多Raft和Paxos库的今天，基于这些库来实现日志复制成为更简单可行的方案。</p>
<h1 id="2-pacifica-replication-framework">2. PACIFICA REPLICATION FRAMEWORK</h1>
<p>适用网络环境：局域网。</p>
<p>错误模型：fail-stop。论文不要求server间的消息时延有上限。不要求时钟是同步的或者松散同步的，但要求时钟飘移有上限。</p>
<h2 id="21-primarybackup-data-replication">2.1 Primary/Backup Data Replication</h2>
<p>一个复制组的主节点负责处理写请求和读请求，并将写请求同步到secondaries节点上去。主节点为update请求确定单调递增的序列号，从节点也按照这个顺序处理请求，因此可以保证从节点的数据和主节点一致。</p>
<p>每个副本维护prepared list和committed point，committed point之前为committed list。</p>
<ul>
<li>读请求处理。主节点使用使用当前的committed list表示的状态来处理请求并返回结果。</li>
<li>写请求处理。
<ul>
<li>主节点分配请求的序列号，将请求、序列号及当前的配置版本作为prepare消息发送到所有从节点。</li>
<li>从节点将接收到的请求以序列号的顺序插入prepared list，然后发送响应给主节点。</li>
<li>主节点接收到所有从节点的ack后请求变为comitted，向客户端发送响应。</li>
<li>每次prepare消息还带上committed point的序列号，以便从节点移动committed point。</li>
</ul>
</li>
</ul>
<img src="/static/PacificA%20Replication%20in%20Log-Based%20Distributed%20Stor%206514f49fc42c4b8a91f2da1663a6af6a/Untitled.png">
<h2 id="22-configuration-management">2.2 Configuration Management</h2>
<p>使用配置管理器（如Paxos）维护节点信息。在节点疑似失效或者新节点加入时，主节点会提交新配置。只有版本匹配时才允许提交。</p>
<p>在出现网络分区时，可能有冲突的重新配置请求：主节点想要移除某些从节点，而某些从节点想要移除主节点。因为这些请求都是基于当前的配置，因此第一个被Paxos接受的请求获得胜利，其他冲突的请求因为版本不匹配而被拒绝。</p>
<img src="/static/PacificA%20Replication%20in%20Log-Based%20Distributed%20Stor%206514f49fc42c4b8a91f2da1663a6af6a/Untitled%201.png">
<h2 id="23-leases-and-failure-detection">2.3 Leases and Failure Detection</h2>
<p>使用租约来防止脑裂问题。</p>
<p>主节点从每个节点取得租约，然后定期发送beacon来维护租约。如果超过一定时间没有收到从节点对beacon的响应，则租约过期。如果任一租约过期，主节点不再认为自己是主节点，停止处理读写请求，先从Paxos中移除失效的从节点。</p>
<p>只要发送beacon的节点是当前配置的主节点，从节点就回复ack。超过grace period后没收到主节点的beacon，从节点认为租约过期，联系Paxos移除当前的主节点并成为新的主节点。</p>
<p>假设没有时钟飘移，只要grace period大于等于租约时间，就可以保证租约在主节点上过期先于在从节点上过期。</p>
<p>有请求时，beacon和ack和附带发送。没有请求时，才需要专门发送beacon和ack。</p>
<h2 id="24-reconfiguration-reconciliation-and-recovery">2.4 Reconfiguration, Reconciliation, and Recovery</h2>
<p>新的主节点即位后开始reconciliation。新主将自己的prepared list发送到所有从节点，从节点需要截断新主的committed point之后的请求。</p>
<p>发生主节点切换时，已提交的序列号会被保持，而未提交的序列号则不一定保持。</p>
<p>新的节点加入时，为避免阻塞请求处理，先作为候选从节点加入，追上后通知主节点将其作为从节点加入配置中。</p>
<p>在节点先被移除配置后又重新加回配置的场景中，可以先从prepared list中截断不一致的请求，然后同步增量请求。</p>
<h2 id="25-correctness">2.5 Correctness</h2>
<blockquote>
<p>Linearizability: The system execution is equivalent to a linearized execution of all processed requests. <br />
Durability: If a client receives an acknowledgment from the system for an update, the update has been included in the equivalent linearized execution. <br />
Progress: Assuming that communication links between non-faulty servers are reliable, that the configuration manager eventually responds to reconfiguration requests, and that eventually there are no failures and no reconfigurations in the system, the system will return a response to each client request. <br /></p>
</blockquote>
<h2 id="26-implementations">2.6 Implementations</h2>
<p>如果支持append-only的应用状态的话，可以直接用作prepared list。</p>
<h2 id="27-discussions">2.7 Discussions</h2>
<p>最多允许n-1个节点失败。</p>
<p>为了应对整个复制组的短暂失败，所有副本的prepared list和committed point需要维护在持久化存储上。</p>
<p>和Paxos的对比</p>
<ol>
<li>Paxos对少数慢节点不敏感，而会导致primary/backup协议停滞，直到重新配置请求将其从复制组中移除。租约时间也需要合理配置，如果过大在节点失败时会有比较长的停滞时间，如果过小会导致假阳性。</li>
<li>PacificA容忍更多的节点失败。</li>
<li>PacificA的重新配置借助配置管理器可以很容易的实现。</li>
</ol>
<p>弱化一致性要求：租约过期的主节点或者从节点也允许处理query请求。</p>
<h1 id="3-replication-for-distributed-log-based-storage-systems">3 REPLICATION FOR DISTRIBUTED LOG-BASED STORAGE SYSTEMS</h1>
<img src="/static/PacificA%20Replication%20in%20Log-Based%20Distributed%20Stor%206514f49fc42c4b8a91f2da1663a6af6a/Untitled%202.png">
<p>上图为单机架构。</p>
<h2 id="31-logical-replication">3.1 Logical Replication</h2>
<p>在应用日志基础上加上3个字段：配置版本、序列号、上个提交的序列号，即可以使用一个日志同时作为应用日志和prepared request存储。对于相同序列号的日志，高配置版本会覆盖低版本的日志。</p>
<p>在第一个阶段，接收到prepare消息时，副本追加到日志中。在第二个阶段，请求提交时，被应用到内存中的数据结构中。</p>
<p>在checkpoint后，可以截断已应用和已checkpoint的日志。</p>
<p>logical-V是logical replication的变体，只有主节点维护内存状态，从节点只需要追加日志，而不需要应用到内存状态。主节点生成快照的时候，从节点也需要fetch快照，截断已被丢弃或者快照的日志。优势是从节点消耗更少的内存和CPU，缺点是更高的网络带宽消耗，主节点切换也需要花费更多的时间来重建内存状态。</p>
<h2 id="32-layered-replication">3.2 Layered Replication</h2>
<p>基于log的存储系统由两层构成：底层提供持久化文件存储，上层将应用逻辑变为文件操作。</p>
<h2 id="33-log-merging">3.3 Log Merging</h2>
<p>一个机器上有多个复制组时，需要合并日志以避免导致磁盘随机seek。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>论文笔记：DiskANN: Fast Accurate Billion-point Nearest Neighbor Search on a Single Node</title>
      <link>https://egolearner.github.io/post/diskann/</link>
      <pubDate>Sun, 13 Nov 2022 08:47:05 +0800</pubDate>
      
      <guid>https://egolearner.github.io/post/diskann/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Authors: Devvrit, Suhas Jayaram Subramanya&lt;/li&gt;
&lt;li&gt;Created: October 4, 2022 9:45 PM&lt;/li&gt;
&lt;li&gt;PublishedAt: NIPS&lt;/li&gt;
&lt;li&gt;URL: &lt;a href=&#34;https://suhasjs.github.io/files/diskann_neurips19.pdf&#34;&gt;https://suhasjs.github.io/files/diskann_neurips19.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Year: 2019&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;summary&#34;&gt;&lt;strong&gt;Summary&lt;/strong&gt;&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;DiskANN使用64G RAM来索引和服务100维左右的10亿数据集，95%以上的1-recall@1的时延在5ms以内。&lt;/li&gt;
&lt;li&gt;提出Vamana图算法，直径比NSG和HNSW更小。&lt;/li&gt;
&lt;li&gt;将点加入重叠聚类，每个聚类构建Vamana索引，然后通过合并边来实现图合并，和所有数据点构建单一索引的搜索性能相近。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;strength&#34;&gt;&lt;strong&gt;Strength&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;通过将点加入重叠聚类，构建的图简单合并也有不错的效果。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;weakness&#34;&gt;&lt;strong&gt;Weakness&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;图索引用在SSD上，直觉上太多随机访问效果应该会打折扣，虽然Vamana做了优化。后续的SPANN通过层次均衡聚类构建倒排索引，性能超过了DiskANN。&lt;/li&gt;
&lt;li&gt;索引中需要同时存原始向量和PQ压缩向量，应该磁盘使用会比较大。&lt;/li&gt;
&lt;li&gt;性能数据只比较了1-recall@1，很多系统在召回时不止召回一个。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;take-away&#34;&gt;&lt;strong&gt;Take Away&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;图索引合并。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<ul>
<li>Authors: Devvrit, Suhas Jayaram Subramanya</li>
<li>Created: October 4, 2022 9:45 PM</li>
<li>PublishedAt: NIPS</li>
<li>URL: <a href="https://suhasjs.github.io/files/diskann_neurips19.pdf">https://suhasjs.github.io/files/diskann_neurips19.pdf</a></li>
<li>Year: 2019</li>
</ul>
<h1 id="summary"><strong>Summary</strong></h1>
<ol>
<li>DiskANN使用64G RAM来索引和服务100维左右的10亿数据集，95%以上的1-recall@1的时延在5ms以内。</li>
<li>提出Vamana图算法，直径比NSG和HNSW更小。</li>
<li>将点加入重叠聚类，每个聚类构建Vamana索引，然后通过合并边来实现图合并，和所有数据点构建单一索引的搜索性能相近。</li>
</ol>
<h2 id="strength"><strong>Strength</strong></h2>
<ol>
<li>通过将点加入重叠聚类，构建的图简单合并也有不错的效果。</li>
</ol>
<h2 id="weakness"><strong>Weakness</strong></h2>
<ol>
<li>图索引用在SSD上，直觉上太多随机访问效果应该会打折扣，虽然Vamana做了优化。后续的SPANN通过层次均衡聚类构建倒排索引，性能超过了DiskANN。</li>
<li>索引中需要同时存原始向量和PQ压缩向量，应该磁盘使用会比较大。</li>
<li>性能数据只比较了1-recall@1，很多系统在召回时不止召回一个。</li>
</ol>
<h2 id="take-away"><strong>Take Away</strong></h2>
<p>图索引合并。</p>
<h1 id="1-引言">1 引言</h1>
<p>总结当前10亿级向量检索的解决方案</p>
<p>方案1。基于倒排索引和数据压缩，典型例子Faiss和IVFOADC+G+P。将向量划分为M个聚类，检索时只扫描m &laquo; M个分区；因为原始数据内存中放不下，使用使用PQ等量化手段来压缩数据。优点是内存使用低，128维10亿点使用小于64GB的内存。缺点是由于数据压缩有损，1-recall@1只有0.5左右。</p>
<p>方案2。数据划分为不相交分片，每个分片构建内存索引。优点是召回很高，缺点是内存使用很大。</p>
<p>论文认为上述两个方案的局限在于它们构建的索引只能使用内存服务。</p>
<p>零售级的SSD一次随机读需要几百微秒，每秒能处理约300k的随机读。而搜索应用中最近邻检索的时延要求为几毫秒。因此设计高效的SSD驻留索引的关键有两点：减少随机SSD访问到几十个；减少到磁盘的round trip请求数到10个以内，最好到5个。（个人理解第一点在强调图的直径不能太大，第二点在强调减少磁盘访问，即后面提出的W参数）</p>
<h1 id="2-vamana-图构建算法">2 Vamana 图构建算法</h1>
<h2 id="21-近似邻居图和greedysearch算法">2.1 近似邻居图和GreedySearch算法</h2>
<p>基于近似图的检索算法，一般采用贪心算法，从某个点出发，遍历图来渐近的趋向检索点。这要求近似图满足sparse neighborhood graph(SNG)的性质。SNG中确定一个点p的出邻居的过程如下：</p>
<blockquote>
<p>initialize a set S = P \ {p}. As long as S != ∅, add a directed edge from p to p∗, where p∗ is the closest point to p from S, and remove from S all points p′ such that d(p, p′) &gt; d(p∗, p′). It is then easy to see that GreedySearch(s, x_p, 1, 1) starting at any s ∈ P would converge to p for all base points p ∈ P .</p>
</blockquote>
<p>大致是从S中选依次选到p最近的点p*，然后移除S中到p比到p*更远的点，直到S为空。</p>
<p>SNG的复杂度是O(n2)，因此不可行。本质上来说，HNSW和SSG都是对SNG的近似，因此这些算法输出的图的直径和密度都是不可灵活控制的。</p>
<img src="/static/DiskANN%20Fast%20Accurate%20Billion-point%20Nearest%20Neighb%20121a2edf1de742c0be953e90c69ed864/Untitled.png">
<h2 id="22-健壮剪枝过程">2.2 健壮剪枝过程</h2>
<p>满足SNG性质的图的直径可能非常大。论文给出的极端情况为所有点都在一条直线上，按照SSG的选边算法每个点只会连接最近的两个点。而按照Vamana的算法，有可能连接更多的点。</p>
<p>为了解决这个问题，引入乘数α&gt;1要求检索路径上的点到query的距离依次减少α倍。</p>
<p>如果点p的出邻居通过RobustPrune(p, P \ {p}, α, n-1) 确定，可以保证GreedySearch(s, p, 1, 1) 从任意点s出发将在log复杂度内收敛到 p ∈ P。但是这需要O(n2)的运行时间。Vamana通过精心挑选V和远小于n-1的点来优化索引构建时间。</p>
<p>RobustPrune最后的裁边中，通过引入α，将距离p*比距离p近1/α倍的点移除掉了，可以保留更多的长边（α越大，越有可能在候选集中保留距离p更远的点）。</p>
<h2 id="23-vamana索引算法">2.3 Vamana索引算法</h2>
<img src="/static/DiskANN%20Fast%20Accurate%20Billion-point%20Nearest%20Neighb%20121a2edf1de742c0be953e90c69ed864/Untitled%201.png">
<ol>
<li>首先随机初始化G，每个点有R个随机选择的出邻居。</li>
<li>计算数据集P的中心点s，作为检索算法的起始点。</li>
<li>随机遍历P的所有点p，对GreedySearch访问的点运行RobustPrune来得到点p的出邻居。</li>
<li>对点p的出邻居p’添加反向边p’p，如果出度超过R则运行RobustPrune来选边。</li>
</ol>
<p>随着算法的运行，图变得一致地更好，GreedySearch运行更快。</p>
<p>整体算法运行两遍，第一次使用α=1运行，第二次使用用户定义的α≥1运行。作者观察到第二次运行得到更好的图，如果两次都用用户定义的α运行会使索引算法变慢，因为第一次运行计算出的图的平均度数更大，计算时间也更长。（第一次运行如果使用α&gt;1的话，候选集中保留了更多的点，最后的度数也会更大）</p>
<img src="/static/DiskANN%20Fast%20Accurate%20Billion-point%20Nearest%20Neighb%20121a2edf1de742c0be953e90c69ed864/Untitled%202.png">
<p>第二次运行引入了长边。</p>
<h2 id="24-对比hnsw和nsg">2.4 对比HNSW和NSG</h2>
<p>HNSW和NSG没有超参数α，隐含使用了α=1. 这是Vamana实现在图的度数和直径之间更好权衡的主要因素。</p>
<ul>
<li>HNSW使用GreedySearch的输出作为剪枝的候选集，而Vamana和SNG都使用GreedySearch访问过的点作为候选集。直觉上来说，这帮助Vamana和NSG添加了长边，而HNSW只有邻近边还需要在采样的点上构建分层图。</li>
<li>NSG要求输入为构建耗时长和内存使用高的kNN邻居图，HNSW和Vamana有更简单的初始化，HNSW使用空白图，Vamana使用随机图。Vamana使用随机图初始化比空白图初始化得到的结果图的质量更好。</li>
<li>Vamana需要运行两遍，HNSW和NSG只需要运行一遍。</li>
</ul>
<h1 id="3-diskann构建ssd驻留的索引">3 DiskANN：构建SSD驻留的索引</h1>
<h2 id="31-索引设计">3.1 索引设计</h2>
<p>基本思想是构建Vamana索引并存储到SSD上。有两个问题需要解决：如何构建有10亿个点的图？内存中存不下的情况下如何计算query点和候选列表的点之间的距离？</p>
<p>与其在检索时将query点路由到多个分片，不如将base point发往多个临近的中心点来形成重叠的聚类。</p>
<ol>
<li>将10亿个点使用k-means划分为k个聚类（比如k=40）</li>
<li>将每个base point分配到l个最近的中心点（通常l=2就足够了）</li>
<li>在每个聚类上构建Vamana索引，大约有Nl/k个点，可以在内存中构建。</li>
<li>通过简单的合并边将多个图合并为一个图。</li>
</ol>
<p>经验地，不同聚类的重叠性提供了足够的连接性，即使query点的最近的邻居分开在多个分片时GreedySearch也能成功。</p>
<p>解决第二个问题的思路为在内存中存储每个点的PQ压缩后的向量，同时在SSD上存储图。论文指出Vamana构建索引时使用全精度的坐标，因此即使在检索时使用压缩后的数据，也能高效的引导检索到图中正确的区域。</p>
<h2 id="32-索引布局">3.2 索引布局</h2>
<p>内存中存储压缩后的所有数据点，SSD上存储图和全精度的向量。在磁盘上，在每个点的≤R个邻居之后存储的是全精度向量。在度数小于R时补0，以便可以直接计算offset。</p>
<h2 id="33-beam-search">3.3 Beam Search</h2>
<p>基本的贪心算法的问题是需要有许多SSD roundtrip，导致高延迟。为了减少SSD roundtrip数而不过度增加计算量，我们一次获取 $\mathcal{L} \backslash \mathcal{V}$ 中W（比如4，8）个最近的点的邻居，更新$\mathcal{L}$为top L的候选集。注意从SSD读取少量的随机扇区的时间几乎和一个扇区的时间相同。修改后的检索算法称为BeamSearch。在W=1时，等价于贪心检索。如果W过大，比如16或更多，计算和SSD带宽都可能是浪费的。</p>
<p>SSD带宽打满时，读延迟会超过1ms。因此需要在更低的负载下运维SSD以保证低检索延迟。论文发现在低平衡宽度时（如W=2,4,8）能在延迟和吞吐之间取得平衡。这时SSD的load factor在30-40%，每个线程query处理的时间中40-50%是在IO上。</p>
<h2 id="34-缓存频繁访问的点">3.4 缓存频繁访问的点</h2>
<p>为了进一步减少每个query的磁盘访问数，在内存中缓存一部分点，要么基于已知的query分布，要么简单的缓存从起始点开始C=3,4跳的点。因为点的个数随C指数增长，更大的C带来更大的内存使用。</p>
<h2 id="35-使用全精度向量隐式re-ranking">3.5 使用全精度向量隐式Re-Ranking</h2>
<p>PQ是有损压缩，因此使用PQ和使用真实距离计算的k个候选集可能有差别。为了消除差距，论文使用在每个点的邻居之后存储的全精度向量。邻居关系和全精度向量可以存储在同一扇区内，因此在BeamSearch加载邻居信息时，也可以缓存在搜索过程中访问过的所有点的全精度向量，而不使用额外的SSD读。这可以让我们基于全精度向量来返回top k候选集。（按上面的算法1，访问过的点都是要记录的，有额外的计算开销但没有内存开销。）</p>
<h1 id="4-评估">4 评估</h1>
<img src="/static/DiskANN%20Fast%20Accurate%20Billion-point%20Nearest%20Neighb%20121a2edf1de742c0be953e90c69ed864/Untitled%203.png">
<p>所有数据集中，Vamana超过了HNSW。在GIST1M中，Vamana超过了NSG。另外在三个实验中，Vamana的索引构建时间短于HNSW和NSG。在DEEP1M上，分别为129s, 219s, 480s（包含EFANN构建kNN图的时间）。</p>
<img src="/static/DiskANN%20Fast%20Accurate%20Billion-point%20Nearest%20Neighb%20121a2edf1de742c0be953e90c69ed864/Untitled%204.png">
<p>跳数指在检索的关键路径中磁盘访问的轮数。HNSW和NSG有停滞的趋势，而Vamana随最大度数和α的增加跳数在减少。作者推断α&gt;1的Vamana相比其他图算法更有效的利用了SSD提供的大容量。</p>
<img src="/static/DiskANN%20Fast%20Accurate%20Billion-point%20Nearest%20Neighb%20121a2edf1de742c0be953e90c69ed864/Untitled%205.png">
<p>为了说明小索引合并算法的有效性，论文分别在高配机器上构建1份大索引和在低配机器上构建k份小索引并合并为1份索引。2(a)中单一索引的性能优于合并索引，因为合并索引需要遍历更多的连接。但合并索引的效果也足够好，优于当时的state-of-art IVFOADC+G+P，延时仅比单一索引慢不到20%.</p>
<p>由于IVFOADC+G+P在之前的论文中证明了效果优于FAISS，论文只对比了DiskANN和IVFOADC+G+P。IVFOADC+G+P的1-recall@1上限为62.74%，而DiskANN为100%，满足1-recall@1高于95%时的时延在3.5ms以下。</p>
<h1 id="参考资料">参考资料</h1>
<p>审稿意见</p>
<ul>
<li><a href="https://proceedings.neurips.cc/paper/2019/file/09853c7fb1d3f8ee67a61b6bf4a7f8e6-Reviews.html">Reviews: DiskANN: Fast Accurate Billion-point Nearest Neighbor Search on a Single Node (neurips.cc)</a></li>
</ul>
<p>视频</p>
<ul>
<li><a href="https://northwestern.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=afbc4c0c-0464-499c-816c-af0e015777f8">Theory-in-Practice Day one- Harsha Simhadri (panopto.com)</a></li>
<li><a href="https://www.youtube.com/watch?v=BnYNdSIKibQ">Research talk: Approximate nearest neighbor search systems at scale - YouTube</a></li>
</ul>
<p>论文笔记</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/KgjpRGF4AoUskFESZR4lxQ">Paper Reading | DiskANN： 十亿规模数据集上高召回高 QPS 的 ANNS 单机方案 (qq.com)</a></li>
<li><a href="https://www.jianshu.com/p/07ed2202f107">2019NIPS-(大数据集基于图的KNN算法)DiskANN: Fast Accurate Billion-point Nearest Neighbor Search on a Single &hellip; - 简书 (jianshu.com)</a></li>
<li><a href="https://blog.csdn.net/whenever5225/article/details/106863674">DiskANN：在单机上快速准确地进行十亿数据最近邻搜索(微软印度研究院)——NeurIPS 2019_程序员王同学的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/whenever5225/article/details/122147361">DiskANN十亿级规模向量检索方案论文浅谈_程序员王同学的博客-CSDN博客</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>braft源码分析</title>
      <link>https://egolearner.github.io/post/braft-source-read/</link>
      <pubDate>Sun, 23 Oct 2022 15:44:11 +0800</pubDate>
      
      <guid>https://egolearner.github.io/post/braft-source-read/</guid>
      <description>&lt;p&gt;brat是百度开源的RAFT实现。&lt;/p&gt;
&lt;h2 id=&#34;初始化&#34;&gt;初始化&lt;/h2&gt;
&lt;p&gt;braft::add_service添加的服务&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pr</description>
      <content:encoded><![CDATA[<p>brat是百度开源的RAFT实现。</p>
<h2 id="初始化">初始化</h2>
<p>braft::add_service添加的服务</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="c1">// 发送文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">AddService</span><span class="p">(</span><span class="n">file_service</span><span class="p">(),</span> <span class="n">brpc</span><span class="o">::</span><span class="n">SERVER_DOESNT_OWN_SERVICE</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// raft实现，pre_vote/request_vote/append_entries/install_snapshot/timeout_now
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">AddService</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="k">new</span> <span class="n">RaftServiceImpl</span><span class="p">(</span><span class="n">listen_address</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">                <span class="n">brpc</span><span class="o">::</span><span class="n">SERVER_OWNS_SERVICE</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 统计信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">AddService</span><span class="p">(</span><span class="k">new</span> <span class="n">RaftStatImpl</span><span class="p">,</span> <span class="n">brpc</span><span class="o">::</span><span class="n">SERVER_OWNS_SERVICE</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 命令行操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">AddService</span><span class="p">(</span><span class="k">new</span> <span class="n">CliServiceImpl</span><span class="p">,</span> <span class="n">brpc</span><span class="o">::</span><span class="n">SERVER_OWNS_SERVICE</span><span class="p">))</span> <span class="p">{</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>NodeImpl::init</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="n">CHECK_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_vote_timer</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">options</span><span class="p">.</span><span class="n">election_timeout_ms</span> <span class="o">+</span> <span class="n">options</span><span class="p">.</span><span class="n">max_clock_drift_ms</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">CHECK_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_election_timer</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">options</span><span class="p">.</span><span class="n">election_timeout_ms</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">CHECK_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_stepdown_timer</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">options</span><span class="p">.</span><span class="n">election_timeout_ms</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">CHECK_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_snapshot_timer</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">options</span><span class="p">.</span><span class="n">snapshot_interval_s</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 启动执行队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">bthread</span><span class="o">::</span><span class="n">execution_queue_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_apply_queue_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                       <span class="n">execute_applying_tasks</span><span class="p">,</span> <span class="k">this</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// log storage and log manager init
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">init_log_storage</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化fsm caller时创建了另外一个执行队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">init_fsm_caller</span><span class="p">(</span><span class="n">LogId</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// commitment manager init
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_ballot_box</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BallotBox</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">_ballot_box</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">ballot_box_options</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// snapshot storage init and load
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">init_snapshot_storage</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// if have log using conf in log, else using conf in options
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">_log_manager</span><span class="o">-&gt;</span><span class="n">last_log_index</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_log_manager</span><span class="o">-&gt;</span><span class="n">check_and_set_configuration</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_conf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_conf</span><span class="p">.</span><span class="n">conf</span> <span class="o">=</span> <span class="n">_options</span><span class="p">.</span><span class="n">initial_conf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// init meta and check term
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">init_meta_storage</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Now the raft node is started , have to acquire the lock to avoid race
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// conditions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">raft_mutex_t</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 只有一个节点时马上选举自己
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">_conf</span><span class="p">.</span><span class="n">stable</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">_conf</span><span class="p">.</span><span class="n">conf</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1u</span>
</span></span><span class="line"><span class="cl">            <span class="o">&amp;&amp;</span> <span class="n">_conf</span><span class="p">.</span><span class="n">conf</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">_server_id</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// The group contains only this server which must be the LEADER, trigger
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// the timer immediately.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">elect_self</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lck</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="选举阶段"><strong><strong>选举阶段</strong></strong></h2>
<p>选举超时处理</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">NodeImpl</span><span class="o">::</span><span class="n">handle_election_timeout</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">raft_mutex_t</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// check state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">STATE_FOLLOWER</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Trigger vote manually, or wait until follower lease expire.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_vote_triggered</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">_follower_lease</span><span class="p">.</span><span class="n">expired</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">triggered</span> <span class="o">=</span> <span class="n">_vote_triggered</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">_vote_triggered</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Reset leader as the leader is uncerntain on election timeout.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">PeerId</span> <span class="n">empty_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">butil</span><span class="o">::</span><span class="n">Status</span> <span class="n">status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">status</span><span class="p">.</span><span class="n">set_error</span><span class="p">(</span><span class="n">ERAFTTIMEDOUT</span><span class="p">,</span> <span class="s">&#34;Lost connection from leader %s&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">_leader_id</span><span class="p">.</span><span class="n">to_string</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 里面会根据情况情况回调on_start_following/on_stop_following
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">reset_leader_id</span><span class="p">(</span><span class="n">empty_id</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 发起预选举
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nf">pre_vote</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lck</span><span class="p">,</span> <span class="n">triggered</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Don&#39;t touch any thing of *this ever after
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="pre_vote">pre_vote</h3>
<p>Pre_vote 算法是 raft 作者在其博士论文中提出的，在节点发起一次选举时，会先发起一次 prevote 请求，判断是否能够赢得选举，赢得选举的条件与正常选举相同。如果可以，则增加 term 值，并发起正常的选举。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">NodeImpl</span><span class="o">::</span><span class="n">pre_vote</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">raft_mutex_t</span><span class="o">&gt;*</span> <span class="n">lck</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">triggered</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取last log的term和id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int64_t</span> <span class="n">old_term</span> <span class="o">=</span> <span class="n">_current_term</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// get last_log_id outof node mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">lck</span><span class="o">-&gt;</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">LogId</span> <span class="n">last_log_id</span> <span class="o">=</span> <span class="n">_log_manager</span><span class="o">-&gt;</span><span class="n">last_log_id</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">lck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// pre_vote need defense ABA after unlock&amp;lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">old_term</span> <span class="o">!=</span> <span class="n">_current_term</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">LOG</span><span class="p">(</span><span class="n">WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;node &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">_group_id</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">_server_id</span>
</span></span><span class="line"><span class="cl">                     <span class="o">&lt;&lt;</span> <span class="s">&#34; raise term &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">_current_term</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; when get last_log_id&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">_pre_vote_ctx</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">triggered</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">PeerId</span><span class="o">&gt;</span> <span class="n">peers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">_conf</span><span class="p">.</span><span class="n">list_peers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peers</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 向所有peer发送pre_vote请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">PeerId</span><span class="o">&gt;::</span><span class="n">const_iterator</span>
</span></span><span class="line"><span class="cl">            <span class="n">iter</span> <span class="o">=</span> <span class="n">peers</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">peers</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">iter</span> <span class="o">==</span> <span class="n">_server_id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">OnPreVoteRPCDone</span><span class="o">*</span> <span class="n">done</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OnPreVoteRPCDone</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="n">_current_term</span><span class="p">,</span> <span class="n">_pre_vote_ctx</span><span class="p">.</span><span class="n">version</span><span class="p">(),</span> <span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">done</span><span class="o">-&gt;</span><span class="n">cntl</span><span class="p">.</span><span class="n">set_timeout_ms</span><span class="p">(</span><span class="n">_options</span><span class="p">.</span><span class="n">election_timeout_ms</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">done</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">set_term</span><span class="p">(</span><span class="n">_current_term</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// next term
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">done</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">set_last_log_index</span><span class="p">(</span><span class="n">last_log_id</span><span class="p">.</span><span class="n">index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">done</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">.</span><span class="n">set_last_log_term</span><span class="p">(</span><span class="n">last_log_id</span><span class="p">.</span><span class="n">term</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">RaftService_Stub</span> <span class="nf">stub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">stub</span><span class="p">.</span><span class="n">pre_vote</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="o">-&gt;</span><span class="n">cntl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">done</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">done</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">,</span> <span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 给自己投票
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">grant_self</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_pre_vote_ctx</span><span class="p">,</span> <span class="n">lck</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>pre_vote请求处理</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">RaftServiceImpl</span><span class="o">::</span><span class="n">pre_vote</span><span class="p">(</span><span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">RpcController</span><span class="o">*</span> <span class="n">cntl_base</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="k">const</span> <span class="n">RequestVoteRequest</span><span class="o">*</span> <span class="n">request</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="n">RequestVoteResponse</span><span class="o">*</span> <span class="n">response</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Closure</span><span class="o">*</span> <span class="n">done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获取node对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">NodeImpl</span><span class="o">&gt;</span> <span class="n">node_ptr</span> <span class="o">=</span> 
</span></span><span class="line"><span class="cl">                        <span class="n">global_node_manager</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">group_id</span><span class="p">(),</span> <span class="n">peer_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">NodeImpl</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node_ptr</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">handle_pre_vote_request</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">cntl</span><span class="o">-&gt;</span><span class="n">SetFailed</span><span class="p">(</span><span class="n">rc</span><span class="p">,</span> <span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="n">berror</span><span class="p">(</span><span class="n">rc</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">NodeImpl</span><span class="o">::</span><span class="n">handle_pre_vote_request</span><span class="p">(</span><span class="k">const</span> <span class="n">RequestVoteRequest</span><span class="o">*</span> <span class="n">request</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                      <span class="n">RequestVoteResponse</span><span class="o">*</span> <span class="n">response</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">raft_mutex_t</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">granted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">rejected_by_lease</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">term</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">_current_term</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// ignore older term
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// get last_log_id outof node mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">lck</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">LogId</span> <span class="n">last_log_id</span> <span class="o">=</span> <span class="n">_log_manager</span><span class="o">-&gt;</span><span class="n">last_log_id</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">lck</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// pre_vote not need ABA check after unlock&amp;lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="kt">int64_t</span> <span class="n">votable_time</span> <span class="o">=</span> <span class="n">_follower_lease</span><span class="p">.</span><span class="n">votable_time_from_now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="kt">bool</span> <span class="n">grantable</span> <span class="o">=</span> <span class="p">(</span><span class="n">LogId</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">last_log_index</span><span class="p">(),</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">last_log_term</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">                        <span class="o">&gt;=</span> <span class="n">last_log_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">grantable</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">granted</span> <span class="o">=</span> <span class="p">(</span><span class="n">votable_time</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">rejected_by_lease</span> <span class="o">=</span> <span class="p">(</span><span class="n">votable_time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_term</span><span class="p">(</span><span class="n">_current_term</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_granted</span><span class="p">(</span><span class="n">granted</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_rejected_by_lease</span><span class="p">(</span><span class="n">rejected_by_lease</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_disrupted</span><span class="p">(</span><span class="n">_state</span> <span class="o">==</span> <span class="n">STATE_LEADER</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_previous_term</span><span class="p">(</span><span class="n">_current_term</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>pre_vote响应处理</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">NodeImpl</span><span class="o">::</span><span class="n">handle_pre_vote_response</span><span class="p">(</span><span class="k">const</span> <span class="n">PeerId</span><span class="o">&amp;</span> <span class="n">peer_id</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">term</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                        <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">ctx_version</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                        <span class="k">const</span> <span class="n">RequestVoteResponse</span><span class="o">&amp;</span> <span class="n">response</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// check response term，收到的term更大则放弃选举
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">term</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">_current_term</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">status</span><span class="p">.</span><span class="n">set_error</span><span class="p">(</span><span class="n">EHIGHERTERMRESPONSE</span><span class="p">,</span> <span class="s">&#34;Raft node receives higher term &#34;</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;pre_vote_response.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">step_down</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">term</span><span class="p">(),</span> <span class="nb">false</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 省略比较复杂的检查grant逻辑，涉及lease/disrupted_leader等
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 预选举通过，开始正式的选举
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">_pre_vote_ctx</span><span class="p">.</span><span class="n">granted</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">elect_self</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lck</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="elect">elect</h3>
<p>预选举通过，开始正式的选举</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// in lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">NodeImpl</span><span class="o">::</span><span class="n">elect_self</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">raft_mutex_t</span><span class="o">&gt;*</span> <span class="n">lck</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                          <span class="kt">bool</span> <span class="n">old_leader_stepped_down</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// cancel follower election timer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">_state</span> <span class="o">==</span> <span class="n">STATE_FOLLOWER</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_election_timer</span><span class="p">.</span><span class="n">stop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// reset leader_id before vote
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="n">PeerId</span> <span class="n">old_leader</span> <span class="o">=</span> <span class="n">_leader_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">leader_term</span> <span class="o">=</span> <span class="n">_current_term</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">PeerId</span> <span class="n">empty_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">butil</span><span class="o">::</span><span class="n">Status</span> <span class="n">status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">status</span><span class="p">.</span><span class="n">set_error</span><span class="p">(</span><span class="n">ERAFTTIMEDOUT</span><span class="p">,</span> <span class="s">&#34;A follower&#39;s leader_id is reset to NULL &#34;</span>
</span></span><span class="line"><span class="cl">                                    <span class="s">&#34;as it begins to request_vote.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">reset_leader_id</span><span class="p">(</span><span class="n">empty_id</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 修改状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_state</span> <span class="o">=</span> <span class="n">STATE_CANDIDATE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// term加1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_current_term</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">_voted_id</span> <span class="o">=</span> <span class="n">_server_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">BRAFT_VLOG</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;node &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">_group_id</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">_server_id</span>
</span></span><span class="line"><span class="cl">               <span class="o">&lt;&lt;</span> <span class="s">&#34; term &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">_current_term</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; start vote_timer&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 启动vote定时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_vote_timer</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">_pre_vote_ctx</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">_vote_ctx</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">old_leader_stepped_down</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_vote_ctx</span><span class="p">.</span><span class="n">set_disrupted_leader</span><span class="p">(</span><span class="n">DisruptedLeader</span><span class="p">(</span><span class="n">old_leader</span><span class="p">,</span> <span class="n">leader_term</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">_follower_lease</span><span class="p">.</span><span class="n">expire</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int64_t</span> <span class="n">old_term</span> <span class="o">=</span> <span class="n">_current_term</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// get last_log_id outof node mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">lck</span><span class="o">-&gt;</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">LogId</span> <span class="n">last_log_id</span> <span class="o">=</span> <span class="n">_log_manager</span><span class="o">-&gt;</span><span class="n">last_log_id</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">lck</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// vote need defense ABA after unlock&amp;lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">old_term</span> <span class="o">!=</span> <span class="n">_current_term</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// term changed cause by step_down
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">LOG</span><span class="p">(</span><span class="n">WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;node &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">_group_id</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">_server_id</span>
</span></span><span class="line"><span class="cl">                     <span class="o">&lt;&lt;</span> <span class="s">&#34; raise term &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">_current_term</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; when get last_log_id&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">_vote_ctx</span><span class="p">.</span><span class="n">set_last_log_id</span><span class="p">(</span><span class="n">last_log_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">PeerId</span><span class="o">&gt;</span> <span class="n">peers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">_conf</span><span class="p">.</span><span class="n">list_peers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peers</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 向peer发送vote请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">request_peers_to_vote</span><span class="p">(</span><span class="n">peers</span><span class="p">,</span> <span class="n">_vote_ctx</span><span class="p">.</span><span class="n">disrupted_leader</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//TODO: outof lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">status</span> <span class="o">=</span> <span class="n">_meta_storage</span><span class="o">-&gt;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">set_term_and_votedfor</span><span class="p">(</span><span class="n">_current_term</span><span class="p">,</span> <span class="n">_server_id</span><span class="p">,</span> <span class="n">_v_group_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">LOG</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;node &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">_group_id</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">_server_id</span>
</span></span><span class="line"><span class="cl">                   <span class="o">&lt;&lt;</span> <span class="s">&#34; fail to set_term_and_votedfor itself when elect_self,&#34;</span>
</span></span><span class="line"><span class="cl">                      <span class="s">&#34; error: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// reset _voted_id to avoid inconsistent cases
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// return immediately without granting _vote_ctx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">_voted_id</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 给自己投票
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">grant_self</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_vote_ctx</span><span class="p">,</span> <span class="n">lck</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>request vote请求处理</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">NodeImpl</span><span class="o">::</span><span class="n">handle_request_vote_request</span><span class="p">(</span><span class="k">const</span> <span class="n">RequestVoteRequest</span><span class="o">*</span> <span class="n">request</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                          <span class="n">RequestVoteResponse</span><span class="o">*</span> <span class="n">response</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">raft_mutex_t</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 忽略一些disrupt逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="n">disrupted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int64_t</span> <span class="n">previous_term</span> <span class="o">=</span> <span class="n">_current_term</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">rejected_by_lease</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ignore older term
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">term</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">_current_term</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// ignore older term
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// get last_log_id outof node mutex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">lck</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">LogId</span> <span class="n">last_log_id</span> <span class="o">=</span> <span class="n">_log_manager</span><span class="o">-&gt;</span><span class="n">last_log_id</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">lck</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// vote need ABA check after unlock&amp;lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">previous_term</span> <span class="o">!=</span> <span class="n">_current_term</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">LOG</span><span class="p">(</span><span class="n">WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;node &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">_group_id</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">_server_id</span>
</span></span><span class="line"><span class="cl">                         <span class="o">&lt;&lt;</span> <span class="s">&#34; raise term &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">_current_term</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; when get last_log_id&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="kt">bool</span> <span class="n">log_is_ok</span> <span class="o">=</span> <span class="p">(</span><span class="n">LogId</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">last_log_index</span><span class="p">(),</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">last_log_term</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">                          <span class="o">&gt;=</span> <span class="n">last_log_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int64_t</span> <span class="n">votable_time</span> <span class="o">=</span> <span class="n">_follower_lease</span><span class="p">.</span><span class="n">votable_time_from_now</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// if the vote is rejected by lease, tell the candidate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">votable_time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">rejected_by_lease</span> <span class="o">=</span> <span class="n">log_is_ok</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// increase current term, change state to follower
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">term</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">_current_term</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">butil</span><span class="o">::</span><span class="n">Status</span> <span class="n">status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">status</span><span class="p">.</span><span class="n">set_error</span><span class="p">(</span><span class="n">EHIGHERTERMREQUEST</span><span class="p">,</span> <span class="s">&#34;Raft node receives higher term &#34;</span>
</span></span><span class="line"><span class="cl">                    <span class="s">&#34;request_vote_request.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">disrupted</span> <span class="o">=</span> <span class="p">(</span><span class="n">_state</span> <span class="o">&lt;=</span> <span class="n">STATE_TRANSFERRING</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">step_down</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">term</span><span class="p">(),</span> <span class="nb">false</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// save
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">log_is_ok</span> <span class="o">&amp;&amp;</span> <span class="n">_voted_id</span><span class="p">.</span><span class="n">is_empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">butil</span><span class="o">::</span><span class="n">Status</span> <span class="n">status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">status</span><span class="p">.</span><span class="n">set_error</span><span class="p">(</span><span class="n">EVOTEFORCANDIDATE</span><span class="p">,</span> <span class="s">&#34;Raft node votes for some candidate, &#34;</span>
</span></span><span class="line"><span class="cl">                    <span class="s">&#34;step down to restart election_timer.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">step_down</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">term</span><span class="p">(),</span> <span class="nb">false</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">_voted_id</span> <span class="o">=</span> <span class="n">candidate_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">//TODO: outof lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 投票需要持久化存储
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">status</span> <span class="o">=</span> <span class="n">_meta_storage</span><span class="o">-&gt;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">set_term_and_votedfor</span><span class="p">(</span><span class="n">_current_term</span><span class="p">,</span> <span class="n">candidate_id</span><span class="p">,</span> <span class="n">_v_group_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// reset _voted_id to response set_granted(false)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">_voted_id</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_disrupted</span><span class="p">(</span><span class="n">disrupted</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_previous_term</span><span class="p">(</span><span class="n">previous_term</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_term</span><span class="p">(</span><span class="n">_current_term</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_granted</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">term</span><span class="p">()</span> <span class="o">==</span> <span class="n">_current_term</span> <span class="o">&amp;&amp;</span> <span class="n">_voted_id</span> <span class="o">==</span> <span class="n">candidate_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_rejected_by_lease</span><span class="p">(</span><span class="n">rejected_by_lease</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>request vote响应处理逻辑</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">NodeImpl</span><span class="o">::</span><span class="n">handle_request_vote_response</span><span class="p">(</span><span class="k">const</span> <span class="n">PeerId</span><span class="o">&amp;</span> <span class="n">peer_id</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">term</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                            <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">ctx_version</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                            <span class="k">const</span> <span class="n">RequestVoteResponse</span><span class="o">&amp;</span> <span class="n">response</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">BAIDU_SCOPED_LOCK</span><span class="p">(</span><span class="n">_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// check state，状态不对直接忽略，比如已成为leader
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">STATE_CANDIDATE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// check response term，response term更大则停止选举
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">term</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">_current_term</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">butil</span><span class="o">::</span><span class="n">Status</span> <span class="n">status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">status</span><span class="p">.</span><span class="n">set_error</span><span class="p">(</span><span class="n">EHIGHERTERMRESPONSE</span><span class="p">,</span> <span class="s">&#34;Raft node receives higher term &#34;</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;request_vote_response.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">step_down</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">term</span><span class="p">(),</span> <span class="nb">false</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">response</span><span class="p">.</span><span class="n">granted</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">response</span><span class="p">.</span><span class="n">rejected_by_lease</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">disrupted</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_vote_ctx</span><span class="p">.</span><span class="n">set_disrupted_leader</span><span class="p">(</span><span class="n">DisruptedLeader</span><span class="p">(</span><span class="n">peer_id</span><span class="p">,</span> <span class="n">response</span><span class="p">.</span><span class="n">previous_term</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">granted</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_vote_ctx</span><span class="p">.</span><span class="n">grant</span><span class="p">(</span><span class="n">peer_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">peer_id</span> <span class="o">==</span> <span class="n">_follower_lease</span><span class="p">.</span><span class="n">last_leader</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">_vote_ctx</span><span class="p">.</span><span class="n">grant</span><span class="p">(</span><span class="n">_server_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">_vote_ctx</span><span class="p">.</span><span class="n">stop_grant_self_timer</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果获得多数支持，成为leader
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">_vote_ctx</span><span class="p">.</span><span class="n">granted</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nf">become_leader</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// If the follower rejected the vote because of lease, reserve it, and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// the candidate will try again after it disrupt the old leader.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">_vote_ctx</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">peer_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 再次要求预留的peer投票
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">retry_vote_on_reserved_peers</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">NodeImpl</span><span class="o">::</span><span class="n">retry_vote_on_reserved_peers</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">PeerId</span><span class="o">&gt;</span> <span class="n">peers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">_vote_ctx</span><span class="p">.</span><span class="n">pop_grantable_peers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peers</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">peers</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">request_peers_to_vote</span><span class="p">(</span><span class="n">peers</span><span class="p">,</span> <span class="n">_vote_ctx</span><span class="p">.</span><span class="n">disrupted_leader</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="leader逻辑">leader逻辑</h2>
<h3 id="成为leader">成为leader</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">NodeImpl</span><span class="o">::</span><span class="n">become_leader</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 检查状态必须为候选者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">CHECK</span><span class="p">(</span><span class="n">_state</span> <span class="o">==</span> <span class="n">STATE_CANDIDATE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// cancel candidate vote timer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_vote_timer</span><span class="p">.</span><span class="n">stop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">_vote_ctx</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 修改状态和leader_id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_state</span> <span class="o">=</span> <span class="n">STATE_LEADER</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">_leader_id</span> <span class="o">=</span> <span class="n">_server_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">_replicator_group</span><span class="p">.</span><span class="n">reset_term</span><span class="p">(</span><span class="n">_current_term</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">_follower_lease</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">_leader_lease</span><span class="p">.</span><span class="n">on_leader_start</span><span class="p">(</span><span class="n">_current_term</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">PeerId</span><span class="o">&gt;</span> <span class="n">peers</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">_conf</span><span class="p">.</span><span class="n">list_peers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">peers</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 每个follower启动一个replicator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">PeerId</span><span class="o">&gt;::</span><span class="n">const_iterator</span>
</span></span><span class="line"><span class="cl">            <span class="n">iter</span> <span class="o">=</span> <span class="n">peers</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">peers</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">iter</span> <span class="o">==</span> <span class="n">_server_id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">_replicator_group</span><span class="p">.</span><span class="n">add_replicator</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// init commit manager
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_ballot_box</span><span class="o">-&gt;</span><span class="n">reset_pending_index</span><span class="p">(</span><span class="n">_log_manager</span><span class="o">-&gt;</span><span class="n">last_log_index</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Register _conf_ctx to reject configuration changing before the first log
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// is committed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">CHECK</span><span class="p">(</span><span class="o">!</span><span class="n">_conf_ctx</span><span class="p">.</span><span class="n">is_busy</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">_conf_ctx</span><span class="p">.</span><span class="n">flush</span><span class="p">(</span><span class="n">_conf</span><span class="p">.</span><span class="n">conf</span><span class="p">,</span> <span class="n">_conf</span><span class="p">.</span><span class="n">old_conf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">_stepdown_timer</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>根据Raft论文，新leader登基之后需要提交一个no-op日志才能安全的提交之前任期的日志。在braft的实现中， <code>_conf_ctx.flush(_conf.conf, _conf.old_conf)</code> 会发起一次节点更新，在节点更新的日志成功提交后回调用户状态机的 <code>on_leader_start</code> 。braft使用节点更新日志替代了论文中的no-op日志。</p>
<p>Replicator启动逻辑</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">Replicator</span><span class="o">::</span><span class="n">start</span><span class="p">(</span><span class="k">const</span> <span class="n">ReplicatorOptions</span><span class="o">&amp;</span> <span class="n">options</span><span class="p">,</span> <span class="n">ReplicatorId</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Replicator</span><span class="o">*</span> <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Replicator</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">brpc</span><span class="o">::</span><span class="n">ChannelOptions</span> <span class="n">channel_opt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//channel_opt.connect_timeout_ms = *options.heartbeat_timeout_ms;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">channel_opt</span><span class="p">.</span><span class="n">timeout_ms</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// We don&#39;t need RPC timeout
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 创建发送channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">_sending_channel</span><span class="p">.</span><span class="n">Init</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">peer_id</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">channel_opt</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span> <span class="o">=</span> <span class="n">options</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="o">-&gt;</span><span class="n">_next_index</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">log_manager</span><span class="o">-&gt;</span><span class="n">last_log_index</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 记录到bthread local存储
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">bthread_id_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">_id</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">_on_error</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">bthread_id_lock</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">_id</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="o">-&gt;</span><span class="n">_catchup_closure</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="o">-&gt;</span><span class="n">_update_last_rpc_send_timestamp</span><span class="p">(</span><span class="n">butil</span><span class="o">::</span><span class="n">monotonic_time_ms</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="o">-&gt;</span><span class="n">_start_heartbeat_timer</span><span class="p">(</span><span class="n">butil</span><span class="o">::</span><span class="n">gettimeofday_us</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Note: r-&gt;_id is unlock in _send_empty_entries, don&#39;t touch r ever after
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 发送no_op来宣示leader身份
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">r</span><span class="o">-&gt;</span><span class="n">_send_empty_entries</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="维护leader身份心跳">维护leader身份——心跳</h3>
<p>在Replicator::start里面开始了heartbeat_timer，它是个bthread_timer，在超时的时候会调用Replicator::_on_timedout，该函数会把对应的id设置为ETIMEDOUT。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Replicator</span><span class="o">::</span><span class="n">_on_timedout</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">bthread_id_t</span> <span class="n">id</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">arg</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">bthread_id_error</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">ETIMEDOUT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>bthread_id_error会去调用_on_error，然后开始_send_heartbeat。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">Replicator</span><span class="o">::</span><span class="n">_on_error</span><span class="p">(</span><span class="n">bthread_id_t</span> <span class="n">id</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error_code</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">error_code</span> <span class="o">==</span> <span class="n">ETIMEDOUT</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// This error is issued in the TimerThread, start a new bthread to avoid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// blocking the caller.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Unlock id to remove the context-switch out of the critical section
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">CHECK_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bthread_id_unlock</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Fail to unlock&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">bthread_t</span> <span class="n">tid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 启动一个bthread来执行_send_heartbeat
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">bthread_start_urgent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">_send_heartbeat</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                 <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">value</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">PLOG</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Fail to start bthread&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">_send_heartbeat</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">value</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>发送心跳</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="n">Replicator</span><span class="o">::</span><span class="n">_send_heartbeat</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Replicator</span><span class="o">*</span> <span class="n">r</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">bthread_id_t</span> <span class="n">id</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">arg</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 从bthread local存储获取replicator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">bthread_id_lock</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// This replicator is stopped
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// id is unlock in _send_empty_entries;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">r</span><span class="o">-&gt;</span><span class="n">_send_empty_entries</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Replicator</span><span class="o">::</span><span class="n">_send_empty_entries</span><span class="p">(</span><span class="kt">bool</span> <span class="n">is_heartbeat</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">brpc</span><span class="o">::</span><span class="n">Controller</span><span class="o">&gt;</span> <span class="n">cntl</span><span class="p">(</span><span class="k">new</span> <span class="n">brpc</span><span class="o">::</span><span class="n">Controller</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">AppendEntriesRequest</span><span class="o">&gt;</span> <span class="n">request</span><span class="p">(</span><span class="k">new</span> <span class="n">AppendEntriesRequest</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">AppendEntriesResponse</span><span class="o">&gt;</span> <span class="n">response</span><span class="p">(</span><span class="k">new</span> <span class="n">AppendEntriesResponse</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">_fill_common_fields</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="n">request</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">_next_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">is_heartbeat</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">CHECK</span><span class="p">(</span><span class="o">!</span><span class="n">is_heartbeat</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// _id is unlock in _install_snapshot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nf">_install_snapshot</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">is_heartbeat</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_heartbeat_in_fly</span> <span class="o">=</span> <span class="n">cntl</span><span class="o">-&gt;</span><span class="n">call_id</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">_heartbeat_counter</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// set RPC timeout for heartbeat, how long should timeout be is waiting to be optimized.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cntl</span><span class="o">-&gt;</span><span class="n">set_timeout_ms</span><span class="p">(</span><span class="o">*</span><span class="n">_options</span><span class="p">.</span><span class="n">election_timeout_ms</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_st</span><span class="p">.</span><span class="n">st</span> <span class="o">=</span> <span class="n">APPENDING_ENTRIES</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">_st</span><span class="p">.</span><span class="n">first_log_index</span> <span class="o">=</span> <span class="n">_next_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">_st</span><span class="p">.</span><span class="n">last_log_index</span> <span class="o">=</span> <span class="n">_next_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">CHECK</span><span class="p">(</span><span class="n">_append_entries_in_fly</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">CHECK_EQ</span><span class="p">(</span><span class="n">_flying_append_entries_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">_append_entries_in_fly</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">FlyingAppendEntriesRpc</span><span class="p">(</span><span class="n">_next_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cntl</span><span class="o">-&gt;</span><span class="n">call_id</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">        <span class="n">_append_entries_counter</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Closure</span><span class="o">*</span> <span class="n">done</span> <span class="o">=</span> <span class="n">brpc</span><span class="o">::</span><span class="n">NewCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="n">is_heartbeat</span> <span class="o">?</span> <span class="nl">_on_heartbeat_returned</span> <span class="p">:</span> <span class="n">_on_rpc_returned</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                <span class="n">_id</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">cntl</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">request</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">response</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                <span class="n">butil</span><span class="o">::</span><span class="n">monotonic_time_ms</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">RaftService_Stub</span> <span class="nf">stub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_sending_channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">stub</span><span class="p">.</span><span class="n">append_entries</span><span class="p">(</span><span class="n">cntl</span><span class="p">.</span><span class="n">release</span><span class="p">(),</span> <span class="n">request</span><span class="p">.</span><span class="n">release</span><span class="p">(),</span> 
</span></span><span class="line"><span class="cl">                        <span class="n">response</span><span class="p">.</span><span class="n">release</span><span class="p">(),</span> <span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">CHECK_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bthread_id_unlock</span><span class="p">(</span><span class="n">_id</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Fail to unlock &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>append_entries请求处理逻辑，既包括心跳处理，也包括正常的请求处理</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">NodeImpl</span><span class="o">::</span><span class="n">handle_append_entries_request</span><span class="p">(</span><span class="n">brpc</span><span class="o">::</span><span class="n">Controller</span><span class="o">*</span> <span class="n">cntl</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                             <span class="k">const</span> <span class="n">AppendEntriesRequest</span><span class="o">*</span> <span class="n">request</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                             <span class="n">AppendEntriesResponse</span><span class="o">*</span> <span class="n">response</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                             <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Closure</span><span class="o">*</span> <span class="n">done</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                             <span class="kt">bool</span> <span class="n">from_append_entries_cache</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LogEntry</span><span class="o">*&gt;</span> <span class="n">entries</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">entries</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">brpc</span><span class="o">::</span><span class="n">ClosureGuard</span> <span class="n">done_guard</span><span class="p">(</span><span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">raft_mutex_t</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// pre set term, to avoid get term in lock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_term</span><span class="p">(</span><span class="n">_current_term</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// check stale term
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 让已被篡位的leader下台
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">term</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">_current_term</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">saved_current_term</span> <span class="o">=</span> <span class="n">_current_term</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">lck</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_success</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_term</span><span class="p">(</span><span class="n">saved_current_term</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// check term and state to step down
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">check_step_down</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">term</span><span class="p">(),</span> <span class="n">server_id</span><span class="p">);</span>   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果有两个相同term的leader，自己的term加一让两个leader都下台
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">server_id</span> <span class="o">!=</span> <span class="n">_leader_id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Increase the term by 1 and make both leaders step down to minimize the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// loss of split brain
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">butil</span><span class="o">::</span><span class="n">Status</span> <span class="n">status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">status</span><span class="p">.</span><span class="n">set_error</span><span class="p">(</span><span class="n">ELEADERCONFLICT</span><span class="p">,</span> <span class="s">&#34;More than one leader in the same term.&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">        <span class="n">step_down</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">term</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_success</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_term</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">term</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">prev_log_index</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">prev_log_index</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">prev_log_term</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">prev_log_term</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">local_prev_log_term</span> <span class="o">=</span> <span class="n">_log_manager</span><span class="o">-&gt;</span><span class="n">get_term</span><span class="p">(</span><span class="n">prev_log_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果term不匹配，视是否允许乱序而报错或正常处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">local_prev_log_term</span> <span class="o">!=</span> <span class="n">prev_log_term</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 心跳请求处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_success</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_term</span><span class="p">(</span><span class="n">_current_term</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_last_log_index</span><span class="p">(</span><span class="n">_log_manager</span><span class="o">-&gt;</span><span class="n">last_log_index</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_readonly</span><span class="p">(</span><span class="n">_node_readonly</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">lck</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// see the comments at FollowerStableClosure::run()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">_ballot_box</span><span class="o">-&gt;</span><span class="n">set_last_committed_index</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">committed_index</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                         <span class="n">prev_log_index</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Parse request
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">butil</span><span class="o">::</span><span class="n">IOBuf</span> <span class="n">data_buf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">data_buf</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">cntl</span><span class="o">-&gt;</span><span class="n">request_attachment</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int64_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">prev_log_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">index</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">EntryMeta</span><span class="o">&amp;</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">ENTRY_TYPE_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">LogEntry</span><span class="o">*</span> <span class="n">log_entry</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LogEntry</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">log_entry</span><span class="o">-&gt;</span><span class="n">AddRef</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">log_entry</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">term</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">term</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">log_entry</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">log_entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="p">(</span><span class="n">EntryType</span><span class="p">)</span><span class="n">entry</span><span class="p">.</span><span class="n">type</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果请求中peer不为空，也设置log_entry的peer/old_peer字段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">CHECK_NE</span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">type</span><span class="p">(),</span> <span class="n">ENTRY_TYPE_CONFIGURATION</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">has_data_len</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">data_len</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">                <span class="n">data_buf</span><span class="p">.</span><span class="n">cutn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log_entry</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">entries</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">log_entry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// check out-of-order cache
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">check_append_entries_cache</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">FollowerStableClosure</span><span class="o">*</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FollowerStableClosure</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">cntl</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">done_guard</span><span class="p">.</span><span class="n">release</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">            <span class="k">this</span><span class="p">,</span> <span class="n">_current_term</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 写入log，在回调中进行回包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_log_manager</span><span class="o">-&gt;</span><span class="n">append_entries</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entries</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// update configuration after _log_manager updated its memory status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_log_manager</span><span class="o">-&gt;</span><span class="n">check_and_set_configuration</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_conf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>心跳回包处理逻辑</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Replicator</span><span class="o">::</span><span class="n">_on_heartbeat_returned</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">ReplicatorId</span> <span class="n">id</span><span class="p">,</span> <span class="n">brpc</span><span class="o">::</span><span class="n">Controller</span><span class="o">*</span> <span class="n">cntl</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">AppendEntriesRequest</span><span class="o">*</span> <span class="n">request</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">        <span class="n">AppendEntriesResponse</span><span class="o">*</span> <span class="n">response</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int64_t</span> <span class="n">rpc_send_time</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">brpc</span><span class="o">::</span><span class="n">Controller</span><span class="o">&gt;</span> <span class="n">cntl_guard</span><span class="p">(</span><span class="n">cntl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">AppendEntriesRequest</span><span class="o">&gt;</span>  <span class="n">req_guard</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">AppendEntriesResponse</span><span class="o">&gt;</span> <span class="n">res_guard</span><span class="p">(</span><span class="n">response</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Replicator</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">bthread_id_t</span> <span class="n">dummy_id</span> <span class="o">=</span> <span class="p">{</span> <span class="n">id</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">long</span> <span class="n">start_time_us</span> <span class="o">=</span> <span class="n">butil</span><span class="o">::</span><span class="n">gettimeofday_us</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// XXX bthread_id大概相当于pthread key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">bthread_id_lock</span><span class="p">(</span><span class="n">dummy_id</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">cntl</span><span class="o">-&gt;</span><span class="n">Failed</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果失败则再次启动定时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">r</span><span class="o">-&gt;</span><span class="n">_start_heartbeat_timer</span><span class="p">(</span><span class="n">start_time_us</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">CHECK_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bthread_id_unlock</span><span class="p">(</span><span class="n">dummy_id</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Fail to unlock &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">dummy_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="o">-&gt;</span><span class="n">_consecutive_error_times</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果心跳收到更高的term，则退位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">term</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">term</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">NodeImpl</span> <span class="o">*</span><span class="n">node_impl</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Acquire a reference of Node here in case that Node is detroyed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// after _notify_on_caught_up.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">node_impl</span><span class="o">-&gt;</span><span class="n">AddRef</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">r</span><span class="o">-&gt;</span><span class="n">_notify_on_caught_up</span><span class="p">(</span><span class="n">EPERM</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">LOG</span><span class="p">(</span><span class="n">INFO</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Replicator=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">dummy_id</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; is going to quit&#34;</span>
</span></span><span class="line"><span class="cl">                  <span class="o">&lt;&lt;</span> <span class="s">&#34;, group &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">group_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">butil</span><span class="o">::</span><span class="n">Status</span> <span class="n">status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">status</span><span class="p">.</span><span class="n">set_error</span><span class="p">(</span><span class="n">EHIGHERTERMRESPONSE</span><span class="p">,</span> <span class="s">&#34;Leader receives higher term &#34;</span>
</span></span><span class="line"><span class="cl">                <span class="s">&#34;heartbeat_response from peer:%s&#34;</span><span class="p">,</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">peer_id</span><span class="p">.</span><span class="n">to_string</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">r</span><span class="o">-&gt;</span><span class="n">_destroy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">node_impl</span><span class="o">-&gt;</span><span class="n">increase_term_to</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">term</span><span class="p">(),</span> <span class="n">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">node_impl</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">readonly</span> <span class="o">=</span> <span class="n">response</span><span class="o">-&gt;</span><span class="n">has_readonly</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">response</span><span class="o">-&gt;</span><span class="n">readonly</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">BRAFT_VLOG</span> <span class="o">&lt;&lt;</span> <span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; readonly &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">readonly</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="o">-&gt;</span><span class="n">_update_last_rpc_send_timestamp</span><span class="p">(</span><span class="n">rpc_send_time</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="o">-&gt;</span><span class="n">_start_heartbeat_timer</span><span class="p">(</span><span class="n">start_time_us</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">NodeImpl</span><span class="o">*</span> <span class="n">node_impl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Check if readonly config changed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">readonly</span> <span class="o">&amp;&amp;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_readonly_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="o">!</span><span class="n">readonly</span> <span class="o">&amp;&amp;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_readonly_index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">node_impl</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">node_impl</span><span class="o">-&gt;</span><span class="n">AddRef</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node_impl</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">CHECK_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bthread_id_unlock</span><span class="p">(</span><span class="n">dummy_id</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Fail to unlock &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">dummy_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">PeerId</span> <span class="n">peer_id</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">peer_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int64_t</span> <span class="n">term</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">term</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">CHECK_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bthread_id_unlock</span><span class="p">(</span><span class="n">dummy_id</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Fail to unlock &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">dummy_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">node_impl</span><span class="o">-&gt;</span><span class="n">change_readonly_config</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">peer_id</span><span class="p">,</span> <span class="n">readonly</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">node_impl</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="状态机任务执行">状态机任务执行</h2>
<p>用户代码会调用<code>NodeImpl::apply(const Task&amp; task)</code>，apply的实现中将任务加入<code>_apply_queue</code>队列。队列执行时最终会调用下面的函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">NodeImpl</span><span class="o">::</span><span class="n">apply</span><span class="p">(</span><span class="n">LogEntryAndClosure</span> <span class="n">tasks</span><span class="p">[],</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">g_apply_tasks_batch_counter</span> <span class="o">&lt;&lt;</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LogEntry</span><span class="o">*&gt;</span> <span class="n">entries</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">entries</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">raft_mutex_t</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">reject_new_user_logs</span> <span class="o">=</span> <span class="p">(</span><span class="n">_node_readonly</span> <span class="o">||</span> <span class="n">_majority_nodes_readonly</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">STATE_LEADER</span> <span class="o">||</span> <span class="n">reject_new_user_logs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 非leader或只读时设置错误，并回调用户的done
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">st</span><span class="p">.</span><span class="n">set_error</span><span class="p">(</span><span class="n">EPERM</span><span class="p">,</span> <span class="s">&#34;is not leader&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">done</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">()</span> <span class="o">=</span> <span class="n">st</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">run_closure_in_bthread</span><span class="p">(</span><span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 检查ABA问题，有问题会设置错误和调用done
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">expected_term</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">expected_term</span> <span class="o">!=</span> <span class="n">_current_term</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">entries</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">entry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">entries</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">term</span> <span class="o">=</span> <span class="n">_current_term</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">entries</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">ENTRY_TYPE_DATA</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 加入投票箱
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">_ballot_box</span><span class="o">-&gt;</span><span class="n">append_pending_task</span><span class="p">(</span><span class="n">_conf</span><span class="p">.</span><span class="n">conf</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                         <span class="n">_conf</span><span class="p">.</span><span class="n">stable</span><span class="p">()</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">_conf</span><span class="p">.</span><span class="n">old_conf</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                         <span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// LeaderStableClosure在回调时会投票
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_log_manager</span><span class="o">-&gt;</span><span class="n">append_entries</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entries</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                               <span class="k">new</span> <span class="n">LeaderStableClosure</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                                        <span class="n">NodeId</span><span class="p">(</span><span class="n">_group_id</span><span class="p">,</span> <span class="n">_server_id</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                                        <span class="n">entries</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                                        <span class="n">_ballot_box</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// update _conf.first
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_log_manager</span><span class="o">-&gt;</span><span class="n">check_and_set_configuration</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_conf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="log持久化">log持久化</h3>
<p>无论是leader还是follower都是调用LogManager来持久化日志，对于leader来说，持久化完成后进行投票；对于follower来说，持久化完成后回包。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">LogManager</span><span class="o">::</span><span class="n">append_entries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LogEntry</span><span class="o">*&gt;</span> <span class="o">*</span><span class="n">entries</span><span class="p">,</span> <span class="n">StableClosure</span><span class="o">*</span> <span class="n">done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">raft_mutex_t</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 检查是否存在冲突
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entries</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">check_and_resolve_conflict</span><span class="p">(</span><span class="n">entries</span><span class="p">,</span> <span class="n">done</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">lck</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// release entries
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">entries</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="o">*</span><span class="n">entries</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">entries</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">entries</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Add ref for disk_thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">(</span><span class="o">*</span><span class="n">entries</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">AddRef</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">entries</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ENTRY_TYPE_CONFIGURATION</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ConfigurationEntry</span> <span class="nf">conf_entry</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="n">entries</span><span class="p">)[</span><span class="n">i</span><span class="p">]));</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 对于修改peer的类型的日志，加入config manager，影响后续的投票。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">_config_manager</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">conf_entry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entries</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">done</span><span class="o">-&gt;</span><span class="n">_first_log_index</span> <span class="o">=</span> <span class="n">entries</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 插入内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">_logs_in_memory</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">_logs_in_memory</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">entries</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span> <span class="n">entries</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">done</span><span class="o">-&gt;</span><span class="n">_entries</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">entries</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 刷盘
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">bthread</span><span class="o">::</span><span class="n">execution_queue_execute</span><span class="p">(</span><span class="n">_disk_queue</span><span class="p">,</span> <span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">CHECK_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;execq execute failed, ret: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; err: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">berror</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">wakeup_all_waiter</span><span class="p">(</span><span class="n">lck</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">LogManager</span><span class="o">::</span><span class="n">check_and_resolve_conflict</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LogEntry</span><span class="o">*&gt;</span> <span class="o">*</span><span class="n">entries</span><span class="p">,</span> <span class="n">StableClosure</span><span class="o">*</span> <span class="n">done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">AsyncClosureGuard</span> <span class="nf">done_guard</span><span class="p">(</span><span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">entries</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 某些情况下leader会设置index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Node is currently the leader and |entries| are from the user who
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// don&#39;t know the correct indexes the logs should assign to. So we have
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// to assign indexes to the appending entries
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">entries</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="o">*</span><span class="n">entries</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="o">++</span><span class="n">_last_log_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">done_guard</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// follower逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Node is currently a follower and |entries| are from the leader. We 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// should check and resolve the confliction between the local logs and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// |entries|
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 日志不连续性，报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">entries</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">_last_log_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">done</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">().</span><span class="n">set_error</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">,</span> <span class="s">&#34;There&#39;s gap between first_index=%&#34;</span> <span class="n">PRId64</span>
</span></span><span class="line"><span class="cl">                                     <span class="s">&#34; and last_log_index=%&#34;</span> <span class="n">PRId64</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                     <span class="n">entries</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">index</span><span class="p">,</span> <span class="n">_last_log_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">applied_index</span> <span class="o">=</span> <span class="n">_applied_id</span><span class="p">.</span><span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果最后一条日志已经apply过，直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">entries</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">applied_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">entries</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">index</span> <span class="o">==</span> <span class="n">_last_log_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 第一条日志正好对上，只需要更新_last_log_index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// Fast path
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">_last_log_index</span> <span class="o">=</span> <span class="n">entries</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Appending entries overlap the local ones. We should find if there
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// is a conflicting index from which we should truncate the local
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// ones.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 找到第一个冲突的日志index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">size_t</span> <span class="n">conflicting_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="p">(;</span> <span class="n">conflicting_index</span> <span class="o">&lt;</span> <span class="n">entries</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">conflicting_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">unsafe_get_term</span><span class="p">((</span><span class="o">*</span><span class="n">entries</span><span class="p">)[</span><span class="n">conflicting_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">index</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="o">!=</span> <span class="p">(</span><span class="o">*</span><span class="n">entries</span><span class="p">)[</span><span class="n">conflicting_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">term</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 如果存在冲突
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">conflicting_index</span> <span class="o">!=</span> <span class="n">entries</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">entries</span><span class="p">)[</span><span class="n">conflicting_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">_last_log_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// Truncate all the conflicting entries to make local logs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// consensus with the leader.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// truncate日志
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">unsafe_truncate_suffix</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                            <span class="p">(</span><span class="o">*</span><span class="n">entries</span><span class="p">)[</span><span class="n">conflicting_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="n">_last_log_index</span> <span class="o">=</span> <span class="n">entries</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>  <span class="c1">// else this is a duplicated AppendEntriesRequest, we have 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>               <span class="c1">// nothing to do besides releasing all the entries
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            
</span></span><span class="line"><span class="cl">            <span class="c1">// Release all the entries before the conflicting_index and the rest
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// would be append to _logs_in_memory and _log_storage after this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// function returns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">conflicting_index</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="p">(</span><span class="o">*</span><span class="n">entries</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 不冲突的日志直接移除，已经持久化过了。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">entries</span><span class="o">-&gt;</span><span class="n">erase</span><span class="p">(</span><span class="n">entries</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span> 
</span></span><span class="line"><span class="cl">                           <span class="n">entries</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">conflicting_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">done_guard</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">CHECK</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Can&#39;t reach here&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">done</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">().</span><span class="n">set_error</span><span class="p">(</span><span class="n">EIO</span><span class="p">,</span> <span class="s">&#34;Impossible&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>日志刷盘</p>
<p>在LogManager的构造函数中创建了一个执行队列。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">LogManager</span><span class="o">::</span><span class="n">start_disk_thread</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">bthread</span><span class="o">::</span><span class="n">ExecutionQueueOptions</span> <span class="n">queue_options</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">queue_options</span><span class="p">.</span><span class="n">bthread_attr</span> <span class="o">=</span> <span class="n">BTHREAD_ATTR_NORMAL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">bthread</span><span class="o">::</span><span class="n">execution_queue_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_disk_queue</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                   <span class="o">&amp;</span><span class="n">queue_options</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                   <span class="n">disk_thread</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                   <span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>disk_thread是负责刷盘的函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">LogManager</span><span class="o">::</span><span class="n">disk_thread</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">meta</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="n">bthread</span><span class="o">::</span><span class="n">TaskIterator</span><span class="o">&lt;</span><span class="n">StableClosure</span><span class="o">*&gt;&amp;</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">is_queue_stopped</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">LogManager</span><span class="o">*</span> <span class="n">log_manager</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">LogManager</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">meta</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// FIXME(chenzhangyi01): it&#39;s buggy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">LogId</span> <span class="n">last_id</span> <span class="o">=</span> <span class="n">log_manager</span><span class="o">-&gt;</span><span class="n">_disk_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">StableClosure</span><span class="o">*</span> <span class="n">storage</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">AppendBatcher</span> <span class="nf">ab</span><span class="p">(</span><span class="n">storage</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">storage</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">last_id</span><span class="p">,</span> <span class="n">log_manager</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(;</span> <span class="n">iter</span><span class="p">;</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// ^^^ Must iterate to the end to release to corresponding
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">//     even if some error has occurred
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">StableClosure</span><span class="o">*</span> <span class="n">done</span> <span class="o">=</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="o">-&gt;</span><span class="n">_entries</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 组batch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">ab</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 刷盘
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">ab</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 日志项为空的任务，是一些管理类的任务。如LastLogIdClosure, TruncatePrefixClosure, TruncateSuffixClosure, ResetClosure
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">TruncatePrefixClosure</span><span class="o">*</span> <span class="n">tpc</span> <span class="o">=</span> 
</span></span><span class="line"><span class="cl">                        <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">TruncatePrefixClosure</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">tpc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">ret</span> <span class="o">=</span> <span class="n">log_manager</span><span class="o">-&gt;</span><span class="n">_log_storage</span><span class="o">-&gt;</span><span class="n">truncate_prefix</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">tpc</span><span class="o">-&gt;</span><span class="n">first_index_kept</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// 命中一种即退出循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">log_manager</span><span class="o">-&gt;</span><span class="n">report_error</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="s">&#34;Failed operation on LogStorage&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">done</span><span class="o">-&gt;</span><span class="n">Run</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">CHECK</span><span class="p">(</span><span class="o">!</span><span class="n">iter</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Must iterate to the end&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ab</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">log_manager</span><span class="o">-&gt;</span><span class="n">set_disk_id</span><span class="p">(</span><span class="n">last_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面AppendBatcher::append会将日志加入队列，AppendBatcher::flush会调用LogManager::append_to_storage来写盘。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">LogManager</span><span class="o">::</span><span class="n">append_to_storage</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LogEntry</span><span class="o">*&gt;*</span> <span class="n">to_append</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                                   <span class="n">LogId</span><span class="o">*</span> <span class="n">last_id</span><span class="p">,</span> <span class="n">IOMetric</span><span class="o">*</span> <span class="n">metric</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_has_error</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">butil</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 调用底层存储实现，默认为SegmentLogStorage
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">nappent</span> <span class="o">=</span> <span class="n">_log_storage</span><span class="o">-&gt;</span><span class="n">append_entries</span><span class="p">(</span><span class="o">*</span><span class="n">to_append</span><span class="p">,</span> <span class="n">metric</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">nappent</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">to_append</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">report_error</span><span class="p">(</span><span class="n">EIO</span><span class="p">,</span> <span class="s">&#34;Fail to append entries&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">to_append</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="o">*</span><span class="n">to_append</span><span class="p">)[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">to_append</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="同步follower">同步follower</h3>
<p>_send_entries 负责同步task到follower。在apply_task时会将任务写到log_manager里面，而在_send_entries实现中，会调用_prepare_entry来从log_manager获取entry。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Replicator</span><span class="o">::</span><span class="n">_send_entries</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">brpc</span><span class="o">::</span><span class="n">Controller</span><span class="o">&gt;</span> <span class="n">cntl</span><span class="p">(</span><span class="k">new</span> <span class="n">brpc</span><span class="o">::</span><span class="n">Controller</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">AppendEntriesRequest</span><span class="o">&gt;</span> <span class="n">request</span><span class="p">(</span><span class="k">new</span> <span class="n">AppendEntriesRequest</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">AppendEntriesResponse</span><span class="o">&gt;</span> <span class="n">response</span><span class="p">(</span><span class="k">new</span> <span class="n">AppendEntriesResponse</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">_fill_common_fields</span><span class="p">(</span><span class="n">request</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">_next_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_reset_next_index</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">_install_snapshot</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">EntryMeta</span> <span class="n">em</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int</span> <span class="n">max_entries_size</span> <span class="o">=</span> <span class="n">FLAGS_raft_max_entries_size</span> <span class="o">-</span> <span class="n">_flying_append_entries_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">prepare_entry_rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">CHECK_GT</span><span class="p">(</span><span class="n">max_entries_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_entries_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 从log_manager来准备entry
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">prepare_entry_rc</span> <span class="o">=</span> <span class="n">_prepare_entry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cntl</span><span class="o">-&gt;</span><span class="n">request_attachment</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">prepare_entry_rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">request</span><span class="o">-&gt;</span><span class="n">add_entries</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// _id is unlock in _wait_more
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">_next_index</span> <span class="o">&lt;</span> <span class="n">_options</span><span class="p">.</span><span class="n">log_manager</span><span class="o">-&gt;</span><span class="n">first_log_index</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">_reset_next_index</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nf">_install_snapshot</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">_wait_more_entries</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">_append_entries_in_fly</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">FlyingAppendEntriesRpc</span><span class="p">(</span><span class="n">_next_index</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                     <span class="n">request</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">(),</span> <span class="n">cntl</span><span class="o">-&gt;</span><span class="n">call_id</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">    <span class="n">_append_entries_counter</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">_next_index</span> <span class="o">+=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">_flying_append_entries_size</span> <span class="o">+=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">g_send_entries_batch_counter</span> <span class="o">&lt;&lt;</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">_st</span><span class="p">.</span><span class="n">st</span> <span class="o">=</span> <span class="n">APPENDING_ENTRIES</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">_st</span><span class="p">.</span><span class="n">first_log_index</span> <span class="o">=</span> <span class="n">_min_flying_index</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">_st</span><span class="p">.</span><span class="n">last_log_index</span> <span class="o">=</span> <span class="n">_next_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Closure</span><span class="o">*</span> <span class="n">done</span> <span class="o">=</span> <span class="n">brpc</span><span class="o">::</span><span class="n">NewCallback</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="n">_on_rpc_returned</span><span class="p">,</span> <span class="n">_id</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">cntl</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> 
</span></span><span class="line"><span class="cl">                <span class="n">request</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">response</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">butil</span><span class="o">::</span><span class="n">monotonic_time_ms</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">RaftService_Stub</span> <span class="nf">stub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_sending_channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">stub</span><span class="p">.</span><span class="n">append_entries</span><span class="p">(</span><span class="n">cntl</span><span class="p">.</span><span class="n">release</span><span class="p">(),</span> <span class="n">request</span><span class="p">.</span><span class="n">release</span><span class="p">(),</span> 
</span></span><span class="line"><span class="cl">                        <span class="n">response</span><span class="p">.</span><span class="n">release</span><span class="p">(),</span> <span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">_wait_more_entries</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>send_entries结果处理</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Replicator</span><span class="o">::</span><span class="n">_on_rpc_returned</span><span class="p">(</span><span class="n">ReplicatorId</span> <span class="n">id</span><span class="p">,</span> <span class="n">brpc</span><span class="o">::</span><span class="n">Controller</span><span class="o">*</span> <span class="n">cntl</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="n">AppendEntriesRequest</span><span class="o">*</span> <span class="n">request</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                     <span class="n">AppendEntriesResponse</span><span class="o">*</span> <span class="n">response</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                     <span class="kt">int64_t</span> <span class="n">rpc_send_time</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">brpc</span><span class="o">::</span><span class="n">Controller</span><span class="o">&gt;</span> <span class="n">cntl_guard</span><span class="p">(</span><span class="n">cntl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">AppendEntriesRequest</span><span class="o">&gt;</span>  <span class="n">req_guard</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">AppendEntriesResponse</span><span class="o">&gt;</span> <span class="n">res_guard</span><span class="p">(</span><span class="n">response</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Replicator</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">bthread_id_t</span> <span class="n">dummy_id</span> <span class="o">=</span> <span class="p">{</span> <span class="n">id</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">long</span> <span class="n">start_time_us</span> <span class="o">=</span> <span class="n">butil</span><span class="o">::</span><span class="n">gettimeofday_us</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">valid_rpc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int64_t</span> <span class="n">rpc_first_index</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">prev_log_index</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int64_t</span> <span class="n">min_flying_index</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_min_flying_index</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">CHECK_GT</span><span class="p">(</span><span class="n">min_flying_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 省略校验call_id是否匹配的逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">cntl</span><span class="o">-&gt;</span><span class="n">Failed</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; fail, sleep.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">BRAFT_VLOG</span> <span class="o">&lt;&lt;</span> <span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// If the follower crashes, any RPC to the follower fails immediately,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// so we need to block the follower for a while instead of looping until
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// it comes back or be removed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// dummy_id is unlock in block
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">r</span><span class="o">-&gt;</span><span class="n">_reset_next_index</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 失败了block一段时间，有可能follower crash
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_block</span><span class="p">(</span><span class="n">start_time_us</span><span class="p">,</span> <span class="n">cntl</span><span class="o">-&gt;</span><span class="n">ErrorCode</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="o">-&gt;</span><span class="n">_consecutive_error_times</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">success</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果响应中的term更大则退位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">term</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">term</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">NodeImpl</span> <span class="o">*</span><span class="n">node_impl</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">butil</span><span class="o">::</span><span class="n">Status</span> <span class="n">status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">status</span><span class="p">.</span><span class="n">set_error</span><span class="p">(</span><span class="n">EHIGHERTERMRESPONSE</span><span class="p">,</span> <span class="s">&#34;Leader receives higher term &#34;</span>
</span></span><span class="line"><span class="cl">                    <span class="s">&#34;%s from peer:%s&#34;</span><span class="p">,</span> <span class="n">response</span><span class="o">-&gt;</span><span class="n">GetTypeName</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">peer_id</span><span class="p">.</span><span class="n">to_string</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">node_impl</span><span class="o">-&gt;</span><span class="n">increase_term_to</span><span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">term</span><span class="p">(),</span> <span class="n">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">node_impl</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// prev_log_index and prev_log_term doesn&#39;t match
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">r</span><span class="o">-&gt;</span><span class="n">_reset_next_index</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// log index 不匹配则直接设置next_index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">last_log_index</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_next_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// The peer contains less logs than leader
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">r</span><span class="o">-&gt;</span><span class="n">_next_index</span> <span class="o">=</span> <span class="n">response</span><span class="o">-&gt;</span><span class="n">last_log_index</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">            <span class="c1">// 否则依次减1直到匹配(XXX 看下面的实现不是term不匹配导致的，那什么情况会走到这个逻辑？）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// The peer contains logs from old term which should be truncated,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// decrease _last_log_at_peer by one to test the right index to keep
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">BAIDU_LIKELY</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">_next_index</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="o">--</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">_next_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">LOG</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Group &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">group_id</span> 
</span></span><span class="line"><span class="cl">                           <span class="o">&lt;&lt;</span> <span class="s">&#34; peer=&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">peer_id</span>
</span></span><span class="line"><span class="cl">                           <span class="o">&lt;&lt;</span> <span class="s">&#34; declares that log at index=0 doesn&#39;t match,&#34;</span>
</span></span><span class="line"><span class="cl">                              <span class="s">&#34; which is not supposed to happen&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// dummy_id is unlock in _send_heartbeat
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 用于更新log index信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">r</span><span class="o">-&gt;</span><span class="n">_send_empty_entries</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; success&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">BRAFT_VLOG</span> <span class="o">&lt;&lt;</span> <span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">response</span><span class="o">-&gt;</span><span class="n">term</span><span class="p">()</span> <span class="o">!=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">term</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">r</span><span class="o">-&gt;</span><span class="n">_reset_next_index</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">CHECK_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bthread_id_unlock</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">_id</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Fail to unlock &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="o">-&gt;</span><span class="n">_update_last_rpc_send_timestamp</span><span class="p">(</span><span class="n">rpc_send_time</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int</span> <span class="n">entries_size</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">entries_size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">rpc_last_log_index</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">prev_log_index</span><span class="p">()</span> <span class="o">+</span> <span class="n">entries_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">BRAFT_VLOG_IF</span><span class="p">(</span><span class="n">entries_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Group &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">group_id</span>
</span></span><span class="line"><span class="cl">                                    <span class="o">&lt;&lt;</span> <span class="s">&#34; replicated logs in [&#34;</span> 
</span></span><span class="line"><span class="cl">                                    <span class="o">&lt;&lt;</span> <span class="n">min_flying_index</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span> 
</span></span><span class="line"><span class="cl">                                    <span class="o">&lt;&lt;</span> <span class="n">rpc_last_log_index</span>
</span></span><span class="line"><span class="cl">                                    <span class="o">&lt;&lt;</span> <span class="s">&#34;] to peer &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">peer_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">entries_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 检查是否通过投票
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">ballot_box</span><span class="o">-&gt;</span><span class="n">commit_at</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="n">min_flying_index</span><span class="p">,</span> <span class="n">rpc_last_log_index</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">peer_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// A rpc is marked as success, means all request before it are success,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// erase them sequentially.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">_append_entries_in_fly</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">           <span class="n">r</span><span class="o">-&gt;</span><span class="n">_append_entries_in_fly</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">log_index</span> <span class="o">&lt;=</span> <span class="n">rpc_first_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">r</span><span class="o">-&gt;</span><span class="n">_flying_append_entries_size</span> <span class="o">-=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_append_entries_in_fly</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">entries_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">r</span><span class="o">-&gt;</span><span class="n">_append_entries_in_fly</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="o">-&gt;</span><span class="n">_has_succeeded</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="o">-&gt;</span><span class="n">_notify_on_caught_up</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// dummy_id is unlock in _send_entries
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">_timeout_now_index</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_timeout_now_index</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_min_flying_index</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">r</span><span class="o">-&gt;</span><span class="n">_send_timeout_now</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 再次调用send
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">r</span><span class="o">-&gt;</span><span class="n">_send_entries</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="apply_log">apply_log</h3>
<p>在log被持久化到多数节点上时，BallotBox::commit_at会调用下列函数向队列添加COMMITED任务。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">FSMCaller</span><span class="o">::</span><span class="n">on_committed</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">committed_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ApplyTask</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">COMMITTED</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">t</span><span class="p">.</span><span class="n">committed_index</span> <span class="o">=</span> <span class="n">committed_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">bthread</span><span class="o">::</span><span class="n">execution_queue_execute</span><span class="p">(</span><span class="n">_queue_id</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>队列执行函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">FSMCaller</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">meta</span><span class="p">,</span> <span class="n">bthread</span><span class="o">::</span><span class="n">TaskIterator</span><span class="o">&lt;</span><span class="n">ApplyTask</span><span class="o">&gt;&amp;</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">FSMCaller</span><span class="o">*</span> <span class="n">caller</span> <span class="o">=</span> <span class="p">(</span><span class="n">FSMCaller</span><span class="o">*</span><span class="p">)</span><span class="n">meta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">is_queue_stopped</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">caller</span><span class="o">-&gt;</span><span class="n">do_shutdown</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int64_t</span> <span class="n">max_committed_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int64_t</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span>  <span class="n">batch_size</span> <span class="o">=</span> <span class="n">FLAGS_raft_fsm_caller_commit_batch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(;</span> <span class="n">iter</span><span class="p">;</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">COMMITTED</span> <span class="o">&amp;&amp;</span> <span class="n">counter</span> <span class="o">&lt;</span> <span class="n">batch_size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">committed_index</span> <span class="o">&gt;</span> <span class="n">max_committed_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">max_committed_index</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">committed_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">max_committed_index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">caller</span><span class="o">-&gt;</span><span class="n">_cur_task</span> <span class="o">=</span> <span class="n">COMMITTED</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 出现连续的COMMITED任务超过commit_batch，或者出现了别的类型的任务时调用do_committed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">caller</span><span class="o">-&gt;</span><span class="n">do_committed</span><span class="p">(</span><span class="n">max_committed_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">max_committed_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">g_commit_tasks_batch_counter</span> <span class="o">&lt;&lt;</span> <span class="n">counter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">batch_size</span> <span class="o">=</span> <span class="n">FLAGS_raft_fsm_caller_commit_batch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">switch</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="nl">COMMITTED</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">committed_index</span> <span class="o">&gt;</span> <span class="n">max_committed_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">max_committed_index</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">committed_index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="nl">SNAPSHOT_SAVE</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>do_commited实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">FSMCaller</span><span class="o">::</span><span class="n">do_committed</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">committed_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_error</span><span class="p">.</span><span class="n">status</span><span class="p">().</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int64_t</span> <span class="n">last_applied_index</span> <span class="o">=</span> <span class="n">_last_applied_index</span><span class="p">.</span><span class="n">load</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                                        <span class="n">butil</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// We can tolerate the disorder of committed_index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">last_applied_index</span> <span class="o">&gt;=</span> <span class="n">committed_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Closure</span><span class="o">*&gt;</span> <span class="n">closure</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int64_t</span> <span class="n">first_closure_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">CHECK_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_closure_queue</span><span class="o">-&gt;</span><span class="n">pop_closure_until</span><span class="p">(</span><span class="n">committed_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">closure</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                                  <span class="o">&amp;</span><span class="n">first_closure_index</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">IteratorImpl</span> <span class="nf">iter_impl</span><span class="p">(</span><span class="n">_fsm</span><span class="p">,</span> <span class="n">_log_manager</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">closure</span><span class="p">,</span> <span class="n">first_closure_index</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                 <span class="n">last_applied_index</span><span class="p">,</span> <span class="n">committed_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">_applying_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(;</span> <span class="n">iter_impl</span><span class="p">.</span><span class="n">is_good</span><span class="p">();)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">iter_impl</span><span class="p">.</span><span class="n">entry</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ENTRY_TYPE_DATA</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 配置变更
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">iter_impl</span><span class="p">.</span><span class="n">entry</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ENTRY_TYPE_CONFIGURATION</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">iter_impl</span><span class="p">.</span><span class="n">entry</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">old_peers</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// Joint stage is not supposed to be noticeable by end users.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">_fsm</span><span class="o">-&gt;</span><span class="n">on_configuration_committed</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                            <span class="n">Configuration</span><span class="p">(</span><span class="o">*</span><span class="n">iter_impl</span><span class="p">.</span><span class="n">entry</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">peers</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                            <span class="n">iter_impl</span><span class="p">.</span><span class="n">entry</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 其他任务执行回调
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// For other entries, we have nothing to do besides flush the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// pending tasks and run this closure to notify the caller that the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// entries before this one were successfully committed and applied.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">iter_impl</span><span class="p">.</span><span class="n">done</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">iter_impl</span><span class="p">.</span><span class="n">done</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Run</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">iter_impl</span><span class="p">.</span><span class="n">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">Iterator</span> <span class="nf">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iter_impl</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 执行用户逻辑来apply
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">_fsm</span><span class="o">-&gt;</span><span class="n">on_apply</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Try move to next in case that we pass the same log twice.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">iter_impl</span><span class="p">.</span><span class="n">has_error</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">set_error</span><span class="p">(</span><span class="n">iter_impl</span><span class="p">.</span><span class="n">error</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">iter_impl</span><span class="p">.</span><span class="n">run_the_rest_closure_with_error</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">last_index</span> <span class="o">=</span> <span class="n">iter_impl</span><span class="p">.</span><span class="n">index</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">last_term</span> <span class="o">=</span> <span class="n">_log_manager</span><span class="o">-&gt;</span><span class="n">get_term</span><span class="p">(</span><span class="n">last_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">LogId</span> <span class="nf">last_applied_id</span><span class="p">(</span><span class="n">last_index</span><span class="p">,</span> <span class="n">last_term</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 记录applied index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_last_applied_index</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">committed_index</span><span class="p">,</span> <span class="n">butil</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">_last_applied_term</span> <span class="o">=</span> <span class="n">last_term</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 注意：applied index并没有持久化保存，只在内存中保存。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_log_manager</span><span class="o">-&gt;</span><span class="n">set_applied_id</span><span class="p">(</span><span class="n">last_applied_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="节点更新">节点更新</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">NodeImpl</span><span class="o">::</span><span class="n">unsafe_register_conf_change</span><span class="p">(</span><span class="k">const</span> <span class="n">Configuration</span><span class="o">&amp;</span> <span class="n">old_conf</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                           <span class="k">const</span> <span class="n">Configuration</span><span class="o">&amp;</span> <span class="n">new_conf</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                           <span class="n">Closure</span><span class="o">*</span> <span class="n">done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 非leader报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">STATE_LEADER</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">_state</span> <span class="o">==</span> <span class="n">STATE_TRANSFERRING</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">done</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">().</span><span class="n">set_error</span><span class="p">(</span><span class="n">EBUSY</span><span class="p">,</span> <span class="s">&#34;Is transferring leadership&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">done</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">().</span><span class="n">set_error</span><span class="p">(</span><span class="n">EPERM</span><span class="p">,</span> <span class="s">&#34;Not leader&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">run_closure_in_bthread</span><span class="p">(</span><span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// check concurrent conf change
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果在更新conf，则报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">_conf_ctx</span><span class="p">.</span><span class="n">is_busy</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">done</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">().</span><span class="n">set_error</span><span class="p">(</span><span class="n">EBUSY</span><span class="p">,</span> <span class="s">&#34;Doing another configuration change&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">run_closure_in_bthread</span><span class="p">(</span><span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Return immediately when the new peers equals to current configuration
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// conf不变直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">_conf</span><span class="p">.</span><span class="n">conf</span><span class="p">.</span><span class="n">equals</span><span class="p">(</span><span class="n">new_conf</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">run_closure_in_bthread</span><span class="p">(</span><span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">_conf_ctx</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">old_conf</span><span class="p">,</span> <span class="n">new_conf</span><span class="p">,</span> <span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="追赶阶段"><strong>追赶阶段</strong></h3>
<p>如果新的节点配置相对于当前有新增的一个或者多个节点，leader对应的Replicator, 向把最新的snapshot再这个这些中安装，然后开始同步之后的日志。等到所有的新节点数据都追的差不多，就开始进入一下一阶段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">NodeImpl</span><span class="o">::</span><span class="n">ConfigurationCtx</span><span class="o">::</span><span class="n">start</span><span class="p">(</span><span class="k">const</span> <span class="n">Configuration</span><span class="o">&amp;</span> <span class="n">old_conf</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                       <span class="k">const</span> <span class="n">Configuration</span><span class="o">&amp;</span> <span class="n">new_conf</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                       <span class="n">Closure</span><span class="o">*</span> <span class="n">done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">_done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置状态为追赶阶段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_stage</span> <span class="o">=</span> <span class="n">STAGE_CATCHING_UP</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// diff得到节点变化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">new_conf</span><span class="p">.</span><span class="n">diffs</span><span class="p">(</span><span class="n">old_conf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adding</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">removing</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 没有新增节点进入下一阶段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">adding</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">next_stage</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">adding</span><span class="p">.</span><span class="n">list_peers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_adding_peers</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">PeerId</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">iter</span>
</span></span><span class="line"><span class="cl">            <span class="o">=</span> <span class="n">_adding_peers</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">_adding_peers</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 创建replicator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">_node</span><span class="o">-&gt;</span><span class="n">_replicator_group</span><span class="p">.</span><span class="n">add_replicator</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">OnCaughtUp</span><span class="o">*</span> <span class="n">caught_up</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OnCaughtUp</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="n">_node</span><span class="p">,</span> <span class="n">_node</span><span class="o">-&gt;</span><span class="n">_current_term</span><span class="p">,</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="n">_version</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">timespec</span> <span class="n">due_time</span> <span class="o">=</span> <span class="n">butil</span><span class="o">::</span><span class="n">milliseconds_from_now</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="n">_node</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">get_catchup_timeout_ms</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 对新增节点，等待新节点数据追的差不多，默认margin为1000
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">_node</span><span class="o">-&gt;</span><span class="n">_replicator_group</span><span class="p">.</span><span class="n">wait_caughtup</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="n">_node</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">catchup_margin</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">due_time</span><span class="p">,</span> <span class="n">caught_up</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">delete</span> <span class="n">caught_up</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nf">on_caughtup</span><span class="p">(</span><span class="n">_version</span><span class="p">,</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">ReplicatorGroup</span><span class="o">::</span><span class="n">wait_caughtup</span><span class="p">(</span><span class="k">const</span> <span class="n">PeerId</span><span class="o">&amp;</span> <span class="n">peer</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                                   <span class="kt">int64_t</span> <span class="n">max_margin</span><span class="p">,</span> <span class="k">const</span> <span class="n">timespec</span><span class="o">*</span> <span class="n">due_time</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                   <span class="n">CatchupClosure</span><span class="o">*</span> <span class="n">done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">PeerId</span><span class="p">,</span> <span class="n">ReplicatorIdAndStatus</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">_rmap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">peer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">ReplicatorId</span> <span class="n">rid</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 找replicator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Replicator</span><span class="o">::</span><span class="n">wait_for_caught_up</span><span class="p">(</span><span class="n">rid</span><span class="p">,</span> <span class="n">max_margin</span><span class="p">,</span> <span class="n">due_time</span><span class="p">,</span> <span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Replicator</span><span class="o">::</span><span class="n">wait_for_caught_up</span><span class="p">(</span><span class="n">ReplicatorId</span> <span class="n">id</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                                    <span class="kt">int64_t</span> <span class="n">max_margin</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                    <span class="k">const</span> <span class="n">timespec</span><span class="o">*</span> <span class="n">due_time</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">CatchupClosure</span><span class="o">*</span> <span class="n">done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">bthread_id_t</span> <span class="n">dummy_id</span> <span class="o">=</span> <span class="p">{</span> <span class="n">id</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">Replicator</span><span class="o">*</span> <span class="n">r</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">bthread_id_lock</span><span class="p">(</span><span class="n">dummy_id</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">done</span><span class="o">-&gt;</span><span class="n">_max_margin</span> <span class="o">=</span> <span class="n">max_margin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 已经追上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">_has_succeeded</span> <span class="o">&amp;&amp;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_is_catchup</span><span class="p">(</span><span class="n">max_margin</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">run_closure_in_bthread</span><span class="p">(</span><span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">CHECK_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bthread_id_unlock</span><span class="p">(</span><span class="n">dummy_id</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="o">&lt;&lt;</span> <span class="s">&#34;Fail to unlock&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">dummy_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">due_time</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">done</span><span class="o">-&gt;</span><span class="n">_has_timer</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 创建定时器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">bthread_timer_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="o">-&gt;</span><span class="n">_timer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="o">*</span><span class="n">due_time</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="n">_on_catch_up_timedout</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">id</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">done</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">().</span><span class="n">set_error</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">,</span> <span class="s">&#34;Duplicated call&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">run_closure_in_bthread</span><span class="p">(</span><span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="o">-&gt;</span><span class="n">_catchup_closure</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// success
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">CHECK_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bthread_id_unlock</span><span class="p">(</span><span class="n">dummy_id</span><span class="p">))</span> 
</span></span><span class="line"><span class="cl">            <span class="o">&lt;&lt;</span> <span class="s">&#34;Fail to unlock &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">dummy_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>caughtup回调</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">NodeImpl</span><span class="o">::</span><span class="n">on_caughtup</span><span class="p">(</span><span class="k">const</span> <span class="n">PeerId</span><span class="o">&amp;</span> <span class="n">peer</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">term</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                           <span class="kt">int64_t</span> <span class="n">version</span><span class="p">,</span> <span class="k">const</span> <span class="n">butil</span><span class="o">::</span><span class="n">Status</span><span class="o">&amp;</span> <span class="n">st</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">BAIDU_SCOPED_LOCK</span><span class="p">(</span><span class="n">_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// CHECK _state and _current_term to avoid ABA problem
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// leader退位处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">_state</span> <span class="o">!=</span> <span class="n">STATE_LEADER</span> <span class="o">||</span> <span class="n">term</span> <span class="o">!=</span> <span class="n">_current_term</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// if leader stepped down, reset() has already been called in step_down(),
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// so nothing needs to be done here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 成功追上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>  <span class="c1">// Caught up successfully
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">_conf_ctx</span><span class="p">.</span><span class="n">on_caughtup</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="n">peer</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Retry if this peer is still alive
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果超时再次重试
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">error_code</span><span class="p">()</span> <span class="o">==</span> <span class="n">ETIMEDOUT</span> 
</span></span><span class="line"><span class="cl">            <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">butil</span><span class="o">::</span><span class="n">monotonic_time_ms</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                <span class="o">-</span> <span class="n">_replicator_group</span><span class="p">.</span><span class="n">last_rpc_send_timestamp</span><span class="p">(</span><span class="n">peer</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                    <span class="o">&lt;=</span> <span class="n">_options</span><span class="p">.</span><span class="n">election_timeout_ms</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">OnCaughtUp</span><span class="o">*</span> <span class="n">caught_up</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OnCaughtUp</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">_current_term</span><span class="p">,</span> <span class="n">peer</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">_replicator_group</span><span class="p">.</span><span class="n">wait_caughtup</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                    <span class="n">peer</span><span class="p">,</span> <span class="n">_options</span><span class="p">.</span><span class="n">catchup_margin</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">due_time</span><span class="p">,</span> <span class="n">caught_up</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">LOG</span><span class="p">(</span><span class="n">WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;node &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">_group_id</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">_server_id</span>
</span></span><span class="line"><span class="cl">                <span class="o">&lt;&lt;</span> <span class="s">&#34; wait_caughtup failed, peer &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">peer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">delete</span> <span class="n">caught_up</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 发起重试失败，则彻底失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_conf_ctx</span><span class="p">.</span><span class="n">on_caughtup</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="n">peer</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">NodeImpl</span><span class="o">::</span><span class="n">ConfigurationCtx</span><span class="o">::</span><span class="n">on_caughtup</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int64_t</span> <span class="n">version</span><span class="p">,</span> <span class="k">const</span> <span class="n">PeerId</span><span class="o">&amp;</span> <span class="n">peer_id</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">succ</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 检查必须为追赶阶段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">CHECK_EQ</span><span class="p">(</span><span class="n">STAGE_CATCHING_UP</span><span class="p">,</span> <span class="n">_stage</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">succ</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_adding_peers</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">peer_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// add的节点为空则进入下一阶段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">_adding_peers</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nf">next_stage</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Fail
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">butil</span><span class="o">::</span><span class="n">Status</span> <span class="n">err</span><span class="p">(</span><span class="n">ECATCHUP</span><span class="p">,</span> <span class="s">&#34;Peer %s failed to catch up&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                      <span class="n">peer_id</span><span class="p">.</span><span class="n">to_string</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 失败重置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="联合选举阶段"><strong>联合选举阶段</strong></h3>
<p>leader会将旧节点配置和新节点配置写入Log, 在这个阶段之后直到下一个阶段之前，所有的选举和日志同步都需要在<strong>新老节点之间达到多数。</strong></p>
<p>变更节点大于1时，进入联合选举阶段；如果这次只变更了一个节点, 则直接进入下一阶段。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">NodeImpl</span><span class="o">::</span><span class="n">ConfigurationCtx</span><span class="o">::</span><span class="n">next_stage</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">CHECK</span><span class="p">(</span><span class="n">is_busy</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">_stage</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">STAGE_CATCHING_UP</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">_nchanges</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">_stage</span> <span class="o">=</span> <span class="n">STAGE_JOINT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">Configuration</span> <span class="nf">old_conf</span><span class="p">(</span><span class="n">_old_peers</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">_node</span><span class="o">-&gt;</span><span class="n">unsafe_apply_configuration</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                    <span class="n">Configuration</span><span class="p">(</span><span class="n">_new_peers</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">old_conf</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Skip joint consensus since only one peer has been changed here. Make
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// it a one-stage change to be compitible with the legacy
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// implementation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nl">STAGE_JOINT</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">_stage</span> <span class="o">=</span> <span class="n">STAGE_STABLE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">_node</span><span class="o">-&gt;</span><span class="n">unsafe_apply_configuration</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                    <span class="n">Configuration</span><span class="p">(</span><span class="n">_new_peers</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>它会生成一个类型为ENTRY_TYPE_CONFIGURATION的logEntry，将entry的peers设置为新配置，old_peers设置为旧配置。然后把这个任务添加到投票箱里面，并调用LogManager::append_entries把entry append到内存并持久化。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">NodeImpl</span><span class="o">::</span><span class="n">unsafe_apply_configuration</span><span class="p">(</span><span class="k">const</span> <span class="n">Configuration</span><span class="o">&amp;</span> <span class="n">new_conf</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                          <span class="k">const</span> <span class="n">Configuration</span><span class="o">*</span> <span class="n">old_conf</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                          <span class="kt">bool</span> <span class="n">leader_start</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">CHECK</span><span class="p">(</span><span class="n">_conf_ctx</span><span class="p">.</span><span class="n">is_busy</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">LogEntry</span><span class="o">*</span> <span class="n">entry</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LogEntry</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">entry</span><span class="o">-&gt;</span><span class="n">AddRef</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">entry</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">.</span><span class="n">term</span> <span class="o">=</span> <span class="n">_current_term</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 产生一个配置变更的日志项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">entry</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">ENTRY_TYPE_CONFIGURATION</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">entry</span><span class="o">-&gt;</span><span class="n">peers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PeerId</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">new_conf</span><span class="p">.</span><span class="n">list_peers</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">peers</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">old_conf</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">entry</span><span class="o">-&gt;</span><span class="n">old_peers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PeerId</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">old_conf</span><span class="o">-&gt;</span><span class="n">list_peers</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">old_peers</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">ConfigurationChangeDone</span><span class="o">*</span> <span class="n">configuration_change_done</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">            <span class="k">new</span> <span class="n">ConfigurationChangeDone</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">_current_term</span><span class="p">,</span> <span class="n">leader_start</span><span class="p">,</span> <span class="n">_leader_lease</span><span class="p">.</span><span class="n">lease_epoch</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Use the new_conf to deal the quorum of this very log
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_ballot_box</span><span class="o">-&gt;</span><span class="n">append_pending_task</span><span class="p">(</span><span class="n">new_conf</span><span class="p">,</span> <span class="n">old_conf</span><span class="p">,</span> <span class="n">configuration_change_done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LogEntry</span><span class="o">*&gt;</span> <span class="n">entries</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">entries</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// append 日志项
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_log_manager</span><span class="o">-&gt;</span><span class="n">append_entries</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entries</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                 <span class="k">new</span> <span class="n">LeaderStableClosure</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                                        <span class="n">NodeId</span><span class="p">(</span><span class="n">_group_id</span><span class="p">,</span> <span class="n">_server_id</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                                        <span class="mi">1u</span><span class="p">,</span> <span class="n">_ballot_box</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">_log_manager</span><span class="o">-&gt;</span><span class="n">check_and_set_configuration</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_conf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果entry type是ENTRY_TYPE_CONFIGURATION的话就把这个配置append到_config_manager里面。之后会调用LogManager::check_and_set_configuration把_conf设置为刚刚放进去的新配置（其中old_conf为之前的配置）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">LogManager</span><span class="o">::</span><span class="n">append_entries</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LogEntry</span><span class="o">*&gt;</span> <span class="o">*</span><span class="n">entries</span><span class="p">,</span> <span class="n">StableClosure</span><span class="o">*</span> <span class="n">done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">entries</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Add ref for disk_thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">(</span><span class="o">*</span><span class="n">entries</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">AddRef</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">entries</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">ENTRY_TYPE_CONFIGURATION</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ConfigurationEntry</span> <span class="nf">conf_entry</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="o">*</span><span class="n">entries</span><span class="p">)[</span><span class="n">i</span><span class="p">]));</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 对于修改peer的类型的日志，加入config manager，影响后续的投票。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">_config_manager</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">conf_entry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个时间点之后，产生的任务，在放到投票箱的时候_conf.stable会返回false，然后将第二个参数设置为_conf.old_conf。因此这个时间点之后产生的任务需要新旧两个配置共同决定是否提交，也就是JOINT状态。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">_ballot_box</span><span class="o">-&gt;</span><span class="n">append_pending_task</span><span class="p">(</span><span class="n">_conf</span><span class="p">.</span><span class="n">conf</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                         <span class="n">_conf</span><span class="p">.</span><span class="n">stable</span><span class="p">()</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">_conf</span><span class="p">.</span><span class="n">old_conf</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                         <span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">done</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在投票阶段，新旧配置同时达到多数才通过。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">Ballot</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="k">const</span> <span class="n">Configuration</span><span class="o">&amp;</span> <span class="n">conf</span><span class="p">,</span> <span class="k">const</span> <span class="n">Configuration</span><span class="o">*</span> <span class="n">old_conf</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">_peers</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">conf</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">Configuration</span><span class="o">::</span><span class="n">const_iterator</span>
</span></span><span class="line"><span class="cl">            <span class="n">iter</span> <span class="o">=</span> <span class="n">conf</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">conf</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_peers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_quorum</span> <span class="o">=</span> <span class="n">_peers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old_conf</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">_old_peers</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">old_conf</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">Configuration</span><span class="o">::</span><span class="n">const_iterator</span>
</span></span><span class="line"><span class="cl">            <span class="n">iter</span> <span class="o">=</span> <span class="n">old_conf</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">old_conf</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_old_peers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_old_quorum</span> <span class="o">=</span> <span class="n">_old_peers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Ballot</span><span class="o">::</span><span class="n">PosHint</span> <span class="n">Ballot</span><span class="o">::</span><span class="n">grant</span><span class="p">(</span><span class="k">const</span> <span class="n">PeerId</span><span class="o">&amp;</span> <span class="n">peer</span><span class="p">,</span> <span class="n">PosHint</span> <span class="n">hint</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">UnfoundPeerId</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">iter</span> <span class="o">=</span> <span class="n">find_peer</span><span class="p">(</span><span class="n">peer</span><span class="p">,</span> <span class="n">_peers</span><span class="p">,</span> <span class="n">hint</span><span class="p">.</span><span class="n">pos0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">_peers</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">iter</span><span class="o">-&gt;</span><span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 新配置计数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">--</span><span class="n">_quorum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">hint</span><span class="p">.</span><span class="n">pos0</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">_old_peers</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">hint</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">iter</span> <span class="o">=</span> <span class="n">find_peer</span><span class="p">(</span><span class="n">peer</span><span class="p">,</span> <span class="n">_old_peers</span><span class="p">,</span> <span class="n">hint</span><span class="p">.</span><span class="n">pos1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">_old_peers</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">iter</span><span class="o">-&gt;</span><span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 旧配置计数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="o">--</span><span class="n">_old_quorum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">hint</span><span class="p">.</span><span class="n">pos1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">hint</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">granted</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_quorum</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">_old_quorum</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>ConfigurationChangeDone回调时，进入下一阶段。</p>
<h3 id="新配置同步阶段"><strong>新配置同步阶段</strong></h3>
<p>当联合选举日志正式被新旧集群接受之后，leader将新节点配置写入log，之后所有的log和选举只需要在新集群中达成一致。 等待日志提交到<strong>新集群</strong>中的多数节点中之后， 正式完成节点变更。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">STAGE_JOINT</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">_stage</span> <span class="o">=</span> <span class="n">STAGE_STABLE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">_node</span><span class="o">-&gt;</span><span class="n">unsafe_apply_configuration</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                    <span class="n">Configuration</span><span class="p">(</span><span class="n">_new_peers</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>和联合选举阶段调用相同的实现，只是old_conf为NULL。</p>
<h3 id="清理阶段"><strong>清理阶段</strong></h3>
<p>leader会将多余的Replicator(如果有)关闭，特别如果当leader本身已经从节点配置中被移除，这时候leader会执行stepdown并且唤醒一个合适的节点触发选举。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">case</span> <span class="nl">STAGE_STABLE</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">bool</span> <span class="n">should_step_down</span> <span class="o">=</span> 
</span></span><span class="line"><span class="cl">                <span class="n">_new_peers</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">_node</span><span class="o">-&gt;</span><span class="n">_server_id</span><span class="p">)</span> <span class="o">==</span> <span class="n">_new_peers</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">butil</span><span class="o">::</span><span class="n">Status</span> <span class="n">st</span> <span class="o">=</span> <span class="n">butil</span><span class="o">::</span><span class="n">Status</span><span class="o">::</span><span class="n">OK</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">should_step_down</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 退位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">_node</span><span class="o">-&gt;</span><span class="n">step_down</span><span class="p">(</span><span class="n">_node</span><span class="o">-&gt;</span><span class="n">_current_term</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="n">butil</span><span class="o">::</span><span class="n">Status</span><span class="p">(</span><span class="n">ELEADERREMOVED</span><span class="p">,</span> <span class="s">&#34;This node was removed&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="快照">快照</h2>
<h3 id="打快照">打快照</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">NodeImpl</span><span class="o">::</span><span class="n">do_snapshot</span><span class="p">(</span><span class="n">Closure</span><span class="o">*</span> <span class="n">done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_snapshot_executor</span><span class="o">-&gt;</span><span class="n">do_snapshot</span><span class="p">(</span><span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">SnapshotExecutor</span><span class="o">::</span><span class="n">do_snapshot</span><span class="p">(</span><span class="n">Closure</span><span class="o">*</span> <span class="n">done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 创建writer，默认为LocalSnapshotWriter，使用临时文件路径来初始化
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">SnapshotWriter</span><span class="o">*</span> <span class="n">writer</span> <span class="o">=</span> <span class="n">_snapshot_storage</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">_saving_snapshot</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">SaveSnapshotDone</span><span class="o">*</span> <span class="n">snapshot_save_done</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SaveSnapshotDone</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">writer</span><span class="p">,</span> <span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">_fsm_caller</span><span class="o">-&gt;</span><span class="n">on_snapshot_save</span><span class="p">(</span><span class="n">snapshot_save_done</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">FSMCaller</span><span class="o">::</span><span class="n">on_snapshot_save</span><span class="p">(</span><span class="n">SaveSnapshotClosure</span><span class="o">*</span> <span class="n">done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ApplyTask</span> <span class="n">task</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">task</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">SNAPSHOT_SAVE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">task</span><span class="p">.</span><span class="n">done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 加入队列等待执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">bthread</span><span class="o">::</span><span class="n">execution_queue_execute</span><span class="p">(</span><span class="n">_queue_id</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>FSMCaller处理到打快照的任务时，执行下面的函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">FSMCaller</span><span class="o">::</span><span class="n">do_snapshot_save</span><span class="p">(</span><span class="n">SaveSnapshotClosure</span><span class="o">*</span> <span class="n">done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">CHECK</span><span class="p">(</span><span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int64_t</span> <span class="n">last_applied_index</span> <span class="o">=</span> <span class="n">_last_applied_index</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">butil</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置meta信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">SnapshotMeta</span> <span class="n">meta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">meta</span><span class="p">.</span><span class="n">set_last_included_index</span><span class="p">(</span><span class="n">last_applied_index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">meta</span><span class="p">.</span><span class="n">set_last_included_term</span><span class="p">(</span><span class="n">_last_applied_term</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">ConfigurationEntry</span> <span class="n">conf_entry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">_log_manager</span><span class="o">-&gt;</span><span class="n">get_configuration</span><span class="p">(</span><span class="n">last_applied_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf_entry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">Configuration</span><span class="o">::</span><span class="n">const_iterator</span>
</span></span><span class="line"><span class="cl">            <span class="n">iter</span> <span class="o">=</span> <span class="n">conf_entry</span><span class="p">.</span><span class="n">conf</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">iter</span> <span class="o">!=</span> <span class="n">conf_entry</span><span class="p">.</span><span class="n">conf</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="n">meta</span><span class="p">.</span><span class="n">add_peers</span><span class="p">()</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">to_string</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">Configuration</span><span class="o">::</span><span class="n">const_iterator</span>
</span></span><span class="line"><span class="cl">            <span class="n">iter</span> <span class="o">=</span> <span class="n">conf_entry</span><span class="p">.</span><span class="n">old_conf</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">iter</span> <span class="o">!=</span> <span class="n">conf_entry</span><span class="p">.</span><span class="n">old_conf</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="n">meta</span><span class="p">.</span><span class="n">add_old_peers</span><span class="p">()</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">to_string</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 将meta保存到writer对象中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">SnapshotWriter</span><span class="o">*</span> <span class="n">writer</span> <span class="o">=</span> <span class="n">done</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">meta</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">writer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">done</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">().</span><span class="n">set_error</span><span class="p">(</span><span class="n">EINVAL</span><span class="p">,</span> <span class="s">&#34;snapshot_storage create SnapshotWriter failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">done</span><span class="o">-&gt;</span><span class="n">Run</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用用户的snapshot save实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_fsm</span><span class="o">-&gt;</span><span class="n">on_snapshot_save</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span> <span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在用户的snapshot save实现中，会回调SaveSnapshotClosure::Run，来完成snapshot meta信息的保存。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">SaveSnapshotDone</span><span class="o">::</span><span class="n">Run</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 启动bthread来避免阻塞状态机
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Avoid blocking FSMCaller
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// This continuation of snapshot saving is likely running inplace where the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// on_snapshot_save is called (in the FSMCaller thread) and blocks all the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// following on_apply. As blocking is not necessary and the continuation is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// not important, so we start a bthread to do this.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">bthread_t</span> <span class="n">tid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">bthread_start_urgent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">continue_run</span><span class="p">,</span> <span class="k">this</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">PLOG</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Fail to start bthread&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">continue_run</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="n">SaveSnapshotDone</span><span class="o">::</span><span class="n">continue_run</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">SaveSnapshotDone</span><span class="o">*</span> <span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="n">SaveSnapshotDone</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SaveSnapshotDone</span><span class="o">&gt;</span> <span class="n">self_guard</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Must call on_snapshot_save_done to clear _saving_snapshot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">_se</span><span class="o">-&gt;</span><span class="n">on_snapshot_save_done</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">self</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">(),</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">_meta</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">_writer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">().</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">self</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">().</span><span class="n">set_error</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="s">&#34;node call on_snapshot_save_done failed&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//user done, need set error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">_done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">self</span><span class="o">-&gt;</span><span class="n">_done</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">()</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">_done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">run_closure_in_bthread</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">_done</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的continue_run调用下面的实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">SnapshotExecutor</span><span class="o">::</span><span class="n">on_snapshot_save_done</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">butil</span><span class="o">::</span><span class="n">Status</span><span class="o">&amp;</span> <span class="n">st</span><span class="p">,</span> <span class="k">const</span> <span class="n">SnapshotMeta</span><span class="o">&amp;</span> <span class="n">meta</span><span class="p">,</span> <span class="n">SnapshotWriter</span><span class="o">*</span> <span class="n">writer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">raft_mutex_t</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">error_code</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// InstallSnapshot can break SaveSnapshot, check InstallSnapshot when SaveSnapshot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// because upstream Snapshot maybe newer than local Snapshot.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果leader发送的snapshot更新，忽略本地的snapshot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">meta</span><span class="p">.</span><span class="n">last_included_index</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">_last_snapshot_index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">ret</span> <span class="o">=</span> <span class="n">ESTALE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">writer</span><span class="o">-&gt;</span><span class="n">set_error</span><span class="p">(</span><span class="n">ESTALE</span><span class="p">,</span> <span class="s">&#34;Installing snapshot is older than local snapshot&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">lck</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">writer</span><span class="o">-&gt;</span><span class="n">save_meta</span><span class="p">(</span><span class="n">meta</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">writer</span><span class="o">-&gt;</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">writer</span><span class="o">-&gt;</span><span class="n">set_error</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="s">&#34;Fail to do snapshot&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 默认调用LocalSnapshotStorage，保存snapshot meta信息到文件，将snapshot目录从临时路径重命名为最终路径
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">_snapshot_storage</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">(</span><span class="n">writer</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ret</span> <span class="o">=</span> <span class="n">EIO</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">LOG</span><span class="p">(</span><span class="n">WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;node &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">_node</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; fail to close writer&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_last_snapshot_index</span> <span class="o">=</span> <span class="n">meta</span><span class="p">.</span><span class="n">last_included_index</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">_last_snapshot_term</span> <span class="o">=</span> <span class="n">meta</span><span class="p">.</span><span class="n">last_included_term</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">lck</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">_log_manager</span><span class="o">-&gt;</span><span class="n">set_snapshot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">meta</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">lck</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">EIO</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">report_error</span><span class="p">(</span><span class="n">EIO</span><span class="p">,</span> <span class="s">&#34;Fail to save snapshot&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">_saving_snapshot</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">lck</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">_running_jobs</span><span class="p">.</span><span class="n">signal</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>set_snapshot更新LogManager的状态</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">LogManager</span><span class="o">::</span><span class="n">set_snapshot</span><span class="p">(</span><span class="k">const</span> <span class="n">SnapshotMeta</span><span class="o">*</span> <span class="n">meta</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">raft_mutex_t</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">_mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">meta</span><span class="o">-&gt;</span><span class="n">last_included_index</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">_last_snapshot_id</span><span class="p">.</span><span class="n">index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Configuration</span> <span class="n">conf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">meta</span><span class="o">-&gt;</span><span class="n">peers_size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">conf</span><span class="p">.</span><span class="n">add_peer</span><span class="p">(</span><span class="n">meta</span><span class="o">-&gt;</span><span class="n">peers</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Configuration</span> <span class="n">old_conf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">meta</span><span class="o">-&gt;</span><span class="n">old_peers_size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">old_conf</span><span class="p">.</span><span class="n">add_peer</span><span class="p">(</span><span class="n">meta</span><span class="o">-&gt;</span><span class="n">old_peers</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">ConfigurationEntry</span> <span class="n">entry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">entry</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">LogId</span><span class="p">(</span><span class="n">meta</span><span class="o">-&gt;</span><span class="n">last_included_index</span><span class="p">(),</span> <span class="n">meta</span><span class="o">-&gt;</span><span class="n">last_included_term</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">entry</span><span class="p">.</span><span class="n">conf</span> <span class="o">=</span> <span class="n">conf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">entry</span><span class="p">.</span><span class="n">old_conf</span> <span class="o">=</span> <span class="n">old_conf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">_config_manager</span><span class="o">-&gt;</span><span class="n">set_snapshot</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int64_t</span> <span class="n">term</span> <span class="o">=</span> <span class="n">unsafe_get_term</span><span class="p">(</span><span class="n">meta</span><span class="o">-&gt;</span><span class="n">last_included_index</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">LogId</span> <span class="n">last_but_one_snapshot_id</span> <span class="o">=</span> <span class="n">_last_snapshot_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">_last_snapshot_id</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">meta</span><span class="o">-&gt;</span><span class="n">last_included_index</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">_last_snapshot_id</span><span class="p">.</span><span class="n">term</span> <span class="o">=</span> <span class="n">meta</span><span class="o">-&gt;</span><span class="n">last_included_term</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">_last_snapshot_id</span> <span class="o">&gt;</span> <span class="n">_applied_id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_applied_id</span> <span class="o">=</span> <span class="n">_last_snapshot_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// NOTICE: not to update disk_id here as we are not sure if this node really
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// has these logs on disk storage. Just leave disk_id as it was, which can keep
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// these logs in memory all the time until they are flushed to disk. By this 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// way we can avoid some corner cases which failed to get logs.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">term</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果term等于0，说明last_included_index大于last_index（一般发生在follower处），
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 则把缓存和文件里面的log entry从前面截断到last_included_index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// last_included_index is larger than last_index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// FIXME: what if last_included_index is less than first_index?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">_virtual_first_log_id</span> <span class="o">=</span> <span class="n">_last_snapshot_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">truncate_prefix</span><span class="p">(</span><span class="n">meta</span><span class="o">-&gt;</span><span class="n">last_included_index</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lck</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">term</span> <span class="o">==</span> <span class="n">meta</span><span class="o">-&gt;</span><span class="n">last_included_term</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果term等于 meta-&gt;last_included_term，说明log entry里面还存在着这条记录，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 先不着急截断，把它截断到上一个快照处(如果有的话)。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Truncating log to the index of the last snapshot.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// We don&#39;t truncate log before the latest snapshot immediately since
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// some log around last_snapshot_index is probably needed by some
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// followers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">last_but_one_snapshot_id</span><span class="p">.</span><span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// We have last snapshot index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">_virtual_first_log_id</span> <span class="o">=</span> <span class="n">last_but_one_snapshot_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">truncate_prefix</span><span class="p">(</span><span class="n">last_but_one_snapshot_id</span><span class="p">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lck</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 其他情况对应index上的term不等于meta-&gt;last_included_term，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 则可能是follower处正在安装快照，这种情况，直接reset，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 让_first_log_index指向last_included_index，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// _last_log_index指向last_included_index-1，把entries清空。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// TODO: check the result of reset.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">_virtual_first_log_id</span> <span class="o">=</span> <span class="n">_last_snapshot_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">reset</span><span class="p">(</span><span class="n">meta</span><span class="o">-&gt;</span><span class="n">last_included_index</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lck</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">CHECK</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Cannot reach here&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="installsnapshot">InstallSnapshot</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Replicator</span><span class="o">::</span><span class="n">_send_entries</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">if</span> <span class="p">(</span><span class="n">_fill_common_fields</span><span class="p">(</span><span class="n">request</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">_next_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_reset_next_index</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">_install_snapshot</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在_send_entries实现中，如果要发送的entry在log_manager中不存在（已经合入snapshot并在本地清理了日志），_fill_common_fields返回非0值，此时会调用_install_snapshot来安装快照。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Replicator</span><span class="o">::</span><span class="n">_install_snapshot</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// pre-set replicator state to INSTALLING_SNAPSHOT, so replicator could be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// blocked if something is wrong, such as throttled for a period of time 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_st</span><span class="p">.</span><span class="n">st</span> <span class="o">=</span> <span class="n">INSTALLING_SNAPSHOT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 返回最新的快照reader，默认实现为LocalSnapshotReader
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_reader</span> <span class="o">=</span> <span class="n">_options</span><span class="p">.</span><span class="n">snapshot_storage</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_reader</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">e</span><span class="p">.</span><span class="n">status</span><span class="p">().</span><span class="n">set_error</span><span class="p">(</span><span class="n">EIO</span><span class="p">,</span> <span class="s">&#34;Fail to open snapshot&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 生成copy的uri，格式为 remote://host:port/reader_id_number
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 通过reader id可以区分不同的读者
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">uri</span> <span class="o">=</span> <span class="n">_reader</span><span class="o">-&gt;</span><span class="n">generate_uri_for_copy</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">SnapshotMeta</span> <span class="n">meta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// report error on failure
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">_reader</span><span class="o">-&gt;</span><span class="n">load_meta</span><span class="p">(</span><span class="o">&amp;</span><span class="n">meta</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">e</span><span class="p">.</span><span class="n">status</span><span class="p">().</span><span class="n">set_error</span><span class="p">(</span><span class="n">EIO</span><span class="p">,</span> <span class="s">&#34;Fail to load meta from &#34;</span> <span class="o">+</span> <span class="n">snapshot_path</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="n">brpc</span><span class="o">::</span><span class="n">Controller</span><span class="o">*</span> <span class="n">cntl</span> <span class="o">=</span> <span class="k">new</span> <span class="n">brpc</span><span class="o">::</span><span class="n">Controller</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cntl</span><span class="o">-&gt;</span><span class="n">set_max_retry</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cntl</span><span class="o">-&gt;</span><span class="n">set_timeout_ms</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">InstallSnapshotRequest</span><span class="o">*</span> <span class="n">request</span> <span class="o">=</span> <span class="k">new</span> <span class="n">InstallSnapshotRequest</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">InstallSnapshotResponse</span><span class="o">*</span> <span class="n">response</span> <span class="o">=</span> <span class="k">new</span> <span class="n">InstallSnapshotResponse</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">request</span><span class="o">-&gt;</span><span class="n">set_term</span><span class="p">(</span><span class="n">_options</span><span class="p">.</span><span class="n">term</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">request</span><span class="o">-&gt;</span><span class="n">set_group_id</span><span class="p">(</span><span class="n">_options</span><span class="p">.</span><span class="n">group_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">request</span><span class="o">-&gt;</span><span class="n">set_server_id</span><span class="p">(</span><span class="n">_options</span><span class="p">.</span><span class="n">server_id</span><span class="p">.</span><span class="n">to_string</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">request</span><span class="o">-&gt;</span><span class="n">set_peer_id</span><span class="p">(</span><span class="n">_options</span><span class="p">.</span><span class="n">peer_id</span><span class="p">.</span><span class="n">to_string</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置meta和uri
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">request</span><span class="o">-&gt;</span><span class="n">mutable_meta</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">meta</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">request</span><span class="o">-&gt;</span><span class="n">set_uri</span><span class="p">(</span><span class="n">uri</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">_install_snapshot_in_fly</span> <span class="o">=</span> <span class="n">cntl</span><span class="o">-&gt;</span><span class="n">call_id</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">_install_snapshot_counter</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">_st</span><span class="p">.</span><span class="n">last_log_included</span> <span class="o">=</span> <span class="n">meta</span><span class="p">.</span><span class="n">last_included_index</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">_st</span><span class="p">.</span><span class="n">last_term_included</span> <span class="o">=</span> <span class="n">meta</span><span class="p">.</span><span class="n">last_included_term</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Closure</span><span class="o">*</span> <span class="n">done</span> <span class="o">=</span> <span class="n">brpc</span><span class="o">::</span><span class="n">NewCallback</span><span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">                <span class="n">ReplicatorId</span><span class="p">,</span> <span class="n">brpc</span><span class="o">::</span><span class="n">Controller</span><span class="o">*</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="n">InstallSnapshotRequest</span><span class="o">*</span><span class="p">,</span> <span class="n">InstallSnapshotResponse</span><span class="o">*&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                    <span class="n">_on_install_snapshot_returned</span><span class="p">,</span> <span class="n">_id</span><span class="p">.</span><span class="n">value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">cntl</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">RaftService_Stub</span> <span class="nf">stub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_sending_channel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">stub</span><span class="p">.</span><span class="n">install_snapshot</span><span class="p">(</span><span class="n">cntl</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">CHECK_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bthread_id_unlock</span><span class="p">(</span><span class="n">_id</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Fail to unlock &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>follower的处理逻辑</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">NodeImpl</span><span class="o">::</span><span class="n">handle_install_snapshot_request</span><span class="p">(</span><span class="n">brpc</span><span class="o">::</span><span class="n">Controller</span><span class="o">*</span> <span class="n">cntl</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                    <span class="k">const</span> <span class="n">InstallSnapshotRequest</span><span class="o">*</span> <span class="n">request</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">InstallSnapshotResponse</span><span class="o">*</span> <span class="n">response</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Closure</span><span class="o">*</span> <span class="n">done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// check stale term
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 让过期的leader退位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">term</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">_current_term</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_term</span><span class="p">(</span><span class="n">_current_term</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_success</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">check_step_down</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">term</span><span class="p">(),</span> <span class="n">server_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果接收到了另一个peer的install snapshot请求，term加1，让两个leader都退位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">server_id</span> <span class="o">!=</span> <span class="n">_leader_id</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Increase the term by 1 and make both leaders step down to minimize the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// loss of split brain
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">butil</span><span class="o">::</span><span class="n">Status</span> <span class="n">status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">status</span><span class="p">.</span><span class="n">set_error</span><span class="p">(</span><span class="n">ELEADERCONFLICT</span><span class="p">,</span> <span class="s">&#34;More than one leader in the same term.&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">        <span class="n">step_down</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">term</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_success</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">response</span><span class="o">-&gt;</span><span class="n">set_term</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">term</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">clear_append_entries_cache</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">lck</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">_snapshot_executor</span><span class="o">-&gt;</span><span class="n">install_snapshot</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">cntl</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">done_guard</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>install_snapshot实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">SnapshotExecutor</span><span class="o">::</span><span class="n">install_snapshot</span><span class="p">(</span><span class="n">brpc</span><span class="o">::</span><span class="n">Controller</span><span class="o">*</span> <span class="n">cntl</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                        <span class="k">const</span> <span class="n">InstallSnapshotRequest</span><span class="o">*</span> <span class="n">request</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                        <span class="n">InstallSnapshotResponse</span><span class="o">*</span> <span class="n">response</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                        <span class="n">google</span><span class="o">::</span><span class="n">protobuf</span><span class="o">::</span><span class="n">Closure</span><span class="o">*</span> <span class="n">done</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">brpc</span><span class="o">::</span><span class="n">ClosureGuard</span> <span class="n">done_guard</span><span class="p">(</span><span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">SnapshotMeta</span> <span class="n">meta</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">meta</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DownloadingSnapshot</span><span class="o">&gt;</span> <span class="n">ds</span><span class="p">(</span><span class="k">new</span> <span class="n">DownloadingSnapshot</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">ds</span><span class="o">-&gt;</span><span class="n">cntl</span> <span class="o">=</span> <span class="n">cntl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ds</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ds</span><span class="o">-&gt;</span><span class="n">response</span> <span class="o">=</span> <span class="n">response</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ds</span><span class="o">-&gt;</span><span class="n">request</span> <span class="o">=</span> <span class="n">request</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 启动bthread来开始copy。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 如果已经存在任务，视index新旧取消原任务或忽略新任务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ret</span> <span class="o">=</span> <span class="n">register_downloading_snapshot</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//    ^^^ DON&#39;T access request, response, done and cntl after this point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">//        as the retry snapshot will replace this one.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Release done first as this RPC might be replaced by the retry one
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">done_guard</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">CHECK</span><span class="p">(</span><span class="n">_cur_copier</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 等待copy的bthread执行完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_cur_copier</span><span class="o">-&gt;</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 加载下载的snapshot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nf">load_downloading_snapshot</span><span class="p">(</span><span class="n">ds</span><span class="p">.</span><span class="n">release</span><span class="p">(),</span> <span class="n">meta</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>LocalSnapshotCopier创建及初始化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">SnapshotCopier</span><span class="o">*</span> <span class="n">LocalSnapshotStorage</span><span class="o">::</span><span class="n">start_to_copy_from</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">uri</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">LocalSnapshotCopier</span><span class="o">*</span> <span class="n">copier</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LocalSnapshotCopier</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">copier</span><span class="o">-&gt;</span><span class="n">_storage</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">copier</span><span class="o">-&gt;</span><span class="n">_filter_before_copy_remote</span> <span class="o">=</span> <span class="n">_filter_before_copy_remote</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">copier</span><span class="o">-&gt;</span><span class="n">_fs</span> <span class="o">=</span> <span class="n">_fs</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">copier</span><span class="o">-&gt;</span><span class="n">_throttle</span> <span class="o">=</span> <span class="n">_snapshot_throttle</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 解析leader的ip:port以及reader_id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">copier</span><span class="o">-&gt;</span><span class="n">init</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">LOG</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Fail to init copier from &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">uri</span>
</span></span><span class="line"><span class="cl">                   <span class="o">&lt;&lt;</span> <span class="s">&#34; path: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">_path</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">delete</span> <span class="n">copier</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">copier</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">copier</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>拷贝实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">LocalSnapshotCopier</span><span class="o">::</span><span class="n">copy</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 加载remote meta信息，具体实现为将远程的meta文件读取到内存的IOBuf，然后进行解析
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">load_meta_table</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 根据开关，允许对和本地snapshot中文件名和校验和相同的文件跳过下载
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">filter</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">files</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">_remote_snapshot</span><span class="p">.</span><span class="n">list_files</span><span class="p">(</span><span class="o">&amp;</span><span class="n">files</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 逐个拷贝文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">files</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">ok</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 通过文件操作RPC，将文件分段拷贝过来。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">copy_file</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ok</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">_writer</span> <span class="o">&amp;&amp;</span> <span class="n">_writer</span><span class="o">-&gt;</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_writer</span><span class="o">-&gt;</span><span class="n">set_error</span><span class="p">(</span><span class="n">error_code</span><span class="p">(),</span> <span class="n">error_cstr</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">_writer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// set_error for copier only when failed to close writer and copier was 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// ok before this moment 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">_storage</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">(</span><span class="n">_writer</span><span class="p">,</span> <span class="n">_filter_before_copy_remote</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">set_error</span><span class="p">(</span><span class="n">EIO</span><span class="p">,</span> <span class="s">&#34;Fail to close writer&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">_writer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">_reader</span> <span class="o">=</span> <span class="n">_storage</span><span class="o">-&gt;</span><span class="n">open</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在snapshot下载完成后，调用SnapshotExecutor::load_downloading_snapshot来加载</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">SnapshotExecutor</span><span class="o">::</span><span class="n">load_downloading_snapshot</span><span class="p">(</span><span class="n">DownloadingSnapshot</span><span class="o">*</span> <span class="n">ds</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                                 <span class="k">const</span> <span class="n">SnapshotMeta</span><span class="o">&amp;</span> <span class="n">meta</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">brpc</span><span class="o">::</span><span class="n">ClosureGuard</span> <span class="n">done_guard</span><span class="p">(</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">CHECK</span><span class="p">(</span><span class="n">_cur_copier</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">SnapshotReader</span><span class="o">*</span> <span class="n">reader</span> <span class="o">=</span> <span class="n">_cur_copier</span><span class="o">-&gt;</span><span class="n">get_reader</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_cur_copier</span><span class="o">-&gt;</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ds</span><span class="o">-&gt;</span><span class="n">cntl</span><span class="o">-&gt;</span><span class="n">SetFailed</span><span class="p">(</span><span class="n">_cur_copier</span><span class="o">-&gt;</span><span class="n">error_code</span><span class="p">(),</span> <span class="s">&#34;%s&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="n">_cur_copier</span><span class="o">-&gt;</span><span class="n">error_cstr</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">_snapshot_storage</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">(</span><span class="n">_cur_copier</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">_cur_copier</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">reader</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">reader</span><span class="o">-&gt;</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">ds</span><span class="o">-&gt;</span><span class="n">cntl</span><span class="o">-&gt;</span><span class="n">SetFailed</span><span class="p">(</span><span class="n">brpc</span><span class="o">::</span><span class="n">EINTERNAL</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                           <span class="s">&#34;Fail to copy snapshot from %s&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="n">ds</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">uri</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// The owner of ds is on_snapshot_load_done
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ds_guard</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">done_guard</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">_loading_snapshot</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//                ^ After this point, this installing cannot be interrupted
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">_loading_snapshot_meta</span> <span class="o">=</span> <span class="n">meta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">lck</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">InstallSnapshotDone</span><span class="o">*</span> <span class="n">install_snapshot_done</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">            <span class="k">new</span> <span class="n">InstallSnapshotDone</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">reader</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 调用用户的snapshot load实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">_fsm_caller</span><span class="o">-&gt;</span><span class="n">on_snapshot_load</span><span class="p">(</span><span class="n">install_snapshot_done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">install_snapshot_done</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">().</span><span class="n">set_error</span><span class="p">(</span><span class="n">EHOSTDOWN</span><span class="p">,</span> <span class="s">&#34;This raft node is down&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">install_snapshot_done</span><span class="o">-&gt;</span><span class="n">Run</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Leader对InstallSnapshot响应的处理逻辑</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Replicator</span><span class="o">::</span><span class="n">_on_install_snapshot_returned</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">ReplicatorId</span> <span class="n">id</span><span class="p">,</span> <span class="n">brpc</span><span class="o">::</span><span class="n">Controller</span><span class="o">*</span> <span class="n">cntl</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">InstallSnapshotRequest</span><span class="o">*</span> <span class="n">request</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">            <span class="n">InstallSnapshotResponse</span><span class="o">*</span> <span class="n">response</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Replicator</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">bthread_id_t</span> <span class="n">dummy_id</span> <span class="o">=</span> <span class="p">{</span> <span class="n">id</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">succ</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">bthread_id_lock</span><span class="p">(</span><span class="n">dummy_id</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">_reader</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 关闭reader
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">snapshot_storage</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">_reader</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">r</span><span class="o">-&gt;</span><span class="n">_reader</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">snapshot_throttle</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">r</span><span class="o">-&gt;</span><span class="n">_options</span><span class="p">.</span><span class="n">snapshot_throttle</span><span class="o">-&gt;</span><span class="n">finish_one_task</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果失败会在后续的_send_entries中再次调用InstallSnapshot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// We don&#39;t retry installing the snapshot explicitly. 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// dummy_id is unlock in _send_entries
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">succ</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_block</span><span class="p">(</span><span class="n">butil</span><span class="o">::</span><span class="n">gettimeofday_us</span><span class="p">(),</span> <span class="n">cntl</span><span class="o">-&gt;</span><span class="n">ErrorCode</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="o">-&gt;</span><span class="n">_has_succeeded</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="o">-&gt;</span><span class="n">_notify_on_caught_up</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">_timeout_now_index</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_timeout_now_index</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_min_flying_index</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">r</span><span class="o">-&gt;</span><span class="n">_send_timeout_now</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// dummy_id is unlock in _send_entries
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">_send_entries</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<ul>
<li><a href="https://github.com/baidu/braft/blob/master/docs/cn/server.md">braft/server.md at master · baidu/braft (github.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/169840204">braft源码分析（一）选举和心跳保持部分 - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/169904153">braft源码分析（二）日志复制、配置变更和快照 - 知乎 (zhihu.com)</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>论文笔记：PolarDB Serverless</title>
      <link>https://egolearner.github.io/post/polardb-serverless/</link>
      <pubDate>Sun, 21 Aug 2022 22:06:36 +0800</pubDate>
      
      <guid>https://egolearner.github.io/post/polardb-serverless/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Authors: Wei Cao, Yingqiang Zhang&lt;/li&gt;
&lt;li&gt;Created: August 21, 2022 7:46 AM&lt;/li&gt;
&lt;li&gt;PublishedAt: SIGMOD&lt;/li&gt;
&lt;li&gt;Tags: Database, serverless&lt;/li&gt;
&lt;li&gt;URL: &lt;a href=&#34;https://www.cs.utah.edu/~lifeifei/papers/polardbserverless-sigmod21.pdf&#34;&gt;https://www.cs.utah.edu/~lifeifei/papers/polardbserverless-sigmod21.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Year: 2021&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;summary&#34;&gt;&lt;strong&gt;Summary&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;通过计算、内存和存储的分离，来支持serverless按需分配资源。相当于将单机的实现原语扩展到分布式环境，使用各种方法来解决网络传输引入的问题（如时延、B树一致性）。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<ul>
<li>Authors: Wei Cao, Yingqiang Zhang</li>
<li>Created: August 21, 2022 7:46 AM</li>
<li>PublishedAt: SIGMOD</li>
<li>Tags: Database, serverless</li>
<li>URL: <a href="https://www.cs.utah.edu/~lifeifei/papers/polardbserverless-sigmod21.pdf">https://www.cs.utah.edu/~lifeifei/papers/polardbserverless-sigmod21.pdf</a></li>
<li>Year: 2021</li>
</ul>
<h1 id="summary"><strong>Summary</strong></h1>
<p>通过计算、内存和存储的分离，来支持serverless按需分配资源。相当于将单机的实现原语扩展到分布式环境，使用各种方法来解决网络传输引入的问题（如时延、B树一致性）。</p>
<h2 id="strength"><strong>Strength</strong></h2>
<ul>
<li>serverless，进一步解耦了资源分配。</li>
</ul>
<h2 id="weakness"><strong>Weakness</strong></h2>
<ul>
<li>比较复杂。</li>
<li>复杂场景的实用性一般，比如号称支持Auto Scaling，但是类似双十一的场景应该还支持不了。</li>
</ul>
<h2 id="take-away"><strong>Take Away</strong></h2>
<h1 id="论文内容">论文内容</h1>
<h2 id="概述">概述</h2>
<img src="/static/PolarDB%20Serverless%20A%20Cloud%20Native%20Database%20for%20Dis%207fe5181874d5494aa4df51b19b426dc3/Untitled.png">
<p>云数据库的典型架构，最右为PolarDB serverless（后面简称PS)。</p>
<p>单体机和存储计算分离架构的问题是，资源存在绑定关系，不能方便的按需扩展一种资源而不带来其他资源的浪费。</p>
<p>在PS架构中，cpu, memory和存储都可以独立提升利用率和扩展容量。而且远程内存池的数据页可以被多个数据库进程共享。增加读副本只有少量的本地内存开销。</p>
<p>从架构上来说，类似于将单机的各组件分布式化，所以也需要用类似cache invalidation的机制来保证事务执行的正确性。分布式化后有网络开销，为了让事务执行更快，使用RDMA高速网络连接各组件，并使用RDMA verb来做优化，例如使用RDMA CAS来优化global latch的获取。</p>
<h2 id="背景">背景</h2>
<img src="/static/PolarDB%20Serverless%20A%20Cloud%20Native%20Database%20for%20Dis%207fe5181874d5494aa4df51b19b426dc3/Untitled%201.png">
<p>PolarDB的计算层包括一个主节点（RW）和多个读节点（RO），存储层使用PolarFS。</p>
<p>存储层的每个chunk有三副本，通过Parallel Raft来保证linear serializable。</p>
<p>RW和RO通过redo log来同步内存状态，使用LSN来协调一致性。RW将redo log刷新到PolarFS后②，事务即可以提交。RW将redo log已更新和最新的LSN_RW异步广播到所有的RO节点④。RO收到通知后，从PolarFS拉取redo log的更新，应用到buffer pool中。RO将消费的redo log LSN_RO在响应中回复给RW，然后RW可以清除已消费的redo log，将比min{LSN_RO}更老的脏页在后台刷新到PolarFS⑧。落后太多的RO节点被踢出集群，避免拖慢RW刷新脏页。</p>
<img src="/static/PolarDB%20Serverless%20A%20Cloud%20Native%20Database%20for%20Dis%207fe5181874d5494aa4df51b19b426dc3/Untitled%202.png">
<p>为了保证低延迟，一个数据库实例的计算、内存和存储资源分配在同一PoD下，计算和存储倾向于分配在同一ToR下面。</p>
<h2 id="设计">设计</h2>
<p>和PolarDB架构类似，每个PolarDB serverless实例同样由多个代理节点，一个RW节点和多个RO节点构成，使用PolarFS作为底层存储池。</p>
<p>远程内存引入的问题及解决方案</p>
<ul>
<li>访问延迟。引入分层内存系统和预取等优化。</li>
<li>内存页变为共享资源，需要跨节点互斥机制。</li>
<li>页的传输造成给网络带来负担。PS将redo log写入存储，从日志异步物化page。</li>
</ul>
<h3 id="disaggregated-memory">Disaggregated Memory</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="kr">int</span>  <span class="nx">page_register</span><span class="p">(</span><span class="nx">PageID</span> <span class="nx">page_id</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="kr">const</span> <span class="nx">Address</span> <span class="nx">local_addr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="nx">Address</span><span class="o">&amp;</span> <span class="nx">remote_addr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="nx">Address</span><span class="o">&amp;</span> <span class="nx">pl_addr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="nx">bool</span><span class="o">&amp;</span> <span class="nx">exists</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">int</span>  <span class="nx">page_unregister</span><span class="p">(</span><span class="nx">PageID</span> <span class="nx">page_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">int</span>  <span class="nx">page_read</span><span class="p">(</span><span class="kr">const</span> <span class="nx">Address</span> <span class="nx">local_addr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">               <span class="kr">const</span> <span class="nx">Address</span> <span class="nx">remote_addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">int</span>  <span class="nx">page_write</span><span class="p">(</span><span class="kr">const</span> <span class="nx">Address</span> <span class="nx">local_addr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="kr">const</span> <span class="nx">Address</span> <span class="nx">remote_addr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">int</span>  <span class="nx">page_invalidate</span><span class="p">(</span><span class="nx">PageID</span> <span class="nx">page_id</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>page_invalidate用于RW来invalidate所有RO节点本地的副本。</p>
<ul>
<li>Page Address Table(PAT)记录每个页的位置（slab node id和物理地址）和引用计数。
<ul>
<li>在page_register中，home node通过查询PAT来确定页是否已存在。新创建的页加入PAT中。</li>
<li>在page_unregister中，当一个页的引用计数变为0时，从远程内存池中弹出，并删除PAT的相应项。</li>
</ul>
</li>
<li>Page Invalidation Bitmap(PIB)。对PAT的每个项，在PIB中有一个invalidation位。0指是最新的，1指RW已更新但没刷新到远程内存池中。每个RO节点上也有一个本地PIB。</li>
<li>Page Reference Directory(PRD)。对PAT的每一项，记录引用这个页的数据库节点。PIB和PRD一起用于实现cache coherency。</li>
<li>Page Latch Table(PLT)。PAT的每一项有个全局的latch，用于保证B+树的完整性。</li>
</ul>
<p>存储支持页物化卸载，脏页也可以马上弹出而不需要先刷新。</p>
<p>由于网络延迟，需要本地cache。本地cache的大小采用了经验值远程内存大小/8，128GB.</p>
<p>如果访问的页不在远程内存中，会从PolarFS中加载，然后写入到远程内存中。并非所有从PolarFS中读到的页都需要写入到远程内存中，例如全表扫描的时候。</p>
<img src="/static/PolarDB%20Serverless%20A%20Cloud%20Native%20Database%20for%20Dis%207fe5181874d5494aa4df51b19b426dc3/Untitled%203.png">
<p>在PS中，RW可以将修改的页写回到远程内存中，然后RO马上就可见，因此不需要使用PolarDB中的redo log机制。但是，为了降低网络通信的开销，RW的修改会缓存在本地而不是马上同步到远程内存。因此需要cache invalidation机制。</p>
<p>RW更新本地cached的页后，调用page_invalidate①，它会设置home node上的PIB的相应位，通过查询PRD得到RO节点列表，然后设置这些RO节点上的PIB的相应位。page_invalidate是同步阻塞函数。如果异常的RO节点超时不响应，会被剔出集群以保证page_invalidate成功。</p>
<h3 id="b树结构一致性">B+树结构一致性</h3>
<p>在PS中，只有RW可以修改页，因此不需要防止多个节点导致的写冲突。但Structure Modification Operation(SMO)会同时修改多个页，可能导致RO看到不一致的结构。PS使用PL来解决这个问题。</p>
<p>所有SMO涉及的页需要上PL X锁直到SMO完成。因此所有RO上的读操作需要需要检查PLT看读的页是否有X锁，然后加上S锁。</p>
<p>对RW insert/delete操作，PS采用两步优化。假定不需要有SMO，做乐观树遍历，这时只需要本地latch。如果乐观遍历找到的叶节点页相对满或者空，有可能发生SMO，则再从root开始一次悲观遍历，同时加上X锁和X-PL锁。</p>
<p>为了降低PL锁的成本，PL有粘滞属性，没有读节点的请求时不需要在SMO完成后马上释放。</p>
<p>为了加速PL获取操作，先用RDMA CAS来尝试获取锁。如果快速路径失败，例如给已经有S锁的PL加X锁，再在home node和数据库节点间协调，调用方需要等待协调完成。</p>
<h3 id="快照隔离">快照隔离</h3>
<p>PS基于MVCC来实现SI(快照隔离）。</p>
<p>RW中维护被称为CTS的中心化的时间戳（序列号），负责给所有数据库节点分配递增的时间戳。</p>
<ul>
<li>读写操作从CTS获取两次时间戳，在事务开始时获取cts_commit，在事务结束时获取cts_commit。在事务提交时将cts_commit和修改的记录一起写入。所有的记录和undo记录预留了一列来存储修改它的事务的cts_commit。事务中的读总是返回cts_commit小于事务的cts_read的最新记录。每个版本的记录还存储了修改它的事务id，因此事务认识自己的写。</li>
<li>只读事务只需要在开始时获取cts_read。</li>
</ul>
<p>论文后面讲了如何解决都事务修改的行很多无法立即更新cts_commit的问题，通过查找RW上的CTS日志。</p>
<p>为了优化，使用RDMA CAS来原子的获取和递增CTS时间戳计数器。</p>
<h3 id="页物化卸载page-materialization-offloading">页物化卸载(Page Materialization Offloading)</h3>
<p>传统单体DB会定期将脏页刷新到持久存储上，但在PS上这么做会导致大量网络通信。</p>
<p>论文扩展了PolarFS，将日志和页分开存储为log trunk和page trunk。Redo log先持久化到log trunk，然后异步发送到page trunk，log被应用以更新页。为了重用PolarFS的组件和最小化改动，日志只发送到page trunk的leader节点，再由leader节点物化页和通过ParallelRaft传播更新到其他副本。虽然增加了ApplyLog的延迟，但ApplyLog本身是异步操作不是关键路径。</p>
<img src="/static/PolarDB%20Serverless%20A%20Cloud%20Native%20Database%20for%20Dis%207fe5181874d5494aa4df51b19b426dc3/Untitled%204.png">
<h3 id="auto-scaling">Auto-Scaling</h3>
<p>在版本升级或跨节点迁移时，proxy节点负责维护客户端连接。暂停事务执行，等待100ms，足以让老的RW节点完成大部分的进行中的语句。之后老的节点刷新脏页到共享内存并关机。同时，RW节点attach到共享内存，初始化本地内存状态。最后，proxy连接到新的RW节点，恢复会话状态，转发等待的语句来执行。老的RW节点没来得及完成的长执行的语句，将会在新的RW节点回滚后重新提交。</p>
<p>对于长执行的多语句事务，如批量插入，proxy对每个语句跟踪保存点，发生切换时proxy可以让新的RW node从最新的保存点继续执行。</p>
<p>切换时正在执行的事务需要暂停，PS使用共享内存相比传统的依赖远程存储要快。目前暂停时间为2-3秒。</p>
<h2 id="性能优化">性能优化</h2>
<h3 id="乐观锁">乐观锁</h3>
<p>读节点假定没有SMO。RW维护SMO计数器，SMO_RW，SMO发生时计数器加1，SMO发生时SMO_RW的快照记录到SMO修改的每个页中（记为SMO_page）。在query的开始，获取SMO计数器的值计为SMO_query，RO从root遍历时如果发现SMO_page大于SMO_query，意味着query过程中发生了SMO，需要重试或者回退到悲观锁。</p>
<h3 id="索引感知预取">索引感知预取</h3>
<p>Batched Key Prepare(BKP)的接口接收要预取的一组key，接口被调用时，存储引擎开启后台预取任务，从目标索引中获取需要的key，并在必要时从远程内存或存储中获取相应的数据页。</p>
<h2 id="可靠性和错误恢复">可靠性和错误恢复</h2>
<h3 id="数据库节点恢复">数据库节点恢复</h3>
<p>RO节点可以直接替换。</p>
<p>RW节点分为预期和非预期的节点替换。</p>
<p>**非预期的RW节点失败。**集群管理者CM通过心跳判断RW节点失败时，发起RO节点升级流程。</p>
<ol>
<li>CM通知内存和存储节点拒绝原RW节点之后的写请求。</li>
<li>CM选一个RO节点，通知它升级了，记为RW’。</li>
<li>RW’从每个PolarFS page chunk收集最新版本，LSN_chunk，其中的最小值作为检查点版本LSN_cp。</li>
<li>RW’从持久化PolarFS log chunk上读取redo log记录，从LSN_cp开始读到结束位置LSN_tail，将它们分发到page chunk，等待page chunk来消费redo log和完成恢复。</li>
<li>RW’扫描远程内存池，弹出invalidation位为1的页，以及页版本LSN_page大于LSN_tail的页。</li>
<li>RW’释放所有原RW节点获取的PL锁。</li>
<li>RW’扫描undo header来构建所有活跃事务在原RW节点失败时的状态。</li>
<li>RW’在通知CM完成升级后，准备好接收新请求。</li>
<li>RW’在后台回放undo log来回滚未提交的事务。</li>
</ol>
<p>3、4两步执行ARIES的REDO阶段，并发在许多page chunk节点上执行。</p>
<p>大多数活跃数据仍然存在在远程内存中，可以避免传统主从复制架构的冷数据问题。</p>
<p>**计划内节点退位。**RW节点会做一些清理，例如同步redo log到page chunk，主动释放所有PL锁，写脏页到远程内存，最终刷新redo log到PolarFS。新的RW节点可以省去4、5、6步。另外，新节点可以推迟即位直到活跃事务数变低。</p>
<h3 id="内存节点恢复">内存节点恢复</h3>
<p>home node保存的元数据以同步的方式也保存到slave replica中。home node负责检测slave node的失败。</p>
<h3 id="集群恢复">集群恢复</h3>
<p>极端情况下，所有home node的副本不可用，需要做集群恢复。所有的数据库节点和内存节点从干净状态重启，所有的内存状态从存储重建。初始化之后，RW节点执行并行REDO恢复，然后扫描undo header来找到所有未完成的事务，之后开始服务，并在后台回滚未提交的事务。</p>
<p>集群恢复时有cold cache问题。</p>
<h1 id="参考">参考</h1>
<p><a href="https://zhuanlan.zhihu.com/p/382109937">全新存算分离架构——[SIGMOD2021] PolarDB Serverless: A Cloud Native Database for Disaggregated Data Centers 笔记 - 知乎 (zhihu.com)</a></p>
<p><a href="https://nan01ab.github.io/2021/06/PolarDB-Serverless.html">PolarDB Serverless · Columba M71&rsquo;s Blog (nan01ab.github.io)</a></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
